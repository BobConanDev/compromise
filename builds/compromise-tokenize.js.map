{"version":3,"file":"compromise-tokenize.js","sources":["../src/Term/_id.js","../src/Term/normalize/unicode.js","../src/Term/normalize/isAcronym.js","../src/Term/normalize/clean.js","../src/Term/normalize/reduce.js","../src/Term/parse.js","../src/Term/methods/01-case.js","../src/Term/methods/02-punctuation.js","../src/Term/methods/_doesMatch.js","../src/Term/methods/03-misc.js","../src/Term/methods/04-text.js","../src/Term/methods/_bestTag.js","../src/Term/methods/05-json.js","../src/Term/methods/index.js","../src/Term/tag/fns.js","../src/Term/tag/add.js","../src/Term/tag/unTag.js","../src/Term/tag/canBe.js","../src/Term/tag/index.js","../src/Term/Term.js","../src/Phrase/methods/01-utils.js","../src/Phrase/methods/02-text.js","../src/Phrase/methods/03-change.js","../src/Phrase/insert/append.js","../src/Phrase/insert/prepend.js","../src/Phrase/insert/delete.js","../src/Phrase/methods/04-insert.js","../src/Phrase/methods/05-json.js","../src/Phrase/methods/06-lookahead.js","../src/Phrase/methods/index.js","../src/Phrase/match/02-failFast.js","../src/Phrase/match/03-tryMatch.js","../src/Phrase/match/04-postProcess.js","../src/Doc/match/parseToken.js","../src/Doc/match/syntax.js","../src/Phrase/match/01-matchAll.js","../src/Phrase/match/not.js","../src/Phrase/match/index.js","../src/Phrase/Phrase.js","../src/01-tokenizer/Pool.js","../src/World/data/conjugations.js","../src/01-tokenizer/_linkTerms.js","../src/01-tokenizer/01-sentences.js","../src/01-tokenizer/02-words.js","../src/01-tokenizer/index.js","../src/01-tokenizer/fromJSON.js","../src/World/_data-empty.js","../src/World/tags/tags/nouns.js","../src/World/tags/tags/verbs.js","../src/World/tags/tags/values.js","../src/World/tags/tags/misc.js","../src/World/tags/inference/_color.js","../src/World/tags/inference/_isA.js","../src/World/tags/inference/_notA.js","../src/World/tags/inference/_lineage.js","../src/World/tags/inference/index.js","../src/World/tags/index.js","../_noop.js","../src/World/addWords.js","../src/World/addIrregulars.js","../src/World/data/misc.js","../src/transforms/conjugate/suffixes.js","../src/transforms/conjugate/01-suffixes.js","../src/transforms/conjugate/02-generic.js","../src/transforms/conjugate/index.js","../src/transforms/adjectives/toSuperlative.js","../src/transforms/adjectives/toComparative.js","../src/transforms/adjectives/index.js","../src/transforms/toPlural/_rules.js","../src/transforms/toPlural/index.js","../src/transforms/toSingular/_rules.js","../src/transforms/toSingular/index.js","../src/transforms/toInfinitive/_transform.js","../src/transforms/toInfinitive/_guess.js","../src/World/World.js","../src/World/data/plurals.js","../src/transforms/toInfinitive/index.js","../src/Doc/methods/01-utils.js","../src/Doc/methods/02-accessors.js","../src/Doc/methods/03-match.js","../src/Doc/methods/_setTag.js","../src/Doc/methods/04-tag.js","../src/Doc/methods/05-loops.js","../src/Doc/methods/06-lookup.js","../src/Doc/methods/insert/01-replace.js","../src/Doc/methods/insert/02-insert.js","../src/Doc/methods/output/01-text.js","../src/Doc/methods/output/_offset.js","../src/Doc/methods/output/02-json.js","../src/Doc/methods/output/_debug.js","../src/Doc/methods/output/_topk.js","../src/Doc/methods/output/03-out.js","../src/Doc/methods/transform/01-sort.js","../src/Doc/methods/transform/_methods.js","../src/Doc/methods/transform/02-normalize.js","../src/Doc/methods/transform/03-split.js","../src/Doc/methods/transform/04-case.js","../src/Doc/methods/transform/05-whitespace.js","../src/Doc/methods/transform/06-join.js","../src/Doc/methods/transform/07-contract.js","../src/Doc/methods/index.js","../src/Subset/_simple.js","../src/Subset/Abbreviations.js","../src/Subset/Acronyms.js","../src/Subset/Clauses.js","../src/Subset/Contractions.js","../src/Subset/Lists.js","../src/Subset/Nouns/plural/hasPlural.js","../src/Subset/Nouns/getArticle.js","../src/Subset/Nouns/plural/isPlural/_rules.js","../src/Subset/Nouns/plural/isPlural/index.js","../src/Subset/Nouns/toPossessive.js","../src/Subset/Nouns/parse.js","../src/Subset/Nouns/methods.js","../src/Subset/Nouns/index.js","../src/Subset/Parentheses.js","../src/Subset/Possessives.js","../src/Subset/Quotations.js","../src/Subset/Verbs/toInfinitive/index.js","../src/Subset/Verbs/isPlural.js","../src/Subset/Verbs/toNegative.js","../src/Subset/Verbs/parse.js","../src/Subset/Verbs/conjugate/toBe.js","../src/Subset/Verbs/conjugate/index.js","../src/Subset/Verbs/methods.js","../src/Subset/index.js","../src/Subset/Verbs/index.js","../src/Subset/People.js","../src/Doc/Doc.js","../src/index.js","../src/_version.js"],"sourcesContent":["//this is a not-well-thought-out way to reduce our dependence on `object===object` stuff\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('')\n\n//generates a unique id for this term\nfunction makeId(str) {\n  str = str || '_'\n  let text = str + '-'\n  for (let i = 0; i < 7; i++) {\n    text += chars[Math.floor(Math.random() * chars.length)]\n  }\n  return text\n}\n\nmodule.exports = makeId\n","//a hugely-ignorant, and widely subjective transliteration of latin, cryllic, greek unicode characters to english ascii.\n//approximate visual (not semantic or phonetic) relationship between unicode and ascii characters\n//http://en.wikipedia.org/wiki/List_of_Unicode_characters\n//https://docs.google.com/spreadsheet/ccc?key=0Ah46z755j7cVdFRDM1A2YVpwa1ZYWlpJM2pQZ003M0E\nlet compact = {\n  '!': '¡',\n  '?': '¿Ɂ',\n  '\"': '“”\"❝❞',\n  \"'\": '‘‛❛❜',\n  '-': '—–',\n  a: 'ªÀÁÂÃÄÅàáâãäåĀāĂăĄąǍǎǞǟǠǡǺǻȀȁȂȃȦȧȺΆΑΔΛάαλАадѦѧӐӑӒӓƛɅæ',\n  b: 'ßþƀƁƂƃƄƅɃΒβϐϦБВЪЬвъьѢѣҌҍ',\n  c: '¢©ÇçĆćĈĉĊċČčƆƇƈȻȼͻͼͽϲϹϽϾСсєҀҁҪҫ',\n  d: 'ÐĎďĐđƉƊȡƋƌǷ',\n  e: 'ÈÉÊËèéêëĒēĔĕĖėĘęĚěƎƏƐǝȄȅȆȇȨȩɆɇΈΕΞΣέεξϱϵ϶ЀЁЕЭеѐёҼҽҾҿӖӗӘәӚӛӬӭ',\n  f: 'ƑƒϜϝӺӻҒғſ',\n  g: 'ĜĝĞğĠġĢģƓǤǥǦǧǴǵ',\n  h: 'ĤĥĦħƕǶȞȟΉΗЂЊЋНнђћҢңҤҥҺһӉӊ',\n  I: 'ÌÍÎÏ',\n  i: 'ìíîïĨĩĪīĬĭĮįİıƖƗȈȉȊȋΊΐΪίιϊІЇії',\n  j: 'ĴĵǰȷɈɉϳЈј',\n  k: 'ĶķĸƘƙǨǩΚκЌЖКжкќҚқҜҝҞҟҠҡ',\n  l: 'ĹĺĻļĽľĿŀŁłƚƪǀǏǐȴȽΙӀӏ',\n  m: 'ΜϺϻМмӍӎ',\n  n: 'ÑñŃńŅņŇňŉŊŋƝƞǸǹȠȵΝΠήηϞЍИЙЛПийлпѝҊҋӅӆӢӣӤӥπ',\n  o: 'ÒÓÔÕÖØðòóôõöøŌōŎŏŐőƟƠơǑǒǪǫǬǭǾǿȌȍȎȏȪȫȬȭȮȯȰȱΌΘΟθοσόϕϘϙϬϭϴОФоѲѳӦӧӨөӪӫ',\n  p: 'ƤƿΡρϷϸϼРрҎҏÞ',\n  q: 'Ɋɋ',\n  r: 'ŔŕŖŗŘřƦȐȑȒȓɌɍЃГЯгяѓҐґ',\n  s: 'ŚśŜŝŞşŠšƧƨȘșȿЅѕ',\n  t: 'ŢţŤťŦŧƫƬƭƮȚțȶȾΓΤτϮТт',\n  u: 'µÙÚÛÜùúûüŨũŪūŬŭŮůŰűŲųƯưƱƲǓǔǕǖǗǘǙǚǛǜȔȕȖȗɄΰμυϋύ',\n  v: 'νѴѵѶѷ',\n  w: 'ŴŵƜωώϖϢϣШЩшщѡѿ',\n  x: '×ΧχϗϰХхҲҳӼӽӾӿ',\n  y: 'ÝýÿŶŷŸƳƴȲȳɎɏΎΥΫγψϒϓϔЎУучўѰѱҮүҰұӮӯӰӱӲӳ',\n  z: 'ŹźŻżŽžƩƵƶȤȥɀΖζ',\n}\n//decompress data into two hashes\nlet unicode = {}\nObject.keys(compact).forEach(function(k) {\n  compact[k].split('').forEach(function(s) {\n    unicode[s] = k\n  })\n})\n\nconst killUnicode = str => {\n  let chars = str.split('')\n  chars.forEach((s, i) => {\n    if (unicode[s]) {\n      chars[i] = unicode[s]\n    }\n  })\n  return chars.join('')\n}\nmodule.exports = killUnicode\n// console.log(killUnicode('bjŏȒk—Ɏó'));\n","const periodAcronym = /([A-Z]\\.)+[A-Z]?,?$/\nconst oneLetterAcronym = /^[A-Z]\\.,?$/\nconst noPeriodAcronym = /[A-Z]{2,}('s|,)?$/\nconst lowerCaseAcronym = /([a-z]\\.){2,}[a-z]\\.?$/\n\nconst isAcronym = function(str) {\n  //like N.D.A\n  if (periodAcronym.test(str) === true) {\n    return true\n  }\n  //like c.e.o\n  if (lowerCaseAcronym.test(str) === true) {\n    return true\n  }\n  //like 'F.'\n  if (oneLetterAcronym.test(str) === true) {\n    return true\n  }\n  //like NDA\n  if (noPeriodAcronym.test(str) === true) {\n    return true\n  }\n  return false\n}\nmodule.exports = isAcronym\n","const killUnicode = require('./unicode')\nconst isAcronym = require('./isAcronym')\nconst hasSlash = /[a-z\\u00C0-\\u00FF] ?\\/ ?[a-z\\u00C0-\\u00FF]/\n\n/** some basic operations on a string to reduce noise */\nconst clean = function(str) {\n  str = str || ''\n  str = str.toLowerCase()\n  str = str.trim()\n  let original = str\n  //(very) rough ASCII transliteration -  bjŏrk -> bjork\n  str = killUnicode(str)\n  //rough handling of slashes - 'see/saw'\n  if (hasSlash.test(str) === true) {\n    str = str.replace(/\\/.*/, '')\n  }\n  //#tags, @mentions\n  str = str.replace(/^[#@]/, '')\n  //punctuation\n  str = str.replace(/[,;.!?]+$/, '')\n  // coerce single curly quotes\n  str = str.replace(/[\\u0027\\u0060\\u00B4\\u2018\\u2019\\u201A\\u201B\\u2032\\u2035\\u2039\\u203A]+/g, \"'\")\n  // coerce double curly quotes\n  str = str.replace(\n    /[\\u0022\\u00AB\\u00BB\\u201C\\u201D\\u201E\\u201F\\u2033\\u2034\\u2036\\u2037\\u2E42\\u301D\\u301E\\u301F\\uFF02]+/g,\n    '\"'\n  )\n  //coerce Unicode ellipses\n  str = str.replace(/\\u2026/g, '...')\n  //en-dash\n  str = str.replace(/\\u2013/g, '-')\n  //lookin'->looking (make it easier for conjugation)\n  str = str.replace(/([aeiou][ktrp])in$/, '$1ing')\n  //turn re-enactment to reenactment\n  if (/^(re|un)-?[^aeiou]./.test(str) === true) {\n    str = str.replace('-', '')\n  }\n  //strip leading & trailing grammatical punctuation\n  if (/^[:;]/.test(str) === false) {\n    str = str.replace(/\\.{3,}$/g, '')\n    str = str.replace(/[\",\\.!:;\\?\\)]+$/g, '')\n    str = str.replace(/^['\"\\(]+/g, '')\n  }\n  //do this again..\n  str = str.trim()\n  //oh shucks,\n  if (str === '') {\n    str = original\n  }\n  //compact acronyms\n  if (isAcronym(str)) {\n    str = str.replace(/\\./g, '')\n  }\n  //nice-numbers\n  str = str.replace(/([0-9]),([0-9])/g, '$1$2')\n  return str\n}\n\nmodule.exports = clean\n// console.log(normalize('Dr. V Cooper'));\n","/** reduced is one step further than clean */\nconst reduced = function(str) {\n  // remove apostrophes\n  str = str.replace(/['’]s$/, '')\n  str = str.replace(/s['’]$/, 's')\n  return str\n}\nmodule.exports = reduced\n","const normalize = require('./normalize/clean')\nconst reduce = require('./normalize/reduce')\n// basically, tokenize for terms.\n\n//all punctuation marks, from https://en.wikipedia.org/wiki/Punctuation\n//we have slightly different rules for start/end - like #hashtags.\nconst startings = /^[ \\n\\t\\.’'\\[\\](){}⟨⟩:,،、‒–—―…!.‹›«»‐\\-?‘’;\\/⁄·\\&*\\•^†‡°¡¿※№÷×ºª%‰+−=‱¶′″‴§~|‖¦©℗®℠™¤₳฿\\u0022|\\uFF02|\\u0027|\\u201C|\\u2018|\\u201F|\\u201B|\\u201E|\\u2E42|\\u201A|\\u00AB|\\u2039|\\u2035|\\u2036|\\u2037|\\u301D|\\u0060|\\u301F]+/\nconst endings = /[ \\n\\t\\.’'\\[\\](){}⟨⟩:,،、‒–—―…!.‹›«»‐\\-?‘’;\\/⁄·\\&*@\\•^†‡°¡¿※#№÷×ºª‰+−=‱¶′″‴§~|‖¦©℗®℠™¤₳฿\\u0022|\\uFF02|\\u0027|\\u201D|\\u2019|\\u201D|\\u2019|\\u201D|\\u201D|\\u2019|\\u00BB|\\u203A|\\u2032|\\u2033|\\u2034|\\u301E|\\u00B4|\\u301E]+$/\n\n//money = ₵¢₡₢$₫₯֏₠€ƒ₣₲₴₭₺₾ℳ₥₦₧₱₰£៛₽₹₨₪৳₸₮₩¥\nconst hasSlash = /\\//\nconst hasApostrophe = /['’]/\nconst hasAcronym = /^[a-z]\\.([a-z]\\.)+/i\nconst minusNumber = /^[-+\\.][0-9]/\n\n/** turn given text into a parsed-up object\n * seperate the 'meat' of the word from the whitespace+punctuation\n */\nconst parseTerm = str => {\n  let original = str\n  let pre = ''\n  let post = ''\n  str = str.replace(startings, found => {\n    pre = found\n    // support '-40'\n    if ((pre === '-' || pre === '+' || pre === '.') && minusNumber.test(str)) {\n      pre = ''\n      return found\n    }\n    return ''\n  })\n  str = str.replace(endings, found => {\n    post = found\n    // keep s-apostrophe - \"flanders'\" or \"chillin'\"\n    if (hasApostrophe.test(found) && /[sn]['’]$/.test(original) && hasApostrophe.test(pre) === false) {\n      post = post.replace(hasApostrophe, '')\n      return `'`\n    }\n    //keep end-period in acronym\n    if (hasAcronym.test(str) === true) {\n      post = post.replace(/\\./, '')\n      return '.'\n    }\n    return ''\n  })\n  //we went too far..\n  if (str === '') {\n    // do a very mild parse, and hope for the best.\n    original = original.replace(/ *$/, after => {\n      post = after || ''\n      return ''\n    })\n    str = original\n    pre = ''\n    post = post\n  }\n  // create the various forms of our text,\n  let clean = normalize(str)\n  const parsed = {\n    text: str,\n    clean: clean,\n    reduced: reduce(clean),\n    pre: pre,\n    post: post,\n  }\n  // support aliases for slashes\n  if (hasSlash.test(str)) {\n    str.split(hasSlash).forEach(word => {\n      parsed.alias = parsed.alias || {}\n      parsed.alias[word.trim()] = true\n    })\n  }\n  return parsed\n}\nmodule.exports = parseTerm\n","const titleCase = /^[A-Z][a-z'\\u00C0-\\u00FF]/\nconst upperCase = /^[A-Z]+s?$/\n\n/** convert all text to uppercase */\nexports.toUpperCase = function() {\n  this.text = this.text.toUpperCase()\n  return this\n}\n\n/** convert all text to lowercase */\nexports.toLowerCase = function() {\n  this.text = this.text.toLowerCase()\n  return this\n}\n\n/** only set the first letter to uppercase\n * leave any existing uppercase alone\n */\nexports.toTitleCase = function() {\n  this.text = this.text.replace(/^ *[a-z\\u00C0-\\u00FF]/, x => x.toUpperCase()) //support unicode?\n  return this\n}\n\n/** if all letters are uppercase */\nexports.isUpperCase = function() {\n  return upperCase.test(this.text)\n}\n/** if the first letter is uppercase, and the rest are lowercase */\nexports.isTitleCase = function() {\n  return titleCase.test(this.text)\n}\nexports.titleCase = exports.isTitleCase\n","// these methods are called with '@hasComma' in the match syntax\n// various unicode quotation-mark formats\nconst startQuote = /(\\u0022|\\uFF02|\\u0027|\\u201C|\\u2018|\\u201F|\\u201B|\\u201E|\\u2E42|\\u201A|\\u00AB|\\u2039|\\u2035|\\u2036|\\u2037|\\u301D|\\u0060|\\u301F)/\nconst endQuote = /(\\u0022|\\uFF02|\\u0027|\\u201D|\\u2019|\\u201D|\\u2019|\\u201D|\\u201D|\\u2019|\\u00BB|\\u203A|\\u2032|\\u2033|\\u2034|\\u301E|\\u00B4|\\u301E)/\n\n/** search the term's 'post' punctuation  */\nexports.hasPost = function(punct) {\n  return this.post.indexOf(punct) !== -1\n}\n/** search the term's 'pre' punctuation  */\nexports.hasPre = function(punct) {\n  return this.pre.indexOf(punct) !== -1\n}\n\n/** does it have a quotation symbol?  */\nexports.hasQuote = function() {\n  return startQuote.test(this.pre) || endQuote.test(this.post)\n}\nexports.hasQuotation = exports.hasQuote\n\n/** does it have a comma?  */\nexports.hasComma = function() {\n  return this.hasPost(',')\n}\n\n/** does it end in a period? */\nexports.hasPeriod = function() {\n  return this.hasPost('.') === true && this.hasPost('...') === false\n}\n\n/** does it end in an exclamation */\nexports.hasExclamation = function() {\n  return this.hasPost('!')\n}\n\n/** does it end with a question mark? */\nexports.hasQuestionMark = function() {\n  return this.hasPost('?') || this.hasPost('¿')\n}\n\n/** is there a ... at the end? */\nexports.hasEllipses = function() {\n  return this.hasPost('..') || this.hasPost('…') || this.hasPre('..') || this.hasPre('…')\n}\n\n/** is there a semicolon after this word? */\nexports.hasSemicolon = function() {\n  return this.hasPost(';')\n}\n\n/** is there a slash '/' in this word? */\nexports.hasSlash = function() {\n  return /\\//.test(this.text)\n}\n\n/** a hyphen connects two words like-this */\nexports.hasHyphen = function() {\n  const hyphen = /(-|–|—)/\n  return hyphen.test(this.post) || hyphen.test(this.pre)\n}\n/** a dash separates words - like that */\nexports.hasDash = function() {\n  const hyphen = / (-|–|—) /\n  return hyphen.test(this.post) || hyphen.test(this.pre)\n}\n\n/** is it multiple words combinded */\nexports.hasContraction = function() {\n  return Boolean(this.implicit)\n}\n\n/** try to sensibly put this punctuation mark into the term */\nexports.addPunctuation = function(punct) {\n  // dont add doubles\n  if (punct === ',' || punct === ';') {\n    this.post = this.post.replace(punct, '')\n  }\n  this.post = punct + this.post\n  return this\n}\n","//declare it up here\nlet wrapMatch = function() {}\n\n/** ignore optional/greedy logic, straight-up term match*/\nconst doesMatch = function(t, reg, index, length) {\n  // support id matches\n  if (reg.id === t.id) {\n    return true\n  }\n  // support '.'\n  if (reg.anything === true) {\n    return true\n  }\n  // support '^' (in parentheses)\n  if (reg.start === true && index !== 0) {\n    return false\n  }\n  // support '$' (in parentheses)\n  if (reg.end === true && index !== length - 1) {\n    return false\n  }\n  //support a text match\n  if (reg.word !== undefined) {\n    //match contractions\n    if (t.implicit !== null && t.implicit === reg.word) {\n      return true\n    }\n    // term aliases for slashes and things\n    if (t.alias !== undefined && t.alias.hasOwnProperty(reg.word)) {\n      return true\n    }\n    // support ~ match\n    if (reg.soft === true && reg.word === t.root) {\n      return true\n    }\n    //match either .clean or .text\n    return reg.word === t.clean || reg.word === t.text || reg.word === t.reduced\n  }\n  //support #Tag\n  if (reg.tag !== undefined) {\n    return t.tags[reg.tag] === true\n  }\n  //support @method\n  if (reg.method !== undefined) {\n    if (typeof t[reg.method] === 'function' && t[reg.method]() === true) {\n      return true\n    }\n    return false\n  }\n  //support /reg/\n  if (reg.regex !== undefined) {\n    return reg.regex.test(t.clean)\n  }\n  //support (one|two)\n  if (reg.choices !== undefined) {\n    // try to support && operator\n    if (reg.operator === 'and') {\n      // must match them all\n      return reg.choices.every(r => wrapMatch(t, r, index, length))\n    }\n    // or must match one\n    return reg.choices.some(r => wrapMatch(t, r, index, length))\n  }\n  return false\n}\n\n// wrap result for !negative match logic\nwrapMatch = function(t, reg, index, length) {\n  let result = doesMatch(t, reg, index, length)\n  if (reg.negative === true) {\n    return !result\n  }\n  return result\n}\n\nmodule.exports = wrapMatch\n","const doesMatch = require('./_doesMatch')\nconst isAcronym = require('../normalize/isAcronym')\n\n// these tags aren't juicy-enough\nconst boring = {}\n\n/** check a match object against this term */\nexports.doesMatch = function(reg, index, length) {\n  return doesMatch(this, reg, index, length)\n}\n\n/** does this term look like an acronym? */\nexports.isAcronym = function() {\n  return isAcronym(this.text)\n}\n\n/** is this term implied by a contraction? */\nexports.isImplicit = function() {\n  return this.text === '' && Boolean(this.implicit)\n}\n\n/** does the term have at least one good tag? */\nexports.isKnown = function() {\n  return Object.keys(this.tags).some(t => boring[t] !== true)\n}\n\n/** cache the root property of the term */\nexports.setRoot = function(world) {\n  let transform = world.transforms\n  let str = this.implicit || this.clean\n  if (this.tags.Plural) {\n    str = transform.toSingular(str, world)\n  }\n  if (this.tags.Verb && !this.tags.Negative && !this.tags.Infinitive) {\n    let tense = null\n    if (this.tags.PastTense) {\n      tense = 'PastTense'\n    } else if (this.tags.Gerund) {\n      tense = 'Gerund'\n    } else if (this.tags.PresentTense) {\n      tense = 'PresentTense'\n    } else if (this.tags.Participle) {\n      tense = 'Participle'\n    } else if (this.tags.Actor) {\n      tense = 'Actor'\n    }\n    str = transform.toInfinitive(str, world, tense)\n  }\n  this.root = str\n}\n","const killUnicode = require('../normalize/unicode')\nconst hasSpace = /[\\s-]/\nconst isUpperCase = /^[A-Z-]+$/\n\n// const titleCase = str => {\n//   return str.charAt(0).toUpperCase() + str.substr(1)\n// }\n\n/** return various text formats of this term */\nexports.textOut = function(options, showPre, showPost) {\n  options = options || {}\n  let word = this.text\n  let before = this.pre\n  let after = this.post\n\n  // -word-\n  if (options.reduced === true) {\n    word = this.reduced || ''\n  }\n  if (options.root === true) {\n    word = this.root || ''\n  }\n  if (options.implicit === true && this.implicit) {\n    word = this.implicit || ''\n  }\n  if (options.normal === true) {\n    word = this.clean || this.text || ''\n  }\n  if (options.root === true) {\n    word = this.root || this.reduced || ''\n  }\n  if (options.unicode === true) {\n    word = killUnicode(word)\n  }\n  // cleanup case\n  if (options.titlecase === true) {\n    if (this.tags.ProperNoun && !this.titleCase()) {\n      // word = titleCase(word)\n    } else if (this.tags.Acronym) {\n      word = word.toUpperCase() //uppercase acronyms\n    } else if (isUpperCase.test(word) && !this.tags.Acronym) {\n      // lowercase everything else\n      word = word.toLowerCase()\n    }\n  }\n  if (options.lowercase === true) {\n    word = word.toLowerCase()\n  }\n  // remove the '.'s from 'F.B.I.' (safely)\n  if (options.acronyms === true && this.tags.Acronym) {\n    word = word.replace(/\\./g, '')\n  }\n\n  // -before/after-\n  if (options.whitespace === true || options.root === true) {\n    before = ''\n    after = ' '\n    if ((hasSpace.test(this.post) === false || options.last) && !this.implicit) {\n      after = ''\n    }\n  }\n  if (options.punctuation === true && !options.root) {\n    //normalized end punctuation\n    if (this.hasPost('.') === true) {\n      after = '.' + after\n    } else if (this.hasPost('?') === true) {\n      after = '?' + after\n    } else if (this.hasPost('!') === true) {\n      after = '!' + after\n    } else if (this.hasPost(',') === true) {\n      after = ',' + after\n    } else if (this.hasEllipses() === true) {\n      after = '...' + after\n    }\n  }\n  if (showPre !== true) {\n    before = ''\n  }\n  if (showPost !== true) {\n    // let keep = after.match(/\\)/) || ''\n    after = '' //keep //after.replace(/[ .?!,]+/, '')\n  }\n  // remove the '.' from 'Mrs.' (safely)\n  if (options.abbreviations === true && this.tags.Abbreviation) {\n    after = after.replace(/^\\./, '')\n  }\n  return before + word + after\n}\n","const boringTags = {\n  Auxiliary: 1,\n  Possessive: 1,\n}\n\n/** a subjective ranking of tags kinda tfidf-based */\nconst rankTags = function(term, world) {\n  let tags = Object.keys(term.tags)\n  const tagSet = world.tags\n  tags = tags.sort((a, b) => {\n    //bury the tags we dont want\n    if (boringTags[b] || !tagSet[b]) {\n      return -1\n    }\n    // unknown tags are interesting\n    if (!tagSet[b]) {\n      return 1\n    }\n    if (!tagSet[a]) {\n      return 0\n    }\n    // then sort by #of parent tags (most-specific tags first)\n    if (tagSet[a].lineage.length > tagSet[b].lineage.length) {\n      return 1\n    }\n    if (tagSet[a].isA.length > tagSet[b].isA.length) {\n      return -1\n    }\n    return 0\n  })\n  return tags\n}\nmodule.exports = rankTags\n","const rankTags = require('./_bestTag')\n\nconst jsonDefault = {\n  text: true,\n  tags: true,\n  implicit: true,\n  whitespace: true,\n\n  clean: false,\n  id: false,\n  index: false,\n  offset: false,\n  bestTag: false,\n}\n\n/** return various metadata for this term */\nexports.json = function(options, world) {\n  options = options || {}\n  options = Object.assign({}, jsonDefault, options)\n  let result = {}\n\n  // default on\n  if (options.text) {\n    result.text = this.text\n  }\n  if (options.normal) {\n    result.normal = this.normal\n  }\n\n  if (options.tags) {\n    result.tags = Object.keys(this.tags)\n  }\n\n  // default off\n  if (options.clean) {\n    result.clean = this.clean\n  }\n  if (options.id || options.offset) {\n    result.id = this.id\n  }\n  if (options.implicit && this.implicit !== null) {\n    result.implicit = this.implicit\n  }\n  if (options.whitespace) {\n    result.pre = this.pre\n    result.post = this.post\n  }\n  if (options.bestTag) {\n    result.bestTag = rankTags(this, world)[0]\n  }\n\n  return result\n}\n","module.exports = Object.assign(\n  {},\n  require('./01-case'),\n  require('./02-punctuation'),\n  require('./03-misc'),\n  require('./04-text'),\n  require('./05-json')\n)\n","function isClientSide() {\n  return typeof window !== 'undefined' && window.document\n}\n\n/** add spaces at the end */\nconst padEnd = function(str, width) {\n  str = str.toString()\n  while (str.length < width) {\n    str += ' '\n  }\n  return str\n}\n\n/** output for verbose-mode */\nexports.logTag = function(t, tag, reason) {\n  if (isClientSide()) {\n    console.log('%c' + padEnd(t.clean, 3) + '  + ' + tag + ' ', 'color: #6accb2;')\n    return\n  }\n  //server-side\n  let log = '\\x1b[33m' + padEnd(t.clean, 15) + '\\x1b[0m + \\x1b[32m' + tag + '\\x1b[0m '\n  if (reason) {\n    log = padEnd(log, 35) + ' ' + reason + ''\n  }\n  console.log(log)\n}\n\n/** output for verbose mode  */\nexports.logUntag = function(t, tag, reason) {\n  if (isClientSide()) {\n    console.log('%c' + padEnd(t.clean, 3) + '  - ' + tag + ' ', 'color: #AB5850;')\n    return\n  }\n  //server-side\n  let log = '\\x1b[33m' + padEnd(t.clean, 3) + ' \\x1b[31m - #' + tag + '\\x1b[0m '\n  if (reason) {\n    log = padEnd(log, 35) + ' ' + reason\n  }\n  console.log(log)\n}\n\nexports.isArray = function(arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]'\n}\n\nexports.titleCase = str => {\n  return str.charAt(0).toUpperCase() + str.substr(1)\n}\n","const fns = require('./fns')\n\n/** add a tag, and its descendents, to a term */\nconst addTag = function(t, tag, reason, world) {\n  let tagset = world.tags\n  //support '.' or '-' notation for skipping the tag\n  if (tag === '' || tag === '.' || tag === '-') {\n    return\n  }\n  if (tag[0] === '#') {\n    tag = tag.replace(/^#/, '')\n  }\n  tag = fns.titleCase(tag)\n  //if we already got this one\n  if (t.tags[tag] === true) {\n    return\n  }\n  // log it?\n  const isVerbose = world.isVerbose()\n  if (isVerbose === true) {\n    fns.logTag(t, tag, reason)\n  }\n  //add tag\n  t.tags[tag] = true //whee!\n\n  //check tagset for any additional things to do...\n  if (tagset.hasOwnProperty(tag) === true) {\n    //add parent Tags\n    tagset[tag].isA.forEach(down => {\n      t.tags[down] = true\n      if (isVerbose === true) {\n        fns.logTag(t, '→ ' + down)\n      }\n    })\n    //remove any contrary tags\n    t.unTag(tagset[tag].notA, '←', world)\n  }\n}\n\n/** support an array of tags */\nconst addTags = function(term, tags, reason, world) {\n  if (typeof tags !== 'string') {\n    for (let i = 0; i < tags.length; i++) {\n      addTag(term, tags[i], reason, world)\n    }\n    // tags.forEach(tag => addTag(term, tag, reason, world))\n  } else {\n    addTag(term, tags, reason, world)\n  }\n}\nmodule.exports = addTags\n","const fns = require('./fns')\n\n/** remove this tag, and its descentents from the term */\nconst unTag = function(t, tag, reason, world) {\n  const isVerbose = world.isVerbose()\n  //support '*' for removing all tags\n  if (tag === '*') {\n    t.tags = {}\n    return t\n  }\n  // remove the tag\n  if (t.tags[tag] === true) {\n    delete t.tags[tag]\n    //log in verbose-mode\n    if (isVerbose === true) {\n      fns.logUntag(t, tag, reason)\n    }\n  }\n  //delete downstream tags too\n  const tagset = world.tags\n  if (tagset[tag]) {\n    let lineage = tagset[tag].lineage\n    for (let i = 0; i < lineage.length; i++) {\n      if (t.tags[lineage[i]] === true) {\n        delete t.tags[lineage[i]]\n        if (isVerbose === true) {\n          fns.logUntag(t, ' - ' + lineage[i])\n        }\n      }\n    }\n  }\n  return t\n}\n\n//handle an array of tags\nconst untagAll = function(term, tags, reason, world) {\n  if (typeof tags !== 'string' && tags) {\n    for (let i = 0; i < tags.length; i++) {\n      unTag(term, tags[i], reason, world)\n    }\n    return\n  }\n  unTag(term, tags, reason, world)\n}\nmodule.exports = untagAll\n","'use strict'\n\n//recursively-check compatibility of this tag and term\nconst canBe = function(term, tag, world) {\n  const tagset = world.tags\n  // cleanup tag\n  if (tag[0] === '#') {\n    tag = tag.replace(/^#/, '')\n  }\n  //fail-fast\n  if (tagset[tag] === undefined) {\n    return true\n  }\n  //loop through tag's contradictory tags\n  let enemies = tagset[tag].notA || []\n  for (let i = 0; i < enemies.length; i++) {\n    if (term.tags[enemies[i]] === true) {\n      return false\n    }\n  }\n  if (tagset[tag].isA !== undefined) {\n    return canBe(term, tagset[tag].isA, world) //recursive\n  }\n  return true\n}\n\nmodule.exports = canBe\n","const add = require('./add')\nconst unTag = require('./unTag')\nconst canBe = require('./canBe')\n\n/** add a tag or tags, and their descendents to this term\n * @param  {string | string[]} tags - a tag or tags\n * @param {string?} [reason] a clue for debugging\n */\nexports.tag = function(tags, reason, world) {\n  add(this, tags, reason, world)\n  return this\n}\n\n/** only tag this term if it's consistent with it's current tags */\nexports.tagSafe = function(tags, reason, world) {\n  if (canBe(this, tags, world)) {\n    add(this, tags, reason, world)\n  }\n  return this\n}\n\n/** remove a tag or tags, and their descendents from this term\n * @param {string | string[]} tags  - a tag or tags\n * @param {string?} [reason] a clue for debugging\n */\nexports.unTag = function(tags, reason, world) {\n  unTag(this, tags, reason, world)\n  return this\n}\n\n/** is this tag consistent with the word's current tags?\n * @param {string | string[]} tags - a tag or tags\n * @returns {boolean}\n */\nexports.canBe = function(tags, world) {\n  return canBe(this, tags, world)\n}\n","const makeId = require('./_id')\nconst parseTerm = require('./parse')\nconst methods = require('./methods')\nconst tagMethods = require('./tag')\n\nclass Term {\n  constructor(text = '') {\n    text = String(text)\n    let obj = parseTerm(text)\n    // the various forms of our text\n    this.text = obj.text || ''\n    this.clean = obj.clean\n    this.reduced = obj.reduced\n    this.root = obj.root || null\n    this.implicit = obj.implicit || null\n\n    this.pre = obj.pre || ''\n    this.post = obj.post || ''\n    this.tags = {}\n    this.prev = null\n    this.next = null\n    this.id = makeId(obj.clean)\n    this.isA = 'Term' // easier than .constructor...\n    // support alternative matches\n    if (obj.alias) {\n      this.alias = obj.alias\n    }\n  }\n  /** set the text of the Term to something else*/\n  set(str) {\n    let obj = parseTerm(str)\n\n    this.text = obj.text\n    this.clean = obj.clean\n    return this\n  }\n}\n\n/** create a deep-copy of this term */\nTerm.prototype.clone = function() {\n  let term = new Term(this.text)\n  term.pre = this.pre\n  term.post = this.post\n  term.tags = Object.assign({}, this.tags)\n  //use the old id, so it can be matched with .match(doc)\n  // term.id = this.id\n  return term\n}\n\nObject.assign(Term.prototype, methods)\nObject.assign(Term.prototype, tagMethods)\n\nmodule.exports = Term\n","/** return a flat array of Term objects */\nexports.terms = function(n) {\n  if (this.length === 0) {\n    return []\n  }\n  // use cache, if it exists\n  if (this.cache.terms) {\n    if (n !== undefined) {\n      return this.cache.terms[n]\n    }\n    return this.cache.terms\n  }\n  let terms = [this.pool.get(this.start)]\n  for (let i = 0; i < this.length - 1; i += 1) {\n    let id = terms[terms.length - 1].next\n    if (id === null) {\n      // throw new Error('linked-list broken')\n      console.error(\"Compromise error: Linked list broken in phrase '\" + this.start + \"'\")\n      break\n    }\n    let term = this.pool.get(id)\n    terms.push(term)\n    //return this one?\n    if (n !== undefined && n === i) {\n      return terms[n]\n    }\n  }\n  // this.cache.terms = terms\n  if (n !== undefined) {\n    return terms[n]\n  }\n  return terms\n}\n\n/** return a shallow or deep copy of this phrase  */\nexports.clone = function(isShallow) {\n  if (isShallow) {\n    return this.buildFrom(this.start, this.length)\n  }\n  //how do we clone part of the pool?\n  let terms = this.terms()\n  let newTerms = terms.map(t => t.clone())\n  //connect these new ids up\n  newTerms.forEach((t, i) => {\n    //add it to the pool..\n    this.pool.add(t)\n    if (newTerms[i + 1]) {\n      t.next = newTerms[i + 1].id\n    }\n    if (newTerms[i - 1]) {\n      t.prev = newTerms[i - 1].id\n    }\n  })\n  return this.buildFrom(newTerms[0].id, newTerms.length)\n}\n\n/** return last term object */\nexports.lastTerm = function() {\n  let terms = this.terms()\n  return terms[terms.length - 1]\n}\n\n/** quick lookup for a term id */\nexports.hasId = function(wantId) {\n  if (this.length === 0 || !wantId) {\n    return false\n  }\n  if (this.start === wantId) {\n    return true\n  }\n  // use cache, if available\n  if (this.cache.terms) {\n    let terms = this.cache.terms\n    for (let i = 0; i < terms.length; i++) {\n      if (terms[i].id === wantId) {\n        return true\n      }\n    }\n    return false\n  }\n  // otherwise, go through each term\n  let lastId = this.start\n  for (let i = 0; i < this.length - 1; i += 1) {\n    let term = this.pool.get(lastId)\n    if (term === undefined) {\n      console.error(`Compromise error: Linked list broken. Missing term '${lastId}' in phrase '${this.start}'\\n`)\n      // throw new Error('linked List error')\n      return false\n    }\n    if (term.next === wantId) {\n      return true\n    }\n    lastId = term.next\n  }\n  return false\n}\n\n/** how many seperate, non-empty words is it? */\nexports.wordCount = function() {\n  return this.terms().filter(t => t.text !== '').length\n}\n","const trimEnd = function(str) {\n  return str.replace(/ +$/, '')\n}\n\n/** produce output in the given format */\nexports.text = function(options = {}, isFirst, isLast) {\n  if (typeof options === 'string') {\n    if (options === 'normal') {\n      options = {\n        whitespace: true,\n        unicode: true,\n        lowercase: true,\n        punctuation: true,\n        acronyms: true,\n        abbreviations: true,\n        implicit: true,\n        normal: true,\n      }\n    } else if (options === 'clean') {\n      options = {\n        titlecase: false,\n        lowercase: true,\n        punctuation: true,\n        whitespace: true,\n        unicode: true,\n        implicit: true,\n      }\n    } else if (options === 'reduced') {\n      options = {\n        titlecase: false,\n        lowercase: true,\n        punctuation: false, //FIXME: reversed?\n        whitespace: true,\n        unicode: true,\n        implicit: true,\n        reduced: true,\n      }\n    } else if (options === 'root') {\n      options = {\n        titlecase: false,\n        lowercase: true,\n        punctuation: true,\n        whitespace: true,\n        unicode: true,\n        implicit: true,\n        root: true,\n      }\n    } else {\n      options = {}\n    }\n  }\n  let terms = this.terms()\n  //this this phrase a complete sentence?\n  let isFull = false\n  if (terms[0] && terms[0].prev === null && terms[terms.length - 1].next === null) {\n    isFull = true\n  }\n  let text = terms.reduce((str, t, i) => {\n    options.last = isLast && i === terms.length - 1\n    let showPre = true\n    let showPost = true\n    if (isFull === false) {\n      // dont show beginning whitespace\n      if (i === 0 && isFirst) {\n        showPre = false\n      }\n      // dont show end-whitespace\n      if (i === terms.length - 1 && isLast) {\n        showPost = false\n      }\n    }\n    let txt = t.textOut(options, showPre, showPost)\n    // if (options.titlecase && i === 0) {\n    // txt = titleCase(txt)\n    // }\n    return str + txt\n  }, '')\n  //full-phrases show punctuation, but not whitespace\n  if (isFull === true && isLast) {\n    text = trimEnd(text)\n  }\n  if (options.trim === true) {\n    text = text.trim()\n  }\n  return text\n}\n","/** remove start and end whitespace */\nexports.trim = function() {\n  let terms = this.terms()\n  if (terms.length > 0) {\n    //trim starting\n    terms[0].pre = terms[0].pre.replace(/^\\s+/, '')\n    //trim ending\n    let lastTerm = terms[terms.length - 1]\n    lastTerm.post = lastTerm.post.replace(/\\s+$/, '')\n  }\n  return this\n}\n","const endOfSentence = /[.?!]\\s*$/\n\n// replacing a 'word.' with a 'word!'\nconst combinePost = function(before, after) {\n  //only transfer the whitespace\n  if (endOfSentence.test(after)) {\n    let whitespace = before.match(/\\s*$/)\n    return after + whitespace\n  }\n  return before\n}\n\n//add whitespace to the start of the second bit\nconst addWhitespace = function(beforeTerms, newTerms) {\n  // add any existing pre-whitespace to beginning\n  newTerms[0].pre = beforeTerms[0].pre\n  let lastTerm = beforeTerms[beforeTerms.length - 1]\n\n  //add any existing punctuation to end of our new terms\n  let newTerm = newTerms[newTerms.length - 1]\n  newTerm.post = combinePost(lastTerm.post, newTerm.post)\n  // remove existing punctuation\n  lastTerm.post = ''\n\n  //before ←[space]  - after\n  if (lastTerm.post === '') {\n    lastTerm.post += ' '\n  }\n}\n\n//insert this segment into the linked-list\nconst stitchIn = function(beforeTerms, newTerms, pool) {\n  let lastBefore = beforeTerms[beforeTerms.length - 1]\n  let lastNew = newTerms[newTerms.length - 1]\n  let afterId = lastBefore.next\n  //connect ours in (main → newPhrase)\n  lastBefore.next = newTerms[0].id\n  //stich the end in  (newPhrase → after)\n  lastNew.next = afterId\n  //do it backwards, too\n  if (afterId) {\n    // newPhrase ← after\n    let afterTerm = pool.get(afterId)\n    afterTerm.prev = lastNew.id\n  }\n  // before ← newPhrase\n  let beforeId = beforeTerms[0].id\n  if (beforeId) {\n    let newTerm = newTerms[0]\n    newTerm.prev = beforeId\n  }\n}\n\n// avoid stretching a phrase twice.\nconst unique = function(list) {\n  return list.filter((o, i) => {\n    return list.indexOf(o) === i\n  })\n}\n\n//append one phrase onto another.\nconst appendPhrase = function(before, newPhrase, doc) {\n  let beforeTerms = before.cache.terms || before.terms()\n  let newTerms = newPhrase.cache.terms || newPhrase.terms()\n  //spruce-up the whitespace issues\n  addWhitespace(beforeTerms, newTerms)\n  //insert this segment into the linked-list\n  stitchIn(beforeTerms, newTerms, before.pool)\n\n  // stretch!\n  // make each effected phrase longer\n  let toStretch = [before]\n  let hasId = before.start\n  let docs = [doc]\n\n  docs = docs.concat(doc.parents()) // find them all!\n\n  docs.forEach(parent => {\n    // only the phrases that should change\n    let shouldChange = parent.list.filter(p => {\n      return p.hasId(hasId)\n    })\n    toStretch = toStretch.concat(shouldChange)\n  })\n  // don't double-count a phrase\n  toStretch = unique(toStretch)\n  toStretch.forEach(p => {\n    p.length += newPhrase.length\n  })\n  return before\n}\nmodule.exports = appendPhrase\n","const hasSpace = / /\n\n//a new space needs to be added, either on the new phrase, or the old one\n// '[new] [◻old]'   -or-   '[old] [◻new] [old]'\nconst addWhitespace = function(newTerms) {\n  //add a space before our new text?\n  // add a space after our text\n  let lastTerm = newTerms[newTerms.length - 1]\n  if (hasSpace.test(lastTerm.post) === false) {\n    lastTerm.post += ' '\n  }\n  return\n}\n\n//insert this segment into the linked-list\nconst stitchIn = function(main, newPhrase, newTerms) {\n  // [newPhrase] → [main]\n  let lastTerm = newTerms[newTerms.length - 1]\n  lastTerm.next = main.start\n  // [before] → [main]\n  let pool = main.pool\n  let start = pool.get(main.start)\n  if (start.prev) {\n    let before = pool.get(start.prev)\n    before.next = newPhrase.start\n  }\n  //do it backwards, too\n  // before ← newPhrase\n  newTerms[0].prev = main.terms(0).prev\n  // newPhrase ← main\n  main.terms(0).prev = lastTerm.id\n}\n\nconst unique = function(list) {\n  return list.filter((o, i) => {\n    return list.indexOf(o) === i\n  })\n}\n\n//append one phrase onto another\nconst joinPhrase = function(original, newPhrase, doc) {\n  const starterId = original.start\n  let newTerms = newPhrase.terms()\n  //spruce-up the whitespace issues\n  addWhitespace(newTerms, original)\n  //insert this segment into the linked-list\n  stitchIn(original, newPhrase, newTerms)\n  //increase the length of our phrases\n  let toStretch = [original]\n  let docs = [doc]\n  docs = docs.concat(doc.parents())\n  docs.forEach(d => {\n    // only the phrases that should change\n    let shouldChange = d.list.filter(p => {\n      return p.hasId(starterId) || p.hasId(newPhrase.start)\n    })\n    toStretch = toStretch.concat(shouldChange)\n  })\n  // don't double-count\n  toStretch = unique(toStretch)\n  // stretch these phrases\n  toStretch.forEach(p => {\n    p.length += newPhrase.length\n    // change the start too, if necessary\n    if (p.start === starterId) {\n      p.start = newPhrase.start\n    }\n  })\n  return original\n}\nmodule.exports = joinPhrase\n","//recursively decrease the length of all the parent phrases\nconst shrinkAll = function(doc, id, deleteLength, after) {\n  let arr = doc.parents()\n  arr.push(doc)\n\n  arr.forEach(d => {\n    //find our phrase to shrink\n    let phrase = d.list.find(p => p.hasId(id))\n    if (!phrase) {\n      return\n    }\n    phrase.length -= deleteLength\n    // does it start with this soon-removed word?\n    if (phrase.start === id) {\n      phrase.start = after.id\n    }\n  })\n  // cleanup empty phrase objects\n  doc.list = doc.list.filter(p => {\n    if (!p.start || !p.length) {\n      return false\n    }\n    return true\n  })\n}\n\n/** wrap the linked-list around these terms\n * so they don't appear any more\n */\nconst deletePhrase = function(phrase, doc) {\n  let pool = doc.pool()\n  let terms = phrase.cache.terms || phrase.terms()\n\n  //grab both sides of the chain,\n  let prev = pool.get(terms[0].prev) || {}\n  let after = pool.get(terms[terms.length - 1].next) || {}\n\n  if (terms[0].implicit && prev.implicit) {\n    prev.set(prev.implicit)\n    prev.post += ' '\n  }\n\n  // //first, change phrase lengths\n  shrinkAll(doc, phrase.start, phrase.length, after)\n\n  // connect [prev]->[after]\n  if (prev) {\n    prev.next = after.id\n  }\n  // connect [prev]<-[after]\n  if (after) {\n    after.prev = prev.id\n  }\n\n  // lastly, actually delete the terms from the pool?\n  // for (let i = 0; i < terms.length; i++) {\n  //   pool.remove(terms[i].id)\n  // }\n}\nmodule.exports = deletePhrase\n","const append = require('../insert/append')\nconst prepend = require('../insert/prepend')\nconst deletePhrase = require('../insert/delete')\n// const tokenize = require('../../01-tokenizer')\n\n/** put this text at the end */\nexports.append = function(newPhrase, doc) {\n  append(this, newPhrase, doc)\n  return this\n}\n\n/** add this text to the beginning */\nexports.prepend = function(newPhrase, doc) {\n  prepend(this, newPhrase, doc)\n  return this\n}\n\nexports.delete = function(doc) {\n  deletePhrase(this, doc)\n  return this\n}\n\n// stich-in newPhrase, stretch 'doc' + parents\nexports.replace = function(newPhrase, doc) {\n  //add it do the end\n  let firstLength = this.length\n  append(this, newPhrase, doc)\n\n  //delete original terms\n  let tmp = this.buildFrom(this.start, this.length)\n  tmp.length = firstLength\n  deletePhrase(tmp, doc)\n}\n\n/**\n * Turn this phrase object into 3 phrase objects\n */\nexports.splitOn = function(p) {\n  let terms = this.terms()\n  let result = {\n    before: null,\n    match: null,\n    after: null,\n  }\n  let index = terms.findIndex(t => t.id === p.start)\n  if (index === -1) {\n    return result\n  }\n  //make all three sections into phrase-objects\n  let start = terms.slice(0, index)\n  if (start.length > 0) {\n    result.before = this.buildFrom(start[0].id, start.length)\n  }\n  let match = terms.slice(index, index + p.length)\n  if (match.length > 0) {\n    result.match = this.buildFrom(match[0].id, match.length)\n  }\n  let end = terms.slice(index + p.length, terms.length)\n  if (end.length > 0) {\n    result.after = this.buildFrom(end[0].id, end.length, this.pool)\n  }\n  return result\n}\n","/** return json metadata for this phrase */\nexports.json = function(options = {}, world) {\n  let res = {}\n  // text data\n  if (options.text) {\n    res.text = this.text()\n  }\n  if (options.normal) {\n    res.normal = this.text('normal')\n  }\n  if (options.clean) {\n    res.clean = this.text('clean')\n  }\n  if (options.reduced) {\n    res.reduced = this.text('reduced')\n  }\n  if (options.root) {\n    res.root = this.text('root')\n  }\n  if (options.trim) {\n    if (res.text) {\n      res.text = res.text.trim()\n    }\n    if (res.normal) {\n      res.normal = res.normal.trim()\n    }\n    if (res.reduced) {\n      res.reduced = res.reduced.trim()\n    }\n  }\n  // terms data\n  if (options.terms) {\n    if (options.terms === true) {\n      options.terms = {}\n    }\n    res.terms = this.terms().map(t => t.json(options.terms, world))\n  }\n  return res\n}\n","/** match any terms after this phrase */\nexports.lookAhead = function(regs) {\n  // if empty match string, return everything after\n  if (!regs) {\n    regs = '.*'\n  }\n  let pool = this.pool\n  // get a list of all terms preceding our start\n  let terms = []\n  const getAfter = function(id) {\n    let term = pool.get(id)\n    if (!term) {\n      return\n    }\n    terms.push(term)\n    if (term.prev) {\n      getAfter(term.next) //recursion\n    }\n  }\n  let all = this.terms()\n  let lastTerm = all[all.length - 1]\n  getAfter(lastTerm.next)\n  if (terms.length === 0) {\n    return []\n  }\n  // got the terms, make a phrase from them\n  let p = this.buildFrom(terms[0].id, terms.length)\n  return p.match(regs)\n}\n\n/** match any terms before this phrase */\nexports.lookBehind = function(regs) {\n  // if empty match string, return everything before\n  if (!regs) {\n    regs = '.*'\n  }\n  let pool = this.pool\n  // get a list of all terms preceding our start\n  let terms = []\n  const getBefore = function(id) {\n    let term = pool.get(id)\n    if (!term) {\n      return\n    }\n    terms.push(term)\n    if (term.prev) {\n      getBefore(term.prev) //recursion\n    }\n  }\n  let term = pool.get(this.start)\n  getBefore(term.prev)\n  if (terms.length === 0) {\n    return []\n  }\n  // got the terms, make a phrase from them\n  let p = this.buildFrom(terms[terms.length - 1].id, terms.length)\n  return p.match(regs)\n}\n","module.exports = Object.assign(\n  {},\n  require('./01-utils'),\n  require('./02-text'),\n  require('./03-change'),\n  require('./04-insert'),\n  require('./05-json'),\n  require('./06-lookahead')\n)\n","// try to avoid doing the match\nconst failFast = function(p, regs) {\n  if (regs.length === 0) {\n    return true\n  }\n  for (let i = 0; i < regs.length; i += 1) {\n    let reg = regs[i]\n\n    //   //logical quick-ones\n    if (reg.optional !== true && reg.negative !== true) {\n      //start/end impossibilites\n      if (reg.start === true && i > 0) {\n        return true\n      }\n      // has almost no effect\n      if (p.cache.words !== undefined && reg.word !== undefined && p.cache.words.hasOwnProperty(reg.word) !== true) {\n        return true\n      }\n    }\n    //this is not possible\n    if (reg.anything === true && reg.negative === true) {\n      return true\n    }\n  }\n  return false\n}\nmodule.exports = failFast\n","const makeId = require('../../Term/_id')\n// i formally apologize for how complicated this is.\n\n//found a match? it's greedy? keep going!\nconst getGreedy = function(terms, t, reg, until, index, length) {\n  let start = t\n  for (; t < terms.length; t += 1) {\n    //stop for next-reg match\n    if (until && terms[t].doesMatch(until, index + t, length)) {\n      return t\n    }\n    let count = t - start + 1\n    // is it max-length now?\n    if (reg.max !== undefined && count === reg.max) {\n      return t\n    }\n    //stop here\n    if (terms[t].doesMatch(reg, index + t, length) === false) {\n      // is it too short?\n      if (reg.min !== undefined && count < reg.min) {\n        return null\n      }\n      return t\n    }\n  }\n  return t\n}\n\n//'unspecific greedy' is a weird situation.\nconst greedyTo = function(terms, t, nextReg, index, length) {\n  //if there's no next one, just go off the end!\n  if (!nextReg) {\n    return terms.length\n  }\n  //otherwise, we're looking for the next one\n  for (; t < terms.length; t += 1) {\n    if (terms[t].doesMatch(nextReg, index + t, length) === true) {\n      return t\n    }\n  }\n  //guess it doesn't exist, then.\n  return null\n}\n\n// get or create named group\nconst getOrCreateGroup = function(namedGroups, namedGroupId, terms, startIndex, reg) {\n  const g = namedGroups[namedGroupId]\n\n  if (g) {\n    return g\n  }\n\n  const { id } = terms[startIndex]\n\n  namedGroups[namedGroupId] = {\n    group: reg.named.toString(),\n    start: id,\n    length: 0,\n  }\n\n  return namedGroups[namedGroupId]\n}\n\n/** tries to match a sequence of terms, starting from here */\nconst tryHere = function(terms, regs, index, length) {\n  let captures = []\n  const namedGroups = {}\n  let previousGroupId = null\n  let t = 0\n  // we must satisfy each rule in 'regs'\n  for (let r = 0; r < regs.length; r += 1) {\n    let reg = regs[r]\n\n    // Check if this reg has a named capture group\n    const isNamedGroup = typeof reg.named === 'string' || typeof reg.named === 'number'\n    let namedGroupId = null\n\n    // Reuse previous capture group if same\n    if (isNamedGroup) {\n      const prev = regs[r - 1]\n      if (prev && prev.named === reg.named && previousGroupId) {\n        namedGroupId = previousGroupId\n      } else {\n        namedGroupId = makeId(reg.named)\n        // namedGroupId = terms[t].id\n        previousGroupId = namedGroupId\n      }\n    }\n\n    //should we fail here?\n    if (!terms[t]) {\n      //are all remaining regs optional?\n      const hasNeeds = regs.slice(r).some(remain => !remain.optional)\n      if (hasNeeds === false) {\n        break\n      }\n      // have unmet needs\n      return [false, null]\n    }\n\n    //support 'unspecific greedy' .* properly\n    if (reg.anything === true && reg.greedy === true) {\n      let skipto = greedyTo(terms, t, regs[r + 1], reg, index, length)\n      // ensure it's long enough\n      if (reg.min !== undefined && skipto - t < reg.min) {\n        return [false, null]\n      }\n      // reduce it back, if it's too long\n      if (reg.max !== undefined && skipto - t > reg.max) {\n        t = t + reg.max\n        continue\n      }\n\n      if (skipto === null) {\n        return [false, null] //couldn't find it\n      }\n\n      // is it really this easy?....\n      if (reg.named || isNamedGroup) {\n        captures.push(t)\n        captures.push(skipto - 1)\n\n        if (isNamedGroup) {\n          const g = getOrCreateGroup(namedGroups, namedGroupId, terms, t, reg)\n\n          // Update group\n          g.length = skipto - t\n        }\n      }\n\n      t = skipto\n\n      continue\n    }\n\n    //if it looks like a match, continue\n    //we have a special case where an end-anchored greedy match may need to\n    //start matching before the actual end; we do this by (temporarily!)\n    //removing the \"end\" property from the matching token... since this is\n    //very situation-specific, we *only* do this when we really need to.\n    if (\n      reg.anything === true ||\n      (reg.end === true &&\n        reg.greedy === true &&\n        index + t < length - 1 &&\n        terms[t].doesMatch(Object.assign({}, reg, { end: false }), index + t, length) === true) ||\n      terms[t].doesMatch(reg, index + t, length) === true\n    ) {\n      let startAt = t\n      // okay, it was a match, but if it optional too,\n      // we should check the next reg too, to skip it?\n      if (reg.optional && regs[r + 1]) {\n        // does the next reg match it too?\n        if (terms[t].doesMatch(regs[r + 1], index + t, length) === true) {\n          // but does the next reg match the next term??\n          // only skip if it doesn't\n          if (!terms[t + 1] || terms[t + 1].doesMatch(regs[r + 1], index + t, length) === false) {\n            r += 1\n          }\n        }\n      }\n      //advance to the next term!\n      t += 1\n      //check any ending '$' flags\n      if (reg.end === true) {\n        //if this isn't the last term, refuse the match\n        if (t !== terms.length && reg.greedy !== true) {\n          return [false, null]\n        }\n      }\n\n      //try keep it going!\n      if (reg.greedy === true) {\n        // for greedy checking, we no longer care about the reg.start\n        // value, and leaving it can cause failures for anchored greedy\n        // matches.  ditto for end-greedy matches: we need an earlier non-\n        // ending match to succceed until we get to the actual end.\n        t = getGreedy(terms, t, Object.assign({}, reg, { start: false, end: false }), regs[r + 1], index, length)\n        if (t === null) {\n          return [false, null] //greedy was too short\n        }\n        // if this was also an end-anchor match, check to see we really\n        // reached the end\n        if (reg.end === true && index + t !== length) {\n          return [false, null] //greedy didn't reach the end\n        }\n      }\n      if (reg.named || isNamedGroup) {\n        captures.push(startAt)\n\n        //add greedy-end to capture\n        if (t > 1 && reg.greedy) {\n          captures.push(t - 1)\n        }\n\n        // Create capture group if missing\n        if (isNamedGroup) {\n          const g = getOrCreateGroup(namedGroups, namedGroupId, terms, startAt, reg)\n\n          // Update group - add greedy or increment length\n          if (t > 1 && reg.greedy) {\n            g.length += t - startAt\n          } else {\n            g.length++\n          }\n        }\n      }\n\n      continue\n    }\n\n    //bah, who cares, keep going\n    if (reg.optional === true) {\n      continue\n    }\n    // should we skip-over an implicit word?\n    if (terms[t].isImplicit() && regs[r - 1] && terms[t + 1]) {\n      // does the next one match?\n      if (terms[t + 1].doesMatch(reg, index + t, length)) {\n        t += 2\n        continue\n      }\n    }\n    // console.log('   ❌\\n\\n')\n    return [false, null]\n  }\n\n  //we got to the end of the regs, and haven't failed!\n  //try to only return our [captured] segment\n  if (captures.length > 0) {\n    //make sure the array is the full-length we'd return anyways\n    let arr = terms.slice(captures[0], captures[captures.length - 1] + 1)\n    //make sure the array is t-length (so we skip ahead full-length)\n    for (let tmp = 0; tmp < t; tmp++) {\n      arr[tmp] = arr[tmp] || null //these get cleaned-up after\n    }\n    return [arr, namedGroups]\n  }\n  //return our result\n  return [terms.slice(0, t), namedGroups]\n}\nmodule.exports = tryHere\n","const postProcess = function(terms, regs, matches) {\n  if (!matches || matches.length === 0) {\n    return matches\n  }\n  // ensure end reg has the end term\n  let atEnd = regs.some(r => r.end)\n  if (atEnd) {\n    let lastTerm = terms[terms.length - 1]\n    matches = matches.filter(arr => arr.indexOf(lastTerm) !== -1)\n  }\n  return matches\n}\nmodule.exports = postProcess\n","/* break-down a match expression into this:\n{\n  word:'',\n  tag:'',\n  regex:'',\n\n  start:false,\n  end:false,\n  negative:false,\n  anything:false,\n  greedy:false,\n  optional:false,\n\n  named:'',\n  choices:[],\n}\n*/\nconst hasMinMax = /\\{([0-9]+,?[0-9]*)\\}/\nconst andSign = /&&/\nconst captureName = new RegExp(/^<(\\S+)>/)\n\nconst titleCase = str => {\n  return str.charAt(0).toUpperCase() + str.substr(1)\n}\n\nconst end = function(str) {\n  return str[str.length - 1]\n}\nconst start = function(str) {\n  return str[0]\n}\nconst stripStart = function(str) {\n  return str.substr(1)\n}\nconst stripEnd = function(str) {\n  return str.substr(0, str.length - 1)\n}\nconst stripBoth = function(str) {\n  str = stripStart(str)\n  str = stripEnd(str)\n  return str\n}\n\n//\nconst parseToken = function(w) {\n  let obj = {}\n  //collect any flags (do it twice)\n  for (let i = 0; i < 2; i += 1) {\n    //back-flags\n    if (end(w) === '+') {\n      obj.greedy = true\n      w = stripEnd(w)\n    }\n    if (w !== '*' && end(w) === '*' && w !== '\\\\*') {\n      obj.greedy = true\n      w = stripEnd(w)\n    }\n    if (end(w) === '?') {\n      obj.optional = true\n      w = stripEnd(w)\n    }\n    if (end(w) === '$') {\n      obj.end = true\n      w = stripEnd(w)\n    }\n    //front-flags\n    if (start(w) === '^') {\n      obj.start = true\n      w = stripStart(w)\n    }\n    if (start(w) === '!') {\n      obj.negative = true\n      w = stripStart(w)\n    }\n    //wrapped-flags\n    if (start(w) === '(' && end(w) === ')') {\n      // support (one && two)\n      if (andSign.test(w)) {\n        obj.choices = w.split(andSign)\n        obj.operator = 'and'\n      } else {\n        obj.choices = w.split('|')\n        obj.operator = 'or'\n      }\n      //remove '(' and ')'\n      obj.choices[0] = stripStart(obj.choices[0])\n      let last = obj.choices.length - 1\n      obj.choices[last] = stripEnd(obj.choices[last])\n      // clean up the results\n      obj.choices = obj.choices.map(s => s.trim())\n      obj.choices = obj.choices.filter(s => s)\n      //recursion alert!\n      obj.choices = obj.choices.map(parseToken)\n      w = ''\n    }\n    //capture group (this one can span multiple-terms)\n    if (start(w) === '[' || end(w) === ']') {\n      obj.named = true\n      w = w.replace(/^\\[/, '')\n      w = w.replace(/\\]$/, '')\n\n      // Use capture group name\n      if (start(w) === '<') {\n        const res = captureName.exec(w)\n\n        if (res.length >= 2) {\n          obj.named = res[1]\n          w = w.replace(res[0], '')\n        }\n      }\n    }\n    //regex\n    if (start(w) === '/' && end(w) === '/') {\n      w = stripBoth(w)\n      obj.regex = new RegExp(w) //potential vuln - security/detect-non-literal-regexp\n      return obj\n    }\n    //soft-match\n    if (start(w) === '~' && end(w) === '~') {\n      w = stripBoth(w)\n      obj.soft = true\n      obj.word = w\n      return obj\n    }\n  }\n  // support #Tag{0,9}\n  if (hasMinMax.test(w) === true) {\n    w = w.replace(hasMinMax, (a, b) => {\n      let arr = b.split(/,/g)\n      if (arr.length === 1) {\n        // '{3}'\tExactly three times\n        obj.min = Number(arr[0])\n        obj.max = Number(arr[0])\n      } else {\n        // '{2,4}' Two to four times\n        // '{3,}' Three or more times\n        obj.min = Number(arr[0])\n        obj.max = Number(arr[1] || 999)\n      }\n      obj.greedy = true\n      return ''\n    })\n  }\n\n  //do the actual token content\n  if (start(w) === '#') {\n    obj.tag = stripStart(w)\n    obj.tag = titleCase(obj.tag)\n    return obj\n  }\n  //dynamic function on a term object\n  if (start(w) === '@') {\n    obj.method = stripStart(w)\n    return obj\n  }\n  if (w === '.') {\n    obj.anything = true\n    return obj\n  }\n  //support alone-astrix\n  if (w === '*') {\n    obj.anything = true\n    obj.greedy = true\n    obj.optional = true\n    return obj\n  }\n  if (w) {\n    //somehow handle encoded-chars?\n    w = w.replace('\\\\*', '*')\n    w = w.replace('\\\\.', '.')\n    obj.word = w.toLowerCase()\n  }\n  return obj\n}\nmodule.exports = parseToken\n","const parseToken = require('./parseToken')\n// const cache = {}\n\nconst isNamed = function(capture) {\n  return typeof capture === 'string' || typeof capture === 'number'\n}\n\nconst isArray = function(arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]'\n}\n\n//split-up by (these things)\nconst byParentheses = function(str) {\n  let arr = str.split(/([\\^\\[\\!]*\\(.*?\\)[?+*]*\\]?\\$?)/)\n  arr = arr.map(s => s.trim())\n  return arr\n}\n\nconst byWords = function(arr) {\n  let words = []\n  arr.forEach(a => {\n    //keep brackets lumped together\n    if (/^[[^_/]?\\(/.test(a[0])) {\n      words.push(a)\n      return\n    }\n    let list = a.split(' ')\n    list = list.filter(w => w)\n    words = words.concat(list)\n  })\n  return words\n}\n\n//turn an array into a 'choices' list\nconst byArray = function(arr) {\n  return [\n    {\n      choices: arr.map(s => {\n        return {\n          word: s,\n        }\n      }),\n    },\n  ]\n}\n\nconst getLastTrue = (arr, start) => {\n  const last = arr.length - 1 - arr.reverse().findIndex(t => t === true)\n\n  for (let j = start + 1; j < last; j++) {\n    // Don't fill in if there's a named group ahead\n    if (isNamed(arr[j])) {\n      return start\n    }\n  }\n\n  return last\n}\n\nconst postProcess = function(tokens) {\n  // ensure there's only one consecutive capture group.\n  let count = tokens.filter(t => t.named === true || isNamed(t.named)).length\n  if (count > 1) {\n    let captureArr = tokens.map(t => t.named)\n    let first = captureArr.findIndex(t => t === true || isNamed(t))\n    let last = getLastTrue(captureArr, first)\n\n    //'fill in' capture groups between start-end\n    for (let i = first; i < last + 1; i++) {\n      // Don't replace named groups\n      if (isNamed(tokens[i].named)) {\n        continue\n      }\n      const { named } = tokens[first]\n      tokens[i].named = named\n    }\n  }\n\n  return tokens\n}\n\nconst fromDoc = function(doc) {\n  if (!doc || !doc.list || !doc.list[0]) {\n    return []\n  }\n  let ids = []\n  doc.list.forEach(p => {\n    p.terms().forEach(t => {\n      ids.push({ id: t.id })\n    })\n  })\n  return [{ choices: ids, greedy: true }]\n}\n\n/** parse a match-syntax string into json */\nconst syntax = function(input) {\n  // fail-fast\n  if (input === null || input === undefined || input === '') {\n    return []\n  }\n  //try to support a ton of different formats:\n  if (typeof input === 'object') {\n    if (isArray(input)) {\n      if (input.length === 0 || !input[0]) {\n        return []\n      }\n\n      //is it a pre-parsed reg-list?\n      if (typeof input[0] === 'object') {\n        return input\n      }\n      //support a flat array of normalized words\n      if (typeof input[0] === 'string') {\n        return byArray(input)\n      }\n    }\n    //support passing-in a compromise object as a match\n    if (input && input.isA === 'Doc') {\n      return fromDoc(input)\n    }\n    return []\n  }\n  if (typeof input === 'number') {\n    input = String(input) //go for it?\n  }\n  let tokens = byParentheses(input)\n  tokens = byWords(tokens)\n  tokens = tokens.map(parseToken)\n  //clean up anything weird\n  tokens = postProcess(tokens)\n  // console.log(JSON.stringify(tokens, null, 2))\n  return tokens\n}\n\n// const memoizeSyntax = function(input) {\n//   if (typeof input === 'string' && cache.hasOwnProperty(input)) {\n//     return cache[input]\n//   }\n//   let res = syntax(input)\n//   cache[input] = res\n//   return res\n// }\nmodule.exports = syntax\n","const failFast = require('./02-failFast')\nconst tryMatch = require('./03-tryMatch')\nconst postProcess = require('./04-postProcess')\nconst syntax = require('../../Doc/match/syntax')\n\n/**  returns a simple array of arrays */\nconst matchAll = function(p, regs, matchOne = false) {\n  //if we forgot to parse it..\n  if (typeof regs === 'string') {\n    regs = syntax(regs)\n  }\n  //try to dismiss it, at-once\n  if (failFast(p, regs) === true) {\n    return []\n  }\n\n  //any match needs to be this long, at least\n  const minLength = regs.filter(r => r.optional !== true).length\n  let terms = p.cache.terms || p.terms()\n  let matches = []\n\n  //optimisation for '^' start logic\n  if (regs[0].start === true) {\n    let [match, groups] = tryMatch(terms, regs, 0, terms.length)\n    if (match !== false && match.length > 0) {\n      matches.push(match)\n    }\n    // remove (intentional) null results\n    matches = matches.map(arr => {\n      return arr.filter(t => t)\n    })\n\n    //add to names if named capture group\n    if (groups && Object.keys(groups).length > 0) {\n      p.names = Object.assign({}, p.names, groups)\n    }\n\n    return postProcess(terms, regs, matches)\n  }\n  //try starting, from every term\n  for (let i = 0; i < terms.length; i += 1) {\n    // slice may be too short\n    if (i + minLength > terms.length) {\n      break\n    }\n    //try it!\n    let [match, groups] = tryMatch(terms.slice(i), regs, i, terms.length)\n    if (match !== false && match.length > 0) {\n      //zoom forward!\n      i += match.length - 1\n      //[capture-groups] return some null responses\n      match = match.filter(m => m)\n      matches.push(match)\n\n      //save new capture groups\n      if (groups && Object.keys(groups).length > 0) {\n        p.names = Object.assign({}, p.names, groups)\n      }\n\n      //ok, maybe that's enough?\n      if (matchOne === true) {\n        return postProcess(terms, regs, matches)\n      }\n    }\n  }\n  return postProcess(terms, regs, matches)\n}\nmodule.exports = matchAll\n","const matchAll = require('./01-matchAll')\n\n/** return anything that doesn't match.\n * returns a simple array of arrays\n */\nconst notMatch = function(p, regs) {\n  let found = {}\n  let arr = matchAll(p, regs)\n  arr.forEach(ts => {\n    ts.forEach(t => {\n      found[t.id] = true\n    })\n  })\n  //return anything not found\n  let terms = p.terms()\n  let result = []\n  let current = []\n  terms.forEach(t => {\n    if (found[t.id] === true) {\n      if (current.length > 0) {\n        result.push(current)\n        current = []\n      }\n      return\n    }\n    current.push(t)\n  })\n  if (current.length > 0) {\n    result.push(current)\n  }\n  return result\n}\nmodule.exports = notMatch\n","const matchAll = require('./01-matchAll')\nconst notMatch = require('./not')\n\n/** return an array of matching phrases */\nexports.match = function(str, justOne = false) {\n  let matches = matchAll(this, str, justOne)\n  //make them phrase objects\n  matches = matches.map(list => {\n    return this.buildFrom(list[0].id, list.length)\n  })\n  return matches\n}\n\n/** return boolean if one match is found */\nexports.has = function(str) {\n  let matches = matchAll(this, str, true)\n  return matches.length > 0\n}\n\n/** remove all matches from the result */\nexports.not = function(str) {\n  let matches = notMatch(this, str)\n  //make them phrase objects\n  matches = matches.map(list => {\n    return this.buildFrom(list[0].id, list.length)\n  })\n  return matches\n}\n\n/** return a list of phrases that can have this tag */\nexports.canBe = function(tag, world) {\n  let results = []\n  let terms = this.cache.terms || this.terms()\n  let previous = false\n  for (let i = 0; i < terms.length; i += 1) {\n    let can = terms[i].canBe(tag, world)\n    if (can === true) {\n      if (previous === true) {\n        //add it to the end\n        results[results.length - 1].push(terms[i])\n      } else {\n        results.push([terms[i]]) //make a new one\n      }\n      previous = can\n    }\n  }\n  //turn them into Phrase objects\n  results = results\n    .filter(a => a.length > 0)\n    .map(arr => {\n      return this.buildFrom(arr[0].id, arr.length)\n    })\n  return results\n}\n","const methods = require('./methods')\nconst matchMethods = require('./match')\n// const tokenize = require('../01-tokenizer')\n\nclass Phrase {\n  constructor(id, length, pool) {\n    this.start = id\n    this.length = length\n    this.isA = 'Phrase' // easier than .constructor...\n    Object.defineProperty(this, 'pool', {\n      enumerable: false,\n      writable: true,\n      value: pool,\n    })\n    Object.defineProperty(this, 'cache', {\n      enumerable: false,\n      writable: true,\n      value: {},\n    })\n    Object.defineProperty(this, 'names', {\n      enumerable: false,\n      writable: true,\n      value: {},\n    })\n  }\n}\n\n/** create a new Phrase object from an id and length */\nPhrase.prototype.buildFrom = function(id, length) {\n  let p = new Phrase(id, length, this.pool)\n  if (this.cache) {\n    p.cache = this.cache\n    if (length !== this.length) {\n      p.cache.terms = null\n    }\n  }\n\n  if (this.names) {\n    p.names = this.names\n  }\n\n  return p\n}\n\n//apply methods\nObject.assign(Phrase.prototype, matchMethods)\nObject.assign(Phrase.prototype, methods)\n\n//apply aliases\nconst aliases = {\n  term: 'terms',\n}\nObject.keys(aliases).forEach(k => (Phrase.prototype[k] = Phrase.prototype[aliases[k]]))\n\nmodule.exports = Phrase\n","/** a key-value store of all terms in our Document */\nclass Pool {\n  constructor(words = {}) {\n    //quiet this property in console.logs\n    Object.defineProperty(this, 'words', {\n      enumerable: false,\n      value: words,\n    })\n  }\n  /** throw a new term object in */\n  add(term) {\n    this.words[term.id] = term\n    return this\n  }\n  /** find a term by it's id */\n  get(id) {\n    return this.words[id]\n  }\n  /** find a term by it's id */\n  remove(id) {\n    delete this.words[id]\n  }\n  merge(pool) {\n    Object.assign(this.words, pool.words)\n    return this\n  }\n  /** helper method */\n  stats() {\n    return {\n      words: Object.keys(this.words).length,\n    }\n  }\n}\n\n/** make a deep-copy of all terms */\nPool.prototype.clone = function() {\n  let keys = Object.keys(this.words)\n  let words = keys.reduce((h, k) => {\n    let t = this.words[k].clone()\n    h[t.id] = t\n    return h\n  }, {})\n  return new Pool(words)\n}\n\nmodule.exports = Pool\n","// a list of irregular verb conjugations\n// used in verbs().conjugate()\n// but also added to our lexicon\n\n//use shorter key-names\nconst mapping = {\n  g: 'Gerund',\n  prt: 'Participle',\n  perf: 'PerfectTense',\n  pst: 'PastTense',\n  fut: 'FuturePerfect',\n  pres: 'PresentTense',\n  pluperf: 'Pluperfect',\n  a: 'Actor',\n}\n\n// '_' in conjugations is the infinitive form\nlet conjugations = {\n  act: {\n    a: '_or',\n  },\n  ache: {\n    pst: 'ached',\n    g: 'aching',\n  },\n  age: {\n    g: 'ageing',\n    pst: 'aged',\n    pres: 'ages',\n  },\n  aim: {\n    a: '_er',\n    g: '_ing',\n    pst: '_ed',\n  },\n  arise: {\n    prt: '_n',\n    pst: 'arose',\n  },\n  babysit: {\n    a: '_ter',\n    pst: 'babysat',\n  },\n  ban: {\n    a: '',\n    g: '_ning',\n    pst: '_ned',\n  },\n  be: {\n    a: '',\n    g: 'am',\n    prt: 'been',\n    pst: 'was',\n    pres: 'is',\n  },\n  beat: {\n    a: '_er',\n    g: '_ing',\n    prt: '_en',\n  },\n  become: {\n    prt: '_',\n  },\n  begin: {\n    g: '_ning',\n    prt: 'begun',\n    pst: 'began',\n  },\n  being: {\n    g: 'are',\n    pst: 'were',\n    pres: 'are',\n  },\n  bend: {\n    prt: 'bent',\n  },\n  bet: {\n    a: '_ter',\n    prt: '_',\n  },\n  bind: {\n    pst: 'bound',\n  },\n  bite: {\n    g: 'biting',\n    prt: 'bitten',\n    pst: 'bit',\n  },\n  bleed: {\n    prt: 'bled',\n    pst: 'bled',\n  },\n  blow: {\n    prt: '_n',\n    pst: 'blew',\n  },\n  boil: {\n    a: '_er',\n  },\n  brake: {\n    prt: 'broken',\n  },\n  break: {\n    pst: 'broke',\n  },\n  breed: {\n    pst: 'bred',\n  },\n  bring: {\n    prt: 'brought',\n    pst: 'brought',\n  },\n  broadcast: {\n    pst: '_',\n  },\n  budget: {\n    pst: '_ed',\n  },\n  build: {\n    prt: 'built',\n    pst: 'built',\n  },\n  burn: {\n    prt: '_ed',\n  },\n  burst: {\n    prt: '_',\n  },\n  buy: {\n    prt: 'bought',\n    pst: 'bought',\n  },\n  can: {\n    a: '',\n    fut: '_',\n    g: '',\n    pst: 'could',\n    perf: 'could',\n    pluperf: 'could',\n    pres: '_',\n  },\n  catch: {\n    pst: 'caught',\n  },\n  choose: {\n    g: 'choosing',\n    prt: 'chosen',\n    pst: 'chose',\n  },\n  cling: {\n    prt: 'clung',\n  },\n  come: {\n    prt: '_',\n    pst: 'came',\n    g: 'coming',\n  },\n  compete: {\n    a: 'competitor',\n    g: 'competing',\n    pst: '_d',\n  },\n  cost: {\n    pst: '_',\n  },\n  creep: {\n    prt: 'crept',\n  },\n  cut: {\n    prt: '_',\n  },\n  deal: {\n    prt: '_t',\n    pst: '_t',\n  },\n  develop: {\n    a: '_er',\n    g: '_ing',\n    pst: '_ed',\n  },\n  die: {\n    g: 'dying',\n    pst: '_d',\n  },\n  dig: {\n    g: '_ging',\n    prt: 'dug',\n    pst: 'dug',\n  },\n  dive: {\n    prt: '_d',\n  },\n  do: {\n    pst: 'did',\n    pres: '_es',\n  },\n  draw: {\n    prt: '_n',\n    pst: 'drew',\n  },\n  dream: {\n    prt: '_t',\n  },\n  drink: {\n    prt: 'drunk',\n    pst: 'drank',\n  },\n  drive: {\n    g: 'driving',\n    prt: '_n',\n    pst: 'drove',\n  },\n  drop: {\n    g: '_ping',\n    pst: '_ped',\n  },\n  eat: {\n    a: '_er',\n    g: '_ing',\n    prt: '_en',\n    pst: 'ate',\n  },\n  edit: {\n    g: '_ing',\n  },\n  egg: {\n    pst: '_ed',\n  },\n  fall: {\n    prt: '_en',\n    pst: 'fell',\n  },\n  feed: {\n    prt: 'fed',\n    pst: 'fed',\n  },\n  feel: {\n    a: '_er',\n    pst: 'felt',\n  },\n  fight: {\n    prt: 'fought',\n    pst: 'fought',\n  },\n  find: {\n    pst: 'found',\n  },\n  flee: {\n    g: '_ing',\n    prt: 'fled',\n  },\n  fling: {\n    prt: 'flung',\n  },\n  fly: {\n    prt: 'flown',\n    pst: 'flew',\n  },\n  forbid: {\n    pst: 'forbade',\n  },\n  forget: {\n    g: '_ing',\n    prt: 'forgotten',\n    pst: 'forgot',\n  },\n  forgive: {\n    g: 'forgiving',\n    prt: '_n',\n    pst: 'forgave',\n  },\n  free: {\n    a: '',\n    g: '_ing',\n  },\n  freeze: {\n    g: 'freezing',\n    prt: 'frozen',\n    pst: 'froze',\n  },\n  get: {\n    pst: 'got',\n    prt: 'gotten',\n  },\n  give: {\n    g: 'giving',\n    prt: '_n',\n    pst: 'gave',\n  },\n  go: {\n    prt: '_ne',\n    pst: 'went',\n    pres: 'goes',\n  },\n  grow: {\n    prt: '_n',\n  },\n  hang: {\n    prt: 'hung',\n    pst: 'hung',\n  },\n  have: {\n    g: 'having',\n    prt: 'had',\n    pst: 'had',\n    pres: 'has',\n  },\n  hear: {\n    prt: '_d',\n    pst: '_d',\n  },\n  hide: {\n    prt: 'hidden',\n    pst: 'hid',\n  },\n  hit: {\n    prt: '_',\n  },\n  hold: {\n    prt: 'held',\n    pst: 'held',\n  },\n  hurt: {\n    prt: '_',\n    pst: '_',\n  },\n  ice: {\n    g: 'icing',\n    pst: '_d',\n  },\n  imply: {\n    pst: 'implied',\n    pres: 'implies',\n  },\n  is: {\n    a: '',\n    g: 'being',\n    pst: 'was',\n    pres: '_',\n  },\n  keep: {\n    prt: 'kept',\n  },\n  kneel: {\n    prt: 'knelt',\n  },\n  know: {\n    prt: '_n',\n  },\n  lay: {\n    prt: 'laid',\n    pst: 'laid',\n  },\n  lead: {\n    prt: 'led',\n    pst: 'led',\n  },\n  leap: {\n    prt: '_t',\n  },\n  leave: {\n    prt: 'left',\n    pst: 'left',\n  },\n  lend: {\n    prt: 'lent',\n  },\n  lie: {\n    g: 'lying',\n    pst: 'lay',\n  },\n  light: {\n    prt: 'lit',\n    pst: 'lit',\n  },\n  log: {\n    g: '_ging',\n    pst: '_ged',\n  },\n  loose: {\n    prt: 'lost',\n  },\n  lose: {\n    g: 'losing',\n    pst: 'lost',\n  },\n  make: {\n    prt: 'made',\n    pst: 'made',\n  },\n  mean: {\n    prt: '_t',\n    pst: '_t',\n  },\n  meet: {\n    a: '_er',\n    g: '_ing',\n    prt: 'met',\n    pst: 'met',\n  },\n  miss: {\n    pres: '_',\n  },\n  name: {\n    g: 'naming',\n  },\n  pay: {\n    prt: 'paid',\n    pst: 'paid',\n  },\n  prove: {\n    prt: '_n',\n  },\n  puke: {\n    g: 'puking',\n  },\n  put: {\n    prt: '_',\n  },\n  quit: {\n    prt: '_',\n  },\n  read: {\n    prt: '_',\n    pst: '_',\n  },\n  ride: {\n    prt: 'ridden',\n  },\n  ring: {\n    prt: 'rung',\n    pst: 'rang',\n  },\n  rise: {\n    fut: 'will have _n',\n    g: 'rising',\n    prt: '_n',\n    pst: 'rose',\n    pluperf: 'had _n',\n  },\n  rub: {\n    g: '_bing',\n    pst: '_bed',\n  },\n  run: {\n    g: '_ning',\n    prt: '_',\n    pst: 'ran',\n  },\n  say: {\n    prt: 'said',\n    pst: 'said',\n    pres: '_s',\n  },\n  seat: {\n    prt: 'sat',\n  },\n  see: {\n    g: '_ing',\n    prt: '_n',\n    pst: 'saw',\n  },\n  seek: {\n    prt: 'sought',\n  },\n  sell: {\n    prt: 'sold',\n    pst: 'sold',\n  },\n  send: {\n    prt: 'sent',\n  },\n  set: {\n    prt: '_',\n  },\n  sew: {\n    prt: '_n',\n  },\n  shake: {\n    prt: '_n',\n  },\n  shave: {\n    prt: '_d',\n  },\n  shed: {\n    g: '_ding',\n    pst: '_',\n    pres: '_s',\n  },\n  shine: {\n    prt: 'shone',\n    pst: 'shone',\n  },\n  shoot: {\n    prt: 'shot',\n    pst: 'shot',\n  },\n  show: {\n    pst: '_ed',\n  },\n  shut: {\n    prt: '_',\n  },\n  sing: {\n    prt: 'sung',\n    pst: 'sang',\n  },\n  sink: {\n    pst: 'sank',\n    pluperf: 'had sunk',\n  },\n  sit: {\n    pst: 'sat',\n  },\n  ski: {\n    pst: '_ied',\n  },\n  slay: {\n    prt: 'slain',\n  },\n  sleep: {\n    prt: 'slept',\n  },\n  slide: {\n    prt: 'slid',\n    pst: 'slid',\n  },\n  smash: {\n    pres: '_es',\n  },\n  sneak: {\n    prt: 'snuck',\n  },\n  speak: {\n    fut: 'will have spoken',\n    prt: 'spoken',\n    pst: 'spoke',\n    perf: 'have spoken',\n    pluperf: 'had spoken',\n  },\n  speed: {\n    prt: 'sped',\n  },\n  spend: {\n    prt: 'spent',\n  },\n  spill: {\n    prt: '_ed',\n    pst: 'spilt',\n  },\n  spin: {\n    g: '_ning',\n    prt: 'spun',\n    pst: 'spun',\n  },\n  spit: {\n    prt: 'spat',\n  },\n  split: {\n    prt: '_',\n  },\n  spread: {\n    pst: '_',\n  },\n  spring: {\n    prt: 'sprung',\n  },\n  stand: {\n    pst: 'stood',\n  },\n  steal: {\n    a: '_er',\n    pst: 'stole',\n  },\n  stick: {\n    pst: 'stuck',\n  },\n  sting: {\n    pst: 'stung',\n  },\n  stink: {\n    prt: 'stunk',\n    pst: 'stunk',\n  },\n  stream: {\n    a: '_er',\n  },\n  strew: {\n    prt: '_n',\n  },\n  strike: {\n    g: 'striking',\n    pst: 'struck',\n  },\n  suit: {\n    a: '_er',\n    g: '_ing',\n    pst: '_ed',\n  },\n  sware: {\n    prt: 'sworn',\n  },\n  swear: {\n    pst: 'swore',\n  },\n  sweep: {\n    prt: 'swept',\n  },\n  swim: {\n    g: '_ming',\n    pst: 'swam',\n  },\n  swing: {\n    pst: 'swung',\n  },\n  take: {\n    fut: 'will have _n',\n    pst: 'took',\n    perf: 'have _n',\n    pluperf: 'had _n',\n  },\n  teach: {\n    pst: 'taught',\n    pres: '_es',\n  },\n  tear: {\n    pst: 'tore',\n  },\n  tell: {\n    pst: 'told',\n  },\n  think: {\n    pst: 'thought',\n  },\n  thrive: {\n    prt: '_d',\n  },\n  tie: {\n    g: 'tying',\n    pst: '_d',\n  },\n  undergo: {\n    prt: '_ne',\n  },\n  understand: {\n    pst: 'understood',\n  },\n  upset: {\n    prt: '_',\n  },\n  wait: {\n    a: '_er',\n    g: '_ing',\n    pst: '_ed',\n  },\n  wake: {\n    pst: 'woke',\n  },\n  wear: {\n    pst: 'wore',\n  },\n  weave: {\n    prt: 'woven',\n  },\n  wed: {\n    pst: 'wed',\n  },\n  weep: {\n    prt: 'wept',\n  },\n  win: {\n    g: '_ning',\n    pst: 'won',\n  },\n  wind: {\n    prt: 'wound',\n  },\n  withdraw: {\n    pst: 'withdrew',\n  },\n  wring: {\n    prt: 'wrung',\n  },\n  write: {\n    g: 'writing',\n    prt: 'written',\n    pst: 'wrote',\n  },\n}\n\n//uncompress our ad-hoc compression scheme\nlet keys = Object.keys(conjugations)\nfor (let i = 0; i < keys.length; i++) {\n  const inf = keys[i]\n  let final = {}\n  Object.keys(conjugations[inf]).forEach(key => {\n    let str = conjugations[inf][key]\n    //swap-in infinitives for '_'\n    str = str.replace('_', inf)\n\n    let full = mapping[key]\n    final[full] = str\n  })\n  //over-write original\n  conjugations[inf] = final\n}\n\nmodule.exports = conjugations\n","//add forward/backward 'linked-list' prev/next ids\nconst linkTerms = terms => {\n  terms.forEach((term, i) => {\n    if (i > 0) {\n      term.prev = terms[i - 1].id\n    }\n    if (terms[i + 1]) {\n      term.next = terms[i + 1].id\n    }\n  })\n}\nmodule.exports = linkTerms\n","//(Rule-based sentence boundary segmentation) - chop given text into its proper sentences.\n// Ignore periods/questions/exclamations used in acronyms/abbreviations/numbers, etc.\n// @spencermountain 2017 MIT\n\n//proper nouns with exclamation marks\n// const blacklist = {\n//   yahoo: true,\n//   joomla: true,\n//   jeopardy: true,\n// }\n\n//regs-\nconst initSplit = /(\\S.+?[.!?\\u203D\\u2E18\\u203C\\u2047-\\u2049])(?=\\s+|$)/g\nconst hasSomething = /\\S/\n\nconst isAcronym = /[ .][A-Z]\\.? *$/i\nconst hasEllipse = /(?:\\u2026|\\.{2,}) *$/\nconst newLine = /((?:\\r?\\n|\\r)+)/ // Match different new-line formats\nconst hasLetter = /[a-z0-9\\u00C0-\\u00FF\\u00a9|\\u00ae|[\\u2000-\\u3300]|\\ud83c[\\ud000-\\udfff]|\\ud83d[\\ud000-\\udfff]|\\ud83e[\\ud000-\\udfff]/i\n\nconst startWhitespace = /^\\s+/\n\n// Start with a regex:\nconst naiive_split = function(text) {\n  let all = []\n  //first, split by newline\n  let lines = text.split(newLine)\n  for (let i = 0; i < lines.length; i++) {\n    //split by period, question-mark, and exclamation-mark\n    let arr = lines[i].split(initSplit)\n    for (let o = 0; o < arr.length; o++) {\n      all.push(arr[o])\n    }\n  }\n  return all\n}\n\n/** does this look like a sentence? */\nconst isSentence = function(str, abbrevs) {\n  // check for 'F.B.I.'\n  if (isAcronym.test(str) === true) {\n    return false\n  }\n  //check for '...'\n  if (hasEllipse.test(str) === true) {\n    return false\n  }\n  // must have a letter\n  if (hasLetter.test(str) === false) {\n    return false\n  }\n\n  let txt = str.replace(/[.!?\\u203D\\u2E18\\u203C\\u2047-\\u2049] *$/, '')\n  let words = txt.split(' ')\n  let lastWord = words[words.length - 1].toLowerCase()\n  // check for 'Mr.'\n  if (abbrevs.hasOwnProperty(lastWord)) {\n    return false\n  }\n  // //check for jeopardy!\n  // if (blacklist.hasOwnProperty(lastWord)) {\n  //   return false\n  // }\n  return true\n}\n\nconst splitSentences = function(text, world) {\n  let abbrevs = world.cache.abbreviations\n\n  text = text || ''\n  text = String(text)\n  let sentences = []\n  // First do a greedy-split..\n  let chunks = []\n  // Ensure it 'smells like' a sentence\n  if (!text || typeof text !== 'string' || hasSomething.test(text) === false) {\n    return sentences\n  }\n  // Start somewhere:\n  let splits = naiive_split(text)\n  // Filter-out the crap ones\n  for (let i = 0; i < splits.length; i++) {\n    let s = splits[i]\n    if (s === undefined || s === '') {\n      continue\n    }\n    //this is meaningful whitespace\n    if (hasSomething.test(s) === false) {\n      //add it to the last one\n      if (chunks[chunks.length - 1]) {\n        chunks[chunks.length - 1] += s\n        continue\n      } else if (splits[i + 1]) {\n        //add it to the next one\n        splits[i + 1] = s + splits[i + 1]\n        continue\n      }\n    }\n    //else, only whitespace, no terms, no sentence\n    chunks.push(s)\n  }\n\n  //detection of non-sentence chunks:\n  //loop through these chunks, and join the non-sentence chunks back together..\n  for (let i = 0; i < chunks.length; i++) {\n    let c = chunks[i]\n    //should this chunk be combined with the next one?\n    if (chunks[i + 1] && isSentence(c, abbrevs) === false) {\n      chunks[i + 1] = c + (chunks[i + 1] || '')\n    } else if (c && c.length > 0) {\n      //&& hasLetter.test(c)\n      //this chunk is a proper sentence..\n      sentences.push(c)\n      chunks[i] = ''\n    }\n  }\n  //if we never got a sentence, return the given text\n  if (sentences.length === 0) {\n    return [text]\n  }\n\n  //move whitespace to the ends of sentences, when possible\n  //['hello',' world'] -> ['hello ','world']\n  for (let i = 1; i < sentences.length; i += 1) {\n    let ws = sentences[i].match(startWhitespace)\n    if (ws !== null) {\n      sentences[i - 1] += ws[0]\n      sentences[i] = sentences[i].replace(startWhitespace, '')\n    }\n  }\n  return sentences\n}\n\nmodule.exports = splitSentences\n// console.log(sentence_parser('john f. kennedy'));\n","const wordlike = /\\S/\nconst isBoundary = /^[!?.]+$/\nconst naiiveSplit = /(\\S+)/\nconst isSlash = /\\/\\W*$/\n\nconst notWord = {\n  '.': true,\n  '-': true, //dash\n  '–': true, //en-dash\n  '—': true, //em-dash\n  '--': true,\n  '...': true,\n  // '/': true, // 'one / two'\n}\n\nconst hasHyphen = function(str) {\n  //dont split 're-do'\n  if (/^(re|un)-?[^aeiou]./.test(str) === true) {\n    return false\n  }\n  //letter-number\n  let reg = /^([a-z\\u00C0-\\u00FF`\"'/]+)(-|–|—)([a-z0-9\\u00C0-\\u00FF].*)/i\n  if (reg.test(str) === true) {\n    return true\n  }\n  //support weird number-emdash combo '2010–2011'\n  // let reg2 = /^([0-9]+)(–|—)([0-9].*)/i\n  // if (reg2.test(str)) {\n  //   return true\n  // }\n  return false\n}\n\n// 'he / she' should be one word\nconst combineSlashes = function(arr) {\n  for (let i = 1; i < arr.length - 1; i++) {\n    if (isSlash.test(arr[i])) {\n      arr[i - 1] += arr[i] + arr[i + 1]\n      arr[i] = null\n      arr[i + 1] = null\n    }\n  }\n  return arr\n}\n\nconst splitHyphens = function(word) {\n  let arr = []\n  //support multiple-hyphenated-terms\n  const hyphens = word.split(/[-–—]/)\n  let whichDash = '-'\n  let found = word.match(/[-–—]/)\n  if (found && found[0]) {\n    whichDash = found\n  }\n  for (let o = 0; o < hyphens.length; o++) {\n    if (o === hyphens.length - 1) {\n      arr.push(hyphens[o])\n    } else {\n      arr.push(hyphens[o] + whichDash)\n    }\n  }\n  return arr\n}\n\n//turn a string into an array of terms (naiive for now, lumped later)\nconst splitWords = function(str) {\n  let result = []\n  let arr = []\n  //start with a naiive split\n  str = str || ''\n  if (typeof str === 'number') {\n    str = String(str)\n  }\n\n  const words = str.split(naiiveSplit)\n  for (let i = 0; i < words.length; i++) {\n    //split 'one-two'\n    if (hasHyphen(words[i]) === true) {\n      arr = arr.concat(splitHyphens(words[i]))\n      continue\n    }\n    arr.push(words[i])\n  }\n  //greedy merge whitespace+arr to the right\n  let carry = ''\n  for (let i = 0; i < arr.length; i++) {\n    let word = arr[i]\n    //if it's more than a whitespace\n    if (wordlike.test(word) === true && notWord.hasOwnProperty(word) === false && isBoundary.test(word) === false) {\n      //put whitespace on end of previous term, if possible\n      if (result.length > 0) {\n        result[result.length - 1] += carry\n        result.push(word)\n      } else {\n        //otherwise, but whitespace before\n        result.push(carry + word)\n      }\n      carry = ''\n    } else {\n      carry += word\n    }\n  }\n  //handle last one\n  if (carry) {\n    if (result.length === 0) {\n      result[0] = ''\n    }\n    result[result.length - 1] += carry //put it on the end\n  }\n  // combine 'one / two'\n  result = combineSlashes(result)\n  // remove empty results\n  result = result.filter(s => s)\n  return result\n}\nmodule.exports = splitWords\n","const Term = require('../Term/Term')\nconst Phrase = require('../Phrase/Phrase')\nconst Pool = require('./Pool')\nconst linkTerms = require('./_linkTerms')\nconst splitSentences = require('./01-sentences')\nconst splitTerms = require('./02-words')\n\n/** turn a string into an array of Phrase objects */\nconst fromText = function(text = '', world, pool) {\n  //a bit of validation, first\n  if (typeof text !== 'string') {\n    if (typeof text === 'number') {\n      text = String(text)\n    }\n  }\n  //tokenize into words\n  let sentences = splitSentences(text, world)\n  sentences = sentences.map(str => splitTerms(str))\n\n  //turn them into proper objects\n  pool = pool || new Pool()\n\n  let phrases = sentences.map(terms => {\n    terms = terms.map(str => {\n      let term = new Term(str)\n      pool.add(term)\n      return term\n    })\n    //add next/previous ids\n    linkTerms(terms)\n\n    //return phrase objects\n    return new Phrase(terms[0].id, terms.length, pool)\n  })\n  //return them ready for a Document object\n  return phrases\n}\n\nmodule.exports = fromText\n","const Term = require('../Term/Term')\nconst Phrase = require('../Phrase/Phrase')\nconst Pool = require('./Pool')\nconst linkTerms = require('./_linkTerms')\n\nconst fromJSON = function(json, world) {\n  let pool = new Pool()\n  let phrases = json.map((p, k) => {\n    let terms = p.terms.map((o, i) => {\n      let term = new Term(o.text)\n      term.pre = o.pre !== undefined ? o.pre : ''\n      if (o.post === undefined) {\n        o.post = ' '\n        //no given space for very last term\n        if (i >= p.terms.length - 1) {\n          o.post = '. '\n          if (k >= p.terms.length - 1) {\n            o.post = '.'\n          }\n        }\n      }\n      term.post = o.post !== undefined ? o.post : ' '\n\n      if (o.tags) {\n        o.tags.forEach(tag => term.tag(tag, '', world))\n      }\n      pool.add(term)\n      return term\n    })\n    //add prev/next links\n    linkTerms(terms)\n    // return a proper Phrase object\n    return new Phrase(terms[0].id, terms.length, pool)\n  })\n  return phrases\n}\nmodule.exports = fromJSON\n","//ths is used by compromise-tokenize, to avoid loading ./_data\nmodule.exports = {\n  Cool: 'true¦ya',\n}\n","const entity = ['Person', 'Place', 'Organization']\n\nmodule.exports = {\n  Noun: {\n    notA: ['Verb', 'Adjective', 'Adverb'],\n  },\n  // - singular\n  Singular: {\n    isA: 'Noun',\n    notA: 'Plural',\n  },\n  //a specific thing that's capitalized\n  ProperNoun: {\n    isA: 'Noun',\n  },\n\n  // -- people\n  Person: {\n    isA: ['ProperNoun', 'Singular'],\n    notA: ['Place', 'Organization', 'Date'],\n  },\n  FirstName: {\n    isA: 'Person',\n  },\n  MaleName: {\n    isA: 'FirstName',\n    notA: ['FemaleName', 'LastName'],\n  },\n  FemaleName: {\n    isA: 'FirstName',\n    notA: ['MaleName', 'LastName'],\n  },\n  LastName: {\n    isA: 'Person',\n    notA: ['FirstName'],\n  },\n  Honorific: {\n    isA: 'Noun',\n    notA: ['FirstName', 'LastName'],\n  },\n\n  // -- places\n  Place: {\n    isA: 'Singular',\n    notA: ['Person', 'Organization'],\n  },\n  Country: {\n    isA: ['Place', 'ProperNoun'],\n    notA: ['City'],\n  },\n  City: {\n    isA: ['Place', 'ProperNoun'],\n    notA: ['Country'],\n  },\n  Region: {\n    isA: ['Place', 'ProperNoun'],\n  },\n  Address: {\n    isA: 'Place',\n  },\n\n  //---Orgs---\n  Organization: {\n    isA: ['Singular', 'ProperNoun'],\n    notA: ['Person', 'Place'],\n  },\n  SportsTeam: {\n    isA: 'Organization',\n  },\n  School: {\n    isA: 'Organization',\n  },\n  Company: {\n    isA: 'Organization',\n  },\n\n  // - plural\n  Plural: {\n    isA: 'Noun',\n    notA: ['Singular'],\n  },\n  //(not plural or singular)\n  Uncountable: {\n    isA: 'Noun',\n  },\n  Pronoun: {\n    isA: 'Noun',\n    notA: entity,\n  },\n  //a word for someone doing something -'plumber'\n  Actor: {\n    isA: 'Noun',\n    notA: entity,\n  },\n  //a gerund-as-noun - 'swimming'\n  Activity: {\n    isA: 'Noun',\n    notA: ['Person', 'Place'],\n  },\n  //'kilograms'\n  Unit: {\n    isA: 'Noun',\n    notA: entity,\n  },\n  //'Canadians'\n  Demonym: {\n    isA: ['Noun', 'ProperNoun'],\n    notA: entity,\n  },\n  //`john's`\n  Possessive: {\n    isA: 'Noun',\n    // notA: 'Pronoun',\n  },\n}\n","module.exports = {\n  Verb: {\n    notA: ['Noun', 'Adjective', 'Adverb', 'Value'],\n  },\n  // walks\n  PresentTense: {\n    isA: 'Verb',\n    notA: ['PastTense', 'Copula', 'FutureTense'],\n  },\n  // neutral form - 'walk'\n  Infinitive: {\n    isA: 'PresentTense',\n    notA: ['PastTense', 'Gerund'],\n  },\n  // walking\n  Gerund: {\n    isA: 'PresentTense',\n    notA: ['PastTense', 'Copula', 'FutureTense'],\n  },\n  // walked\n  PastTense: {\n    isA: 'Verb',\n    notA: ['FutureTense'],\n  },\n  // will walk\n  FutureTense: {\n    isA: 'Verb',\n  },\n\n  // is\n  Copula: {\n    isA: 'Verb',\n  },\n  // would have\n  Modal: {\n    isA: 'Verb',\n    notA: ['Infinitive'],\n  },\n  // had walked\n  PerfectTense: {\n    isA: 'Verb',\n    notA: 'Gerund',\n  },\n  Pluperfect: {\n    isA: 'Verb',\n  },\n  // shown\n  Participle: {\n    isA: 'Verb',\n  },\n  // show up\n  PhrasalVerb: {\n    isA: 'Verb',\n  },\n  //'up' part\n  Particle: {\n    isA: 'PhrasalVerb',\n  },\n}\n","module.exports = {\n  Value: {\n    notA: ['Verb', 'Adjective', 'Adverb'],\n  },\n  Ordinal: {\n    isA: 'Value',\n    notA: ['Cardinal'],\n  },\n  Cardinal: {\n    isA: 'Value',\n    notA: ['Ordinal'],\n  },\n  RomanNumeral: {\n    isA: 'Cardinal', //can be a person, too\n    notA: ['Ordinal', 'TextValue'],\n  },\n  TextValue: {\n    isA: 'Value',\n    notA: ['NumericValue'],\n  },\n  NumericValue: {\n    isA: 'Value',\n    notA: ['TextValue'],\n  },\n  Money: {\n    isA: 'Cardinal',\n  },\n  Percent: {\n    isA: 'Value',\n  },\n}\n","const anything = ['Noun', 'Verb', 'Adjective', 'Adverb', 'Value']\n\nmodule.exports = {\n  //--Adjectives--\n  Adjective: {\n    notA: ['Noun', 'Verb', 'Adverb', 'Value'],\n  },\n  // adjectives that can conjugate\n  Comparable: {\n    isA: ['Adjective'],\n  },\n  // better\n  Comparative: {\n    isA: ['Adjective'],\n  },\n  // best\n  Superlative: {\n    isA: ['Adjective'],\n    notA: ['Comparative'],\n  },\n\n  NumberRange: {\n    isA: ['Contraction'],\n  },\n  Adverb: {\n    notA: ['Noun', 'Verb', 'Adjective', 'Value'],\n  },\n\n  // Dates:\n  //not a noun, but usually is\n  Date: {\n    notA: ['Verb', 'Conjunction', 'Adverb', 'Preposition', 'Adjective'],\n  },\n  Month: {\n    isA: ['Date', 'Singular'],\n    notA: ['Year', 'WeekDay', 'Time'],\n  },\n  WeekDay: {\n    isA: ['Date', 'Noun'],\n  },\n  // '9:20pm'\n  Time: {\n    isA: ['Date'],\n    notA: ['Value'],\n  },\n\n  //glue\n  Determiner: {\n    notA: anything,\n  },\n  Conjunction: {\n    notA: anything,\n  },\n  Preposition: {\n    notA: anything,\n  },\n\n  // what, who, why\n  QuestionWord: {\n    notA: ['Determiner'],\n  },\n\n  // peso, euro\n  Currency: {},\n  // ughh\n  Expression: {\n    notA: ['Noun', 'Adjective', 'Verb', 'Adverb'],\n  },\n  // dr.\n  Abbreviation: {},\n\n  // internet tags\n  Url: {\n    notA: ['HashTag', 'PhoneNumber', 'Verb', 'Adjective', 'Value', 'AtMention', 'Email'],\n  },\n  PhoneNumber: {\n    notA: ['HashTag', 'Verb', 'Adjective', 'Value', 'AtMention', 'Email'],\n  },\n  HashTag: {},\n  AtMention: {\n    isA: ['Noun'],\n    notA: ['HashTag', 'Verb', 'Adjective', 'Value', 'Email'],\n  },\n  Emoji: {\n    notA: ['HashTag', 'Verb', 'Adjective', 'Value', 'AtMention'],\n  },\n  Emoticon: {\n    notA: ['HashTag', 'Verb', 'Adjective', 'Value', 'AtMention'],\n  },\n  Email: {\n    notA: ['HashTag', 'Verb', 'Adjective', 'Value', 'AtMention'],\n  },\n\n  //non-exclusive\n  Auxiliary: {\n    notA: ['Noun', 'Adjective', 'Value'],\n  },\n  Acronym: {\n    notA: ['Plural', 'RomanNumeral'],\n  },\n  Negative: {\n    notA: ['Noun', 'Adjective', 'Value'],\n  },\n  // if, unless, were\n  Condition: {\n    notA: ['Verb', 'Adjective', 'Noun', 'Value'],\n  },\n}\n","// i just made these up\nconst colorMap = {\n  Noun: 'blue',\n\n  Verb: 'green',\n  Negative: 'green',\n\n  Date: 'red',\n  Value: 'red',\n\n  Adjective: 'magenta',\n\n  Preposition: 'cyan',\n  Conjunction: 'cyan',\n  Determiner: 'cyan',\n  Adverb: 'cyan',\n}\n\n/** add a debug color to some tags */\nconst addColors = function(tags) {\n  Object.keys(tags).forEach(k => {\n    if (colorMap[k]) {\n      tags[k].color = colorMap[k]\n      return\n    }\n    tags[k].isA.some(t => {\n      if (colorMap[t]) {\n        tags[k].color = colorMap[t]\n        return true\n      }\n      return false\n    })\n  })\n  return tags\n}\n\nmodule.exports = addColors\n","const unique = function(arr) {\n  return arr.filter((v, i, a) => a.indexOf(v) === i)\n}\n\n//add 'downward' tags (that immediately depend on this one)\nconst inferIsA = function(tags) {\n  Object.keys(tags).forEach(k => {\n    let tag = tags[k]\n    let len = tag.isA.length\n    for (let i = 0; i < len; i++) {\n      let down = tag.isA[i]\n      if (tags[down]) {\n        tag.isA = tag.isA.concat(tags[down].isA)\n      }\n    }\n    // clean it up\n    tag.isA = unique(tag.isA)\n  })\n  return tags\n}\nmodule.exports = inferIsA\n","const unique = function(arr) {\n  return arr.filter((v, i, a) => a.indexOf(v) === i)\n}\n\n// crawl the tag-graph and infer any conflicts\n// faster than doing this at tag-time\nconst inferNotA = function(tags) {\n  let keys = Object.keys(tags)\n  keys.forEach(k => {\n    let tag = tags[k]\n    tag.notA = tag.notA || []\n    tag.isA.forEach(down => {\n      if (tags[down] && tags[down].notA) {\n        // borrow its conflicts\n        let notA = typeof tags[down].notA === 'string' ? [tags[down].isA] : tags[down].notA || []\n        tag.notA = tag.notA.concat(notA)\n      }\n    })\n    // any tag that lists us as a conflict, we conflict it back.\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]\n      if (tags[key].notA.indexOf(k) !== -1) {\n        tag.notA.push(key)\n      }\n    }\n    // clean it up\n    tag.notA = unique(tag.notA)\n  })\n  return tags\n}\nmodule.exports = inferNotA\n","// a lineage is all 'incoming' tags that have this as 'isA'\nconst inferLineage = function(tags) {\n  let keys = Object.keys(tags)\n  keys.forEach(k => {\n    let tag = tags[k]\n    tag.lineage = []\n    // find all tags with it in their 'isA' set\n    for (let i = 0; i < keys.length; i++) {\n      if (tags[keys[i]].isA.indexOf(k) !== -1) {\n        tag.lineage.push(keys[i])\n      }\n    }\n  })\n  return tags\n}\nmodule.exports = inferLineage\n","const inferColor = require('./_color')\nconst inferIsA = require('./_isA')\nconst inferNotA = require('./_notA')\nconst lineage = require('./_lineage')\n\nconst validate = function(tags) {\n  // cleanup format\n  Object.keys(tags).forEach(k => {\n    let tag = tags[k]\n    // ensure isA is an array\n    tag.isA = tag.isA || []\n    if (typeof tag.isA === 'string') {\n      tag.isA = [tag.isA]\n    }\n    // ensure notA is an array\n    tag.notA = tag.notA || []\n    if (typeof tag.notA === 'string') {\n      tag.notA = [tag.notA]\n    }\n  })\n  return tags\n}\n\n// build-out the tag-graph structure\nconst inferTags = function(tags) {\n  // validate data\n  tags = validate(tags)\n  // build its 'down tags'\n  tags = inferIsA(tags)\n  // infer the conflicts\n  tags = inferNotA(tags)\n  // debug tag color\n  tags = inferColor(tags)\n  // find incoming links\n  tags = lineage(tags)\n  return tags\n}\nmodule.exports = inferTags\n","const nouns = require('./tags/nouns')\nconst verbs = require('./tags/verbs')\nconst values = require('./tags/values')\nconst misc = require('./tags/misc')\nconst inferTags = require('./inference/index')\n\n//extend tagset with new tags\nconst addIn = function(obj, tags) {\n  Object.keys(obj).forEach(k => {\n    tags[k] = obj[k]\n  })\n}\n\nconst build = () => {\n  let tags = {}\n  addIn(nouns, tags)\n  addIn(verbs, tags)\n  addIn(values, tags)\n  addIn(misc, tags)\n  // do the graph-stuff\n  tags = inferTags(tags)\n  return tags\n}\nmodule.exports = build()\n","const noTagger = function(doc) {\n  console.log('not tagging')\n  return doc\n}\nmodule.exports = noTagger\n","//safely add it to the lexicon\nconst addWord = function(word, tag, lex) {\n  if (lex[word] !== undefined) {\n    if (typeof lex[word] === 'string') {\n      lex[word] = [lex[word]]\n    }\n    lex[word].push(tag)\n  } else {\n    lex[word] = tag\n  }\n}\n\n// blast-out more forms for some given words\nconst addMore = function(word, tag, world) {\n  let lexicon = world.words\n  let transform = world.transforms\n\n  // cache multi-words\n  let words = word.split(' ')\n  if (words.length > 1) {\n    //cache the beginning word\n    world.hasCompound[words[0]] = true\n  }\n  // inflect our nouns\n  if (tag === 'Singular') {\n    let plural = transform.toPlural(word, world)\n    lexicon[plural] = lexicon[plural] || 'Plural' // only if it's safe\n  }\n  //conjugate our verbs\n  if (tag === 'Infinitive') {\n    let conj = transform.conjugate(word, world)\n    let tags = Object.keys(conj)\n    for (let i = 0; i < tags.length; i++) {\n      let w = conj[tags[i]]\n      lexicon[w] = lexicon[w] || tags[i] // only if it's safe\n    }\n  }\n  //derive more adjective forms\n  if (tag === 'Comparable') {\n    let conj = transform.adjectives(word)\n    let tags = Object.keys(conj)\n    for (let i = 0; i < tags.length; i++) {\n      let w = conj[tags[i]]\n      lexicon[w] = lexicon[w] || tags[i] // only if it's safe\n    }\n  }\n  //conjugate phrasal-verbs\n  if (tag === 'PhrasalVerb') {\n    //add original form\n    addWord(word, 'Infinitive', lexicon)\n    //conjugate first word\n    let conj = transform.conjugate(words[0], world)\n    let tags = Object.keys(conj)\n    for (let i = 0; i < tags.length; i++) {\n      //add it to our cache\n      world.hasCompound[conj[tags[i]]] = true\n      //first + last words\n      let w = conj[tags[i]] + ' ' + words[1]\n\n      addWord(w, tags[i], lexicon)\n      addWord(w, 'PhrasalVerb', lexicon)\n    }\n  }\n  // inflect our demonyms - 'germans'\n  if (tag === 'Demonym') {\n    let plural = transform.toPlural(word, world)\n    lexicon[plural] = lexicon[plural] || ['Demonym', 'Plural'] // only if it's safe\n  }\n}\n\n// throw a bunch of words in our lexicon\n// const doWord = function(words, tag, world) {\n//   let lexicon = world.words\n//   for (let i = 0; i < words.length; i++) {\n//     addWord(words[i], tag, lexicon)\n//     // do some fancier stuff\n//     addMore(words[i], tag, world)\n//   }\n// }\nmodule.exports = {\n  addWord: addWord,\n  addMore: addMore,\n}\n","// add words from plurals and conjugations data\nconst addIrregulars = function(world) {\n  //add irregular plural nouns\n  let nouns = world.irregulars.nouns\n  let words = Object.keys(nouns)\n  for (let i = 0; i < words.length; i++) {\n    const w = words[i]\n    world.words[w] = 'Singular'\n    world.words[nouns[w]] = 'Plural'\n  }\n\n  // add irregular verb conjugations\n  let verbs = world.irregulars.verbs\n  let keys = Object.keys(verbs)\n  for (let i = 0; i < keys.length; i++) {\n    const inf = keys[i]\n    //add only if it it's safe...\n    world.words[inf] = world.words[inf] || 'Infinitive'\n    let forms = world.transforms.conjugate(inf, world)\n    forms = Object.assign(forms, verbs[inf])\n    //add the others\n    Object.keys(forms).forEach(tag => {\n      world.words[forms[tag]] = world.words[forms[tag]] || tag\n    })\n  }\n}\nmodule.exports = addIrregulars\n","//words that can't be compressed, for whatever reason\nmodule.exports = {\n  // numbers\n  '20th century fox': 'Organization',\n  // '3m': 'Organization',\n  '7 eleven': 'Organization',\n  '7-eleven': 'Organization',\n  g8: 'Organization',\n  'motel 6': 'Organization',\n  vh1: 'Organization',\n  q1: 'Date',\n  q2: 'Date',\n  q3: 'Date',\n  q4: 'Date',\n}\n","const endsWith = {\n  b: [\n    {\n      reg: /([^aeiou][aeiou])b$/i,\n      repl: {\n        pr: '$1bs',\n        pa: '$1bbed',\n        gr: '$1bbing',\n      },\n    },\n  ],\n  d: [\n    {\n      reg: /(end)$/i,\n      repl: {\n        pr: '$1s',\n        pa: 'ent',\n        gr: '$1ing',\n        ar: '$1er',\n      },\n    },\n    {\n      reg: /(eed)$/i,\n      repl: {\n        pr: '$1s',\n        pa: '$1ed',\n        gr: '$1ing',\n        ar: '$1er',\n      },\n    },\n    {\n      reg: /(ed)$/i,\n      repl: {\n        pr: '$1s',\n        pa: '$1ded',\n        ar: '$1der',\n        gr: '$1ding',\n      },\n    },\n    {\n      reg: /([^aeiou][ou])d$/i,\n      repl: {\n        pr: '$1ds',\n        pa: '$1dded',\n        gr: '$1dding',\n      },\n    },\n  ],\n  e: [\n    {\n      reg: /(eave)$/i,\n      repl: {\n        pr: '$1s',\n        pa: '$1d',\n        gr: 'eaving',\n        ar: '$1r',\n      },\n    },\n    {\n      reg: /(ide)$/i,\n      repl: {\n        pr: '$1s',\n        pa: 'ode',\n        gr: 'iding',\n        ar: 'ider',\n      },\n    },\n    {\n      //shake\n      reg: /(t|sh?)(ake)$/i,\n      repl: {\n        pr: '$1$2s',\n        pa: '$1ook',\n        gr: '$1aking',\n        ar: '$1$2r',\n      },\n    },\n    {\n      //awake\n      reg: /w(ake)$/i,\n      repl: {\n        pr: 'w$1s',\n        pa: 'woke',\n        gr: 'waking',\n        ar: 'w$1r',\n      },\n    },\n    {\n      //make\n      reg: /m(ake)$/i,\n      repl: {\n        pr: 'm$1s',\n        pa: 'made',\n        gr: 'making',\n        ar: 'm$1r',\n      },\n    },\n    {\n      reg: /(a[tg]|i[zn]|ur|nc|gl|is)e$/i,\n      repl: {\n        pr: '$1es',\n        pa: '$1ed',\n        gr: '$1ing',\n        // prt: '$1en',\n      },\n    },\n    {\n      reg: /([bd]l)e$/i,\n      repl: {\n        pr: '$1es',\n        pa: '$1ed',\n        gr: '$1ing',\n      },\n    },\n    {\n      reg: /(om)e$/i,\n      repl: {\n        pr: '$1es',\n        pa: 'ame',\n        gr: '$1ing',\n      },\n    },\n  ],\n\n  g: [\n    {\n      reg: /([^aeiou][ou])g$/i,\n      repl: {\n        pr: '$1gs',\n        pa: '$1gged',\n        gr: '$1gging',\n      },\n    },\n  ],\n  h: [\n    {\n      reg: /(..)([cs]h)$/i,\n      repl: {\n        pr: '$1$2es',\n        pa: '$1$2ed',\n        gr: '$1$2ing',\n      },\n    },\n  ],\n  k: [\n    {\n      reg: /(ink)$/i,\n      repl: {\n        pr: '$1s',\n        pa: 'unk',\n        gr: '$1ing',\n        ar: '$1er',\n      },\n    },\n  ],\n\n  m: [\n    {\n      reg: /([^aeiou][aeiou])m$/i,\n      repl: {\n        pr: '$1ms',\n        pa: '$1mmed',\n        gr: '$1mming',\n      },\n    },\n  ],\n\n  n: [\n    {\n      reg: /(en)$/i,\n      repl: {\n        pr: '$1s',\n        pa: '$1ed',\n        gr: '$1ing',\n      },\n    },\n  ],\n  p: [\n    {\n      reg: /(e)(ep)$/i,\n      repl: {\n        pr: '$1$2s',\n        pa: '$1pt',\n        gr: '$1$2ing',\n        ar: '$1$2er',\n      },\n    },\n    {\n      reg: /([^aeiou][aeiou])p$/i,\n      repl: {\n        pr: '$1ps',\n        pa: '$1pped',\n        gr: '$1pping',\n      },\n    },\n    {\n      reg: /([aeiu])p$/i,\n      repl: {\n        pr: '$1ps',\n        pa: '$1p',\n        gr: '$1pping',\n      },\n    },\n  ],\n\n  r: [\n    {\n      reg: /([td]er)$/i,\n      repl: {\n        pr: '$1s',\n        pa: '$1ed',\n        gr: '$1ing',\n      },\n    },\n    {\n      reg: /(er)$/i,\n      repl: {\n        pr: '$1s',\n        pa: '$1ed',\n        gr: '$1ing',\n      },\n    },\n  ],\n  s: [\n    {\n      reg: /(ish|tch|ess)$/i,\n      repl: {\n        pr: '$1es',\n        pa: '$1ed',\n        gr: '$1ing',\n      },\n    },\n  ],\n\n  t: [\n    {\n      reg: /(ion|end|e[nc]t)$/i,\n      repl: {\n        pr: '$1s',\n        pa: '$1ed',\n        gr: '$1ing',\n      },\n    },\n    {\n      reg: /(.eat)$/i,\n      repl: {\n        pr: '$1s',\n        pa: '$1ed',\n        gr: '$1ing',\n      },\n    },\n    {\n      reg: /([aeiu])t$/i,\n      repl: {\n        pr: '$1ts',\n        pa: '$1t',\n        gr: '$1tting',\n      },\n    },\n    {\n      reg: /([^aeiou][aeiou])t$/i,\n      repl: {\n        pr: '$1ts',\n        pa: '$1tted',\n        gr: '$1tting',\n      },\n    },\n  ],\n\n  w: [\n    {\n      reg: /(..)(ow)$/i,\n      repl: {\n        pr: '$1$2s',\n        pa: '$1ew',\n        gr: '$1$2ing',\n        prt: '$1$2n',\n      },\n    },\n  ],\n  y: [\n    {\n      reg: /([i|f|rr])y$/i,\n      repl: {\n        pr: '$1ies',\n        pa: '$1ied',\n        gr: '$1ying',\n      },\n    },\n  ],\n\n  z: [\n    {\n      reg: /([aeiou]zz)$/i,\n      repl: {\n        pr: '$1es',\n        pa: '$1ed',\n        gr: '$1ing',\n      },\n    },\n  ],\n}\n\nmodule.exports = endsWith\n","const suffixes = require('./suffixes')\nconst posMap = {\n  pr: 'PresentTense',\n  pa: 'PastTense',\n  gr: 'Gerund',\n  prt: 'Participle',\n  ar: 'Actor',\n}\n\nconst doTransform = function(str, obj) {\n  let found = {}\n  let keys = Object.keys(obj.repl)\n  for (let i = 0; i < keys.length; i += 1) {\n    let pos = keys[i]\n    found[posMap[pos]] = str.replace(obj.reg, obj.repl[pos])\n  }\n  return found\n}\n\n//look at the end of the word for clues\nconst checkSuffix = function(str = '') {\n  let c = str[str.length - 1]\n  if (suffixes.hasOwnProperty(c) === true) {\n    for (let r = 0; r < suffixes[c].length; r += 1) {\n      const reg = suffixes[c][r].reg\n      if (reg.test(str) === true) {\n        return doTransform(str, suffixes[c][r])\n      }\n    }\n  }\n  return {}\n}\nmodule.exports = checkSuffix\n","//non-specifc, 'hail-mary' transforms from infinitive, into other forms\nconst hasY = /[bcdfghjklmnpqrstvwxz]y$/\n\nconst generic = {\n  Gerund: inf => {\n    if (inf.charAt(inf.length - 1) === 'e') {\n      return inf.replace(/e$/, 'ing')\n    }\n    return inf + 'ing'\n  },\n\n  PresentTense: inf => {\n    if (inf.charAt(inf.length - 1) === 's') {\n      return inf + 'es'\n    }\n    if (hasY.test(inf) === true) {\n      return inf.slice(0, -1) + 'ies'\n    }\n    return inf + 's'\n  },\n\n  PastTense: inf => {\n    if (inf.charAt(inf.length - 1) === 'e') {\n      return inf + 'd'\n    }\n    if (inf.substr(-2) === 'ed') {\n      return inf\n    }\n    if (hasY.test(inf) === true) {\n      return inf.slice(0, -1) + 'ied'\n    }\n    return inf + 'ed'\n  },\n}\n\nmodule.exports = generic\n","const checkSuffix = require('./01-suffixes')\nconst genericFill = require('./02-generic')\n\n//we run this on every verb in the lexicon, so please keep it fast\n//we assume the input word is a proper infinitive\nconst conjugate = function(inf = '', world) {\n  let found = {}\n  // 1. look at irregulars\n  //the lexicon doesn't pass this in\n  if (world && world.irregulars) {\n    if (world.irregulars.verbs.hasOwnProperty(inf) === true) {\n      found = Object.assign({}, world.irregulars.verbs[inf])\n    }\n  }\n  //2. rule-based regex\n  found = Object.assign({}, checkSuffix(inf), found)\n\n  //3. generic transformations\n  //'buzzing'\n  if (found.Gerund === undefined) {\n    found.Gerund = genericFill.Gerund(inf)\n  }\n  //'buzzed'\n  if (found.PastTense === undefined) {\n    found.PastTense = genericFill.PastTense(inf)\n  }\n  //'buzzes'\n  if (found.PresentTense === undefined) {\n    found.PresentTense = genericFill.PresentTense(inf)\n  }\n  return found\n}\nmodule.exports = conjugate\n\n// console.log(conjugate('bake'))\n","//turn 'quick' into 'quickest'\nconst do_rules = [/ght$/, /nge$/, /ough$/, /ain$/, /uel$/, /[au]ll$/, /ow$/, /oud$/, /...p$/]\nconst dont_rules = [/ary$/]\n\nconst irregulars = {\n  nice: 'nicest',\n  late: 'latest',\n  hard: 'hardest',\n  inner: 'innermost',\n  outer: 'outermost',\n  far: 'furthest',\n  worse: 'worst',\n  bad: 'worst',\n  good: 'best',\n  big: 'biggest',\n  large: 'largest',\n}\n\nconst transforms = [\n  {\n    reg: /y$/i,\n    repl: 'iest',\n  },\n  {\n    reg: /([aeiou])t$/i,\n    repl: '$1ttest',\n  },\n  {\n    reg: /([aeou])de$/i,\n    repl: '$1dest',\n  },\n  {\n    reg: /nge$/i,\n    repl: 'ngest',\n  },\n  {\n    reg: /([aeiou])te$/i,\n    repl: '$1test',\n  },\n]\n\nconst to_superlative = function(str) {\n  //irregulars\n  if (irregulars.hasOwnProperty(str)) {\n    return irregulars[str]\n  }\n  //known transforms\n  for (let i = 0; i < transforms.length; i++) {\n    if (transforms[i].reg.test(str)) {\n      return str.replace(transforms[i].reg, transforms[i].repl)\n    }\n  }\n  //dont-rules\n  for (let i = 0; i < dont_rules.length; i++) {\n    if (dont_rules[i].test(str) === true) {\n      return null\n    }\n  }\n  //do-rules\n  for (let i = 0; i < do_rules.length; i++) {\n    if (do_rules[i].test(str) === true) {\n      if (str.charAt(str.length - 1) === 'e') {\n        return str + 'st'\n      }\n      return str + 'est'\n    }\n  }\n  return str + 'est'\n}\n\nmodule.exports = to_superlative\n","//turn 'quick' into 'quickly'\nconst do_rules = [/ght$/, /nge$/, /ough$/, /ain$/, /uel$/, /[au]ll$/, /ow$/, /old$/, /oud$/, /e[ae]p$/]\nconst dont_rules = [/ary$/, /ous$/]\n\nconst irregulars = {\n  grey: 'greyer',\n  gray: 'grayer',\n  green: 'greener',\n  yellow: 'yellower',\n  red: 'redder',\n  good: 'better',\n  well: 'better',\n  bad: 'worse',\n  sad: 'sadder',\n  big: 'bigger',\n}\n\nconst transforms = [\n  {\n    reg: /y$/i,\n    repl: 'ier',\n  },\n  {\n    reg: /([aeiou])t$/i,\n    repl: '$1tter',\n  },\n  {\n    reg: /([aeou])de$/i,\n    repl: '$1der',\n  },\n  {\n    reg: /nge$/i,\n    repl: 'nger',\n  },\n]\n\nconst to_comparative = function(str) {\n  //known-irregulars\n  if (irregulars.hasOwnProperty(str)) {\n    return irregulars[str]\n  }\n  //known-transforms\n  for (let i = 0; i < transforms.length; i++) {\n    if (transforms[i].reg.test(str) === true) {\n      return str.replace(transforms[i].reg, transforms[i].repl)\n    }\n  }\n  //dont-patterns\n  for (let i = 0; i < dont_rules.length; i++) {\n    if (dont_rules[i].test(str) === true) {\n      return null\n    }\n  }\n  //do-patterns\n  for (let i = 0; i < do_rules.length; i++) {\n    if (do_rules[i].test(str) === true) {\n      return str + 'er'\n    }\n  }\n  //easy-one\n  if (/e$/.test(str) === true) {\n    return str + 'r'\n  }\n  return str + 'er'\n}\n\nmodule.exports = to_comparative\n","const fns = {\n  toSuperlative: require('./toSuperlative'),\n  toComparative: require('./toComparative'),\n}\n\n/** conjugate an adjective into other forms */\nconst conjugate = function(w) {\n  let res = {}\n  // 'greatest'\n  let sup = fns.toSuperlative(w)\n  if (sup) {\n    res.Superlative = sup\n  }\n  // 'greater'\n  let comp = fns.toComparative(w)\n  if (comp) {\n    res.Comparative = comp\n  }\n  return res\n}\nmodule.exports = conjugate\n","/** patterns for turning 'bus' to 'buses'*/\nconst suffixes = {\n  a: [[/(antenn|formul|nebul|vertebr|vit)a$/i, '$1ae'], [/([ti])a$/i, '$1a']],\n\n  e: [\n    [/(kn|l|w)ife$/i, '$1ives'],\n    [/(hive)$/i, '$1s'],\n    [/([m|l])ouse$/i, '$1ice'],\n    [/([m|l])ice$/i, '$1ice'],\n  ],\n\n  f: [\n    [/^(dwar|handkerchie|hoo|scar|whar)f$/i, '$1ves'],\n    [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)f$/i, '$1ves'],\n  ],\n\n  i: [[/(octop|vir)i$/i, '$1i']],\n\n  m: [[/([ti])um$/i, '$1a']],\n\n  n: [[/^(oxen)$/i, '$1']],\n\n  o: [[/(al|ad|at|er|et|ed|ad)o$/i, '$1oes']],\n\n  s: [\n    [/(ax|test)is$/i, '$1es'],\n    [/(alias|status)$/i, '$1es'],\n    [/sis$/i, 'ses'],\n    [/(bu)s$/i, '$1ses'],\n    [/(sis)$/i, 'ses'],\n    [/^(?!talis|.*hu)(.*)man$/i, '$1men'],\n    [/(octop|vir|radi|nucle|fung|cact|stimul)us$/i, '$1i'],\n  ],\n\n  x: [[/(matr|vert|ind|cort)(ix|ex)$/i, '$1ices'], [/^(ox)$/i, '$1en']],\n\n  y: [[/([^aeiouy]|qu)y$/i, '$1ies']],\n\n  z: [[/(quiz)$/i, '$1zes']],\n}\n\nmodule.exports = suffixes\n","const rules = require('./_rules')\nconst addE = /(x|ch|sh|s|z)$/\n\nconst trySuffix = function(str) {\n  let c = str[str.length - 1]\n  if (rules.hasOwnProperty(c) === true) {\n    for (let i = 0; i < rules[c].length; i += 1) {\n      let reg = rules[c][i][0]\n      if (reg.test(str) === true) {\n        return str.replace(reg, rules[c][i][1])\n      }\n    }\n  }\n  return null\n}\n\n/** Turn a singular noun into a plural\n * assume the given string is singular\n */\nconst pluralize = function(str = '', world) {\n  let irregulars = world.irregulars.nouns\n\n  // check irregulars list\n  if (irregulars.hasOwnProperty(str)) {\n    return irregulars[str]\n  }\n\n  //we have some rules to try-out\n  let plural = trySuffix(str)\n  if (plural !== null) {\n    return plural\n  }\n  //like 'church'\n  if (addE.test(str)) {\n    return str + 'es'\n  }\n  // ¯\\_(ツ)_/¯\n  return str + 's'\n}\nmodule.exports = pluralize\n","//patterns for turning 'dwarves' to 'dwarf'\nmodule.exports = [\n  [/([^v])ies$/i, '$1y'],\n  [/ises$/i, 'isis'],\n  [/(kn|[^o]l|w)ives$/i, '$1ife'],\n  [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)ves$/i, '$1f'],\n  [/^(dwar|handkerchie|hoo|scar|whar)ves$/i, '$1f'],\n  [/(antenn|formul|nebul|vertebr|vit)ae$/i, '$1a'],\n  [/(octop|vir|radi|nucle|fung|cact|stimul)(i)$/i, '$1us'],\n  [/(buffal|tomat|tornad)(oes)$/i, '$1o'],\n  // [/(analy|diagno|parenthe|progno|synop|the)ses$/i, '$1sis'],\n  [/(..[aeiou]s)es$/i, '$1'],\n  [/(vert|ind|cort)(ices)$/i, '$1ex'],\n  [/(matr|append)(ices)$/i, '$1ix'],\n  [/(x|ch|ss|sh|z|o)es$/i, '$1'],\n  [/men$/i, 'man'],\n  [/(n)ews$/i, '$1ews'],\n  [/([ti])a$/i, '$1um'],\n  [/([^aeiouy]|qu)ies$/i, '$1y'],\n  [/(s)eries$/i, '$1eries'],\n  [/(m)ovies$/i, '$1ovie'],\n  [/([m|l])ice$/i, '$1ouse'],\n  [/(cris|ax|test)es$/i, '$1is'],\n  [/(alias|status)es$/i, '$1'],\n  [/(ss)$/i, '$1'],\n  [/(ics)$/i, '$1'],\n  [/s$/i, ''],\n]\n","const rules = require('./_rules')\n\nconst invertObj = function(obj) {\n  return Object.keys(obj).reduce((h, k) => {\n    h[obj[k]] = k\n    return h\n  }, {})\n}\n\nconst toSingular = function(str, world) {\n  let irregulars = world.irregulars.nouns\n  let invert = invertObj(irregulars)\n\n  // check irregulars list\n  if (invert.hasOwnProperty(str)) {\n    return invert[str]\n  }\n\n  // go through our regexes\n  for (let i = 0; i < rules.length; i++) {\n    if (rules[i][0].test(str) === true) {\n      str = str.replace(rules[i][0], rules[i][1])\n      return str\n    }\n  }\n  return str\n}\nmodule.exports = toSingular\n","//rules for turning a verb into infinitive form\nlet rules = {\n  Participle: [\n    {\n      reg: /own$/i,\n      to: 'ow',\n    },\n    {\n      reg: /(.)un([g|k])$/i,\n      to: '$1in$2',\n    },\n  ],\n\n  Actor: [\n    {\n      reg: /(er)er$/i,\n      to: '$1',\n    },\n  ],\n\n  PresentTense: [\n    {\n      reg: /(..)(ies)$/i,\n      to: '$1y',\n    },\n    {\n      reg: /(tch|sh)es$/i,\n      to: '$1',\n    },\n    {\n      reg: /(ss|zz)es$/i,\n      to: '$1',\n    },\n    {\n      reg: /([tzlshicgrvdnkmu])es$/i,\n      to: '$1e',\n    },\n    {\n      reg: /(n[dtk]|c[kt]|[eo]n|i[nl]|er|a[ytrl])s$/i,\n      to: '$1',\n    },\n    {\n      reg: /(ow)s$/i,\n      to: '$1',\n    },\n    {\n      reg: /(op)s$/i,\n      to: '$1',\n    },\n    {\n      reg: /([eirs])ts$/i,\n      to: '$1t',\n    },\n    {\n      reg: /(ll)s$/i,\n      to: '$1',\n    },\n    {\n      reg: /(el)s$/i,\n      to: '$1',\n    },\n    {\n      reg: /(ip)es$/i,\n      to: '$1e',\n    },\n    {\n      reg: /ss$/i,\n      to: 'ss',\n    },\n    {\n      reg: /s$/i,\n      to: '',\n    },\n  ],\n\n  Gerund: [\n    {\n      //popping -> pop\n      reg: /(..)(p|d|t|g){2}ing$/i,\n      to: '$1$2',\n    },\n    {\n      //fuzzing -> fuzz\n      reg: /(ll|ss|zz)ing$/i,\n      to: '$1',\n    },\n    {\n      reg: /([^aeiou])ying$/i,\n      to: '$1y',\n    },\n    {\n      reg: /([^ae]i.)ing$/i,\n      to: '$1e',\n    },\n    {\n      //eating, reading\n      reg: /(ea[dklnrtv])ing$/i,\n      to: '$1',\n    },\n    {\n      //washing -> wash\n      reg: /(ch|sh)ing$/i,\n      to: '$1',\n    },\n    //soft-e forms:\n    {\n      //z : hazing (not buzzing)\n      reg: /(z)ing$/i,\n      to: '$1e',\n    },\n    {\n      //a : baking, undulating\n      reg: /(a[gdkvtc])ing$/i,\n      to: '$1e',\n    },\n    {\n      //u : conjuring, tubing\n      reg: /(u[rtcbn])ing$/i,\n      to: '$1e',\n    },\n    {\n      //o : forboding, poking, hoping, boring (not hooping)\n      reg: /([^o]o[bdknprv])ing$/i,\n      to: '$1e',\n    },\n    {\n      //ling : tingling, wrinkling, circling, scrambling, bustling\n      reg: /([tbckg]l)ing$/i, //dp\n      to: '$1e',\n    },\n    {\n      //cing : bouncing, denouncing\n      reg: /(c)ing$/i, //dp\n      to: '$1e',\n    },\n\n    // {\n    //   //soft-e :\n    //   reg: /([ua]s|[dr]g|z|o[rlsp]|cre)ing$/i,\n    //   to: '$1e',\n    // },\n    {\n      //fallback\n      reg: /(..)ing$/i,\n      to: '$1',\n    },\n  ],\n\n  PastTense: [\n    {\n      reg: /(ued)$/i,\n      to: 'ue',\n    },\n    {\n      reg: /a([^aeiouy])ed$/i,\n      to: 'a$1e',\n    },\n    {\n      reg: /([aeiou]zz)ed$/i,\n      to: '$1',\n    },\n    {\n      reg: /(e|i)lled$/i,\n      to: '$1ll',\n    },\n    {\n      reg: /(.)(sh|ch)ed$/i,\n      to: '$1$2',\n    },\n    {\n      reg: /(tl|gl)ed$/i,\n      to: '$1e',\n    },\n    {\n      reg: /(um?pt?)ed$/i,\n      to: '$1',\n    },\n    {\n      reg: /(ss)ed$/i,\n      to: '$1',\n    },\n    {\n      reg: /pped$/i,\n      to: 'p',\n    },\n    {\n      reg: /tted$/i,\n      to: 't',\n    },\n    {\n      reg: /(..)gged$/i,\n      to: '$1g',\n    },\n    {\n      reg: /(..)lked$/i,\n      to: '$1lk',\n    },\n    {\n      reg: /([^aeiouy][aeiou])ked$/i,\n      to: '$1ke',\n    },\n    {\n      reg: /(.[aeiou])led$/i,\n      to: '$1l',\n    },\n    {\n      reg: /(..)(h|ion|n[dt]|ai.|[cs]t|pp|all|ss|tt|int|ail|ld|en|oo.|er|k|pp|w|ou.|rt|ght|rm)ed$/i,\n      to: '$1$2',\n    },\n    {\n      reg: /(.ut)ed$/i,\n      to: '$1e',\n    },\n    {\n      reg: /(.pt)ed$/i,\n      to: '$1',\n    },\n    {\n      reg: /(us)ed$/i,\n      to: '$1e',\n    },\n    {\n      reg: /(..[^aeiouy])ed$/i,\n      to: '$1e',\n    },\n    {\n      reg: /(..)ied$/i,\n      to: '$1y',\n    },\n    {\n      reg: /(.o)ed$/i,\n      to: '$1o',\n    },\n    {\n      reg: /(..i)ed$/i,\n      to: '$1',\n    },\n    {\n      reg: /(.a[^aeiou])ed$/i,\n      to: '$1',\n    },\n    {\n      //owed, aced\n      reg: /([aeiou][^aeiou])ed$/i,\n      to: '$1e',\n    },\n    {\n      reg: /([rl])ew$/i,\n      to: '$1ow',\n    },\n    {\n      reg: /([pl])t$/i,\n      to: '$1t',\n    },\n  ],\n}\nmodule.exports = rules\n","let guessVerb = {\n  Gerund: ['ing'],\n  Actor: ['erer'],\n  Infinitive: [\n    'ate',\n    'ize',\n    'tion',\n    'rify',\n    'then',\n    'ress',\n    'ify',\n    'age',\n    'nce',\n    'ect',\n    'ise',\n    'ine',\n    'ish',\n    'ace',\n    'ash',\n    'ure',\n    'tch',\n    'end',\n    'ack',\n    'and',\n    'ute',\n    'ade',\n    'ock',\n    'ite',\n    'ase',\n    'ose',\n    'use',\n    'ive',\n    'int',\n    'nge',\n    'lay',\n    'est',\n    'ain',\n    'ant',\n    'ent',\n    'eed',\n    'er',\n    'le',\n    'own',\n    'unk',\n    'ung',\n    'en',\n  ],\n  PastTense: ['ed', 'lt', 'nt', 'pt', 'ew', 'ld'],\n  PresentTense: [\n    'rks',\n    'cks',\n    'nks',\n    'ngs',\n    'mps',\n    'tes',\n    'zes',\n    'ers',\n    'les',\n    'acks',\n    'ends',\n    'ands',\n    'ocks',\n    'lays',\n    'eads',\n    'lls',\n    'els',\n    'ils',\n    'ows',\n    'nds',\n    'ays',\n    'ams',\n    'ars',\n    'ops',\n    'ffs',\n    'als',\n    'urs',\n    'lds',\n    'ews',\n    'ips',\n    'es',\n    'ts',\n    'ns',\n  ],\n}\n//flip it into a lookup object\nguessVerb = Object.keys(guessVerb).reduce((h, k) => {\n  guessVerb[k].forEach(a => (h[a] = k))\n  return h\n}, {})\nmodule.exports = guessVerb\n","const lexData = require('./_data')\nconst defaultTags = require('./tags')\nconst unpack = require('efrt-unpack')\nconst addLex = require('./addWords')\nconst addIrregulars = require('./addIrregulars')\nconst inferTagSet = require('./tags/inference')\n\nlet misc = require('./data/misc')\n\n//these let users change inflection / verb conjugation\nconst irregulars = {\n  nouns: require('./data/plurals'),\n  verbs: require('./data/conjugations'),\n}\n\n//these behaviours are configurable & shared across some plugins\nconst transforms = {\n  conjugate: require('../transforms/conjugate'),\n  adjectives: require('../transforms/adjectives'),\n  toPlural: require('../transforms/toPlural'),\n  toSingular: require('../transforms/toSingular'),\n  toInfinitive: require('../transforms/toInfinitive'),\n}\n\nlet isVerbose = false\n\n/** all configurable linguistic data */\nclass World {\n  constructor() {\n    // quiet these properties from a console.log\n    Object.defineProperty(this, 'words', {\n      enumerable: false,\n      value: misc,\n      writable: true,\n    })\n    Object.defineProperty(this, 'hasCompound', {\n      enumerable: false,\n      value: {},\n      writable: true,\n    })\n    Object.defineProperty(this, 'irregulars', {\n      enumerable: false,\n      value: irregulars,\n      writable: true,\n    })\n    Object.defineProperty(this, 'tags', {\n      enumerable: false,\n      value: Object.assign({}, defaultTags),\n      writable: true,\n    })\n    Object.defineProperty(this, 'transforms', {\n      enumerable: false,\n      value: transforms,\n      writable: true,\n    })\n\n    Object.defineProperty(this, 'taggers', {\n      enumerable: false,\n      value: [],\n      writable: true,\n    })\n    // add our compressed data to lexicon\n    this.unpackWords(lexData)\n    // add our irregulars to lexicon\n    this.addIrregulars()\n\n    // cache our abbreviations for our sentence-parser\n    Object.defineProperty(this, 'cache', {\n      enumerable: false,\n      value: {\n        abbreviations: this.getByTag('Abbreviation'),\n      },\n    })\n  }\n\n  /** more logs for debugging */\n  verbose(bool) {\n    isVerbose = bool\n    return this\n  }\n  isVerbose() {\n    return isVerbose\n  }\n\n  /** get all terms in our lexicon with this tag */\n  getByTag(tag) {\n    let lex = this.words\n    let res = {}\n    let words = Object.keys(lex)\n    for (let i = 0; i < words.length; i++) {\n      if (typeof lex[words[i]] === 'string') {\n        if (lex[words[i]] === tag) {\n          res[words[i]] = true\n        }\n      } else if (lex[words[i]].some(t => t === tag)) {\n        res[words[i]] = true\n      }\n    }\n    return res\n  }\n\n  /** augment our lingustic data with new data */\n  unpackWords(lex) {\n    let tags = Object.keys(lex)\n    for (let i = 0; i < tags.length; i++) {\n      let words = Object.keys(unpack(lex[tags[i]]))\n      for (let w = 0; w < words.length; w++) {\n        addLex.addWord(words[w], tags[i], this.words)\n        // do some fancier stuff\n        addLex.addMore(words[w], tags[i], this)\n      }\n    }\n  }\n  /** put new words into our lexicon, properly */\n  addWords(obj) {\n    let keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      let word = keys[i].toLowerCase()\n      addLex.addWord(word, obj[keys[i]], this.words)\n      // do some fancier stuff\n      addLex.addMore(word, obj[keys[i]], this)\n    }\n  }\n\n  addIrregulars() {\n    addIrregulars(this)\n    return this\n  }\n\n  /** extend the compromise tagset */\n  addTags(tags) {\n    tags = Object.assign({}, tags)\n    this.tags = Object.assign(this.tags, tags)\n    // calculate graph implications for the new tags\n    this.tags = inferTagSet(this.tags)\n    return this\n  }\n  /** call methods after tagger runs */\n  postProcess(fn) {\n    this.taggers.push(fn)\n    return this\n  }\n\n  /** helper method for logging + debugging */\n  stats() {\n    return {\n      words: Object.keys(this.words).length,\n      plurals: Object.keys(this.irregulars.nouns).length,\n      conjugations: Object.keys(this.irregulars.verbs).length,\n      compounds: Object.keys(this.hasCompound).length,\n      postProcessors: this.taggers.length,\n    }\n  }\n}\n\n//  ¯\\_(:/)_/¯\nconst clone = function(obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\n/** produce a deep-copy of all lingustic data */\nWorld.prototype.clone = function() {\n  let w2 = new World()\n  // these are simple to copy:\n  w2.words = Object.assign({}, this.words)\n  w2.hasCompound = Object.assign({}, this.hasCompound)\n  //these ones are nested:\n  w2.irregulars = clone(this.irregulars)\n  w2.tags = clone(this.tags)\n  // these are functions\n  w2.transforms = this.transforms\n  w2.taggers = this.taggers\n  return w2\n}\nmodule.exports = World\n","//nouns with irregular plural/singular forms\n//used in noun.inflect, and also in the lexicon.\n\nmodule.exports = {\n  addendum: 'addenda',\n  alga: 'algae',\n  alumna: 'alumnae',\n  alumnus: 'alumni',\n  analysis: 'analyses',\n  antenna: 'antennae',\n  appendix: 'appendices',\n  avocado: 'avocados',\n  axis: 'axes',\n  bacillus: 'bacilli',\n  barracks: 'barracks',\n  beau: 'beaux',\n  bus: 'buses',\n  cactus: 'cacti',\n  chateau: 'chateaux',\n  child: 'children',\n  circus: 'circuses',\n  clothes: 'clothes',\n  corpus: 'corpora',\n  criterion: 'criteria',\n  curriculum: 'curricula',\n  database: 'databases',\n  deer: 'deer',\n  diagnosis: 'diagnoses',\n  echo: 'echoes',\n  embargo: 'embargoes',\n  epoch: 'epochs',\n  foot: 'feet',\n  formula: 'formulae',\n  fungus: 'fungi',\n  genus: 'genera',\n  goose: 'geese',\n  halo: 'halos',\n  hippopotamus: 'hippopotami',\n  index: 'indices',\n  larva: 'larvae',\n  leaf: 'leaves',\n  libretto: 'libretti',\n  loaf: 'loaves',\n  man: 'men',\n  matrix: 'matrices',\n  memorandum: 'memoranda',\n  modulus: 'moduli',\n  mosquito: 'mosquitoes',\n  mouse: 'mice',\n  move: 'moves',\n  nebula: 'nebulae',\n  nucleus: 'nuclei',\n  octopus: 'octopi',\n  opus: 'opera',\n  ovum: 'ova',\n  ox: 'oxen',\n  parenthesis: 'parentheses',\n  person: 'people',\n  phenomenon: 'phenomena',\n  prognosis: 'prognoses',\n  quiz: 'quizzes',\n  radius: 'radii',\n  referendum: 'referenda',\n  rodeo: 'rodeos',\n  sex: 'sexes',\n  shoe: 'shoes',\n  sombrero: 'sombreros',\n  stimulus: 'stimuli',\n  stomach: 'stomachs',\n  syllabus: 'syllabi',\n  synopsis: 'synopses',\n  tableau: 'tableaux',\n  thesis: 'theses',\n  thief: 'thieves',\n  tooth: 'teeth',\n  tornado: 'tornados',\n  tuxedo: 'tuxedos',\n  vertebra: 'vertebrae',\n  // virus: 'viri',\n  // zero: 'zeros',\n}\n","const rules = require('./_transform')\nconst guess = require('./_guess')\n\n/** it helps to know what we're conjugating from */\nconst guessTense = function(str) {\n  let three = str.substr(str.length - 3)\n  if (guess.hasOwnProperty(three) === true) {\n    return guess[three]\n  }\n  let two = str.substr(str.length - 2)\n  if (guess.hasOwnProperty(two) === true) {\n    return guess[two]\n  }\n  let one = str.substr(str.length - 1)\n  if (one === 's') {\n    return 'PresentTense'\n  }\n  return null\n}\n\nconst toInfinitive = function(str, world, tense) {\n  if (!str) {\n    return ''\n  }\n  //1. look at known irregulars\n  if (world.words.hasOwnProperty(str) === true) {\n    let irregs = world.irregulars.verbs\n    let keys = Object.keys(irregs)\n    for (let i = 0; i < keys.length; i++) {\n      let forms = Object.keys(irregs[keys[i]])\n      for (let o = 0; o < forms.length; o++) {\n        if (str === irregs[keys[i]][forms[o]]) {\n          return keys[i]\n        }\n      }\n    }\n  }\n\n  // give'r!\n  tense = tense || guessTense(str)\n  if (tense && rules[tense]) {\n    for (let i = 0; i < rules[tense].length; i++) {\n      const rule = rules[tense][i]\n      if (rule.reg.test(str) === true) {\n        return str.replace(rule.reg, rule.to)\n      }\n    }\n  }\n  return str\n}\nmodule.exports = toInfinitive\n","/** return the root, first document */\nexports.all = function() {\n  return this.parents()[0] || this\n}\n\n/** return the previous result */\nexports.parent = function() {\n  if (this.from) {\n    return this.from\n  }\n  return this\n}\n\n/**  return a list of all previous results */\nexports.parents = function(n) {\n  let arr = []\n  const addParent = function(doc) {\n    if (doc.from) {\n      arr.push(doc.from)\n      addParent(doc.from)\n    }\n  }\n  addParent(this)\n  arr = arr.reverse()\n  if (typeof n === 'number') {\n    return arr[n]\n  }\n  return arr\n}\n\n/** deep-copy the document, so that no references remain */\nexports.clone = function(doShallow) {\n  let list = this.list.map(ts => ts.clone(doShallow))\n  let tmp = this.buildFrom(list)\n  return tmp\n}\n\n/** how many seperate terms does the document have? */\nexports.wordCount = function() {\n  return this.list.reduce((count, p) => {\n    count += p.wordCount()\n    return count\n  }, 0)\n}\nexports.wordcount = exports.wordCount\n\n/** turn on logging for decision-debugging */\n// exports.verbose = function(bool) {\n//   if (bool === undefined) {\n//     bool = true\n//   }\n//   this.world.verbose = bool\n// }\n\n/** freeze the current state of the document, for speed-purposes*/\nexports.cache = function(options) {\n  options = options || {}\n  this.list.forEach(p => {\n    let words = {}\n    p.cache = p.cache || {}\n    p.cache.terms = p.cache.terms || p.terms()\n    // cache all the terms\n    p.cache.terms.forEach(t => {\n      words[t.clean] = true\n      words[t.reduced] = true\n      words[t.text.toLowerCase()] = true\n      if (t.implicit) {\n        words[t.implicit] = true\n      }\n      if (t.root) {\n        words[t.root] = true\n      }\n      if (t.alias !== undefined) {\n        words = Object.assign(words, t.alias)\n      }\n      if (options.root) {\n        t.setRoot(this.world)\n        words[t.root] = true\n      }\n    })\n    delete words['']\n    p.cache.words = words\n  })\n  return this\n}\n\n/** un-freezes the current state of the document, so it may be transformed */\nexports.uncache = function() {\n  this.list.forEach(p => {\n    p.cache = {}\n  })\n  // do parents too?\n  this.parents().forEach(doc => {\n    doc.list.forEach(p => {\n      p.cache = {}\n    })\n  })\n  return this\n}\n","/** use only the first result(s) */\nexports.first = function(n) {\n  if (n === undefined) {\n    return this.get(0)\n  }\n  return this.slice(0, n)\n}\n\n/** use only the last result(s) */\nexports.last = function(n) {\n  if (n === undefined) {\n    return this.get(this.list.length - 1)\n  }\n  let end = this.list.length\n  return this.slice(end - n, end)\n}\n\n/** grab a given subset of the results*/\nexports.slice = function(start, end) {\n  let list = this.list.slice(start, end)\n  return this.buildFrom(list)\n}\n\n/* grab nth result */\nexports.eq = function(n) {\n  let p = this.list[n]\n  if (p === undefined) {\n    return this.buildFrom([])\n  }\n  return this.buildFrom([p])\n}\nexports.get = exports.eq\n\n/** grab term[0] for every match */\nexports.firstTerm = function() {\n  return this.match('^.')\n}\n/** grab the last term for every match  */\nexports.lastTerm = function() {\n  return this.match('.$')\n}\n\n/** return a flat array of term objects */\nexports.termList = function(num) {\n  let arr = []\n  //'reduce' but faster\n  for (let i = 0; i < this.list.length; i++) {\n    let terms = this.list[i].terms()\n    for (let o = 0; o < terms.length; o++) {\n      arr.push(terms[o])\n      //support .termList(4)\n      if (num !== undefined && arr[num] !== undefined) {\n        return arr[num]\n      }\n    }\n  }\n  return arr\n}\n\n/* grab named capture group terms as object */\nconst groupByNames = function(doc) {\n  let res = {}\n  const groups = {}\n  for (let i = 0; i < doc.list.length; i++) {\n    const phrase = doc.list[i]\n    const names = Object.values(phrase.names)\n    for (let j = 0; j < names.length; j++) {\n      const { group, start, length } = names[j]\n      if (!groups[group]) {\n        groups[group] = []\n      }\n      groups[group].push(phrase.buildFrom(start, length))\n    }\n  }\n  const keys = Object.keys(groups)\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]\n    res[key] = doc.buildFrom(groups[key])\n  }\n  return res\n}\n\nconst getOneName = function(doc, name) {\n  const arr = []\n  for (let i = 0; i < doc.list.length; i++) {\n    const phrase = doc.list[i]\n    let keys = Object.keys(phrase.names)\n    keys = keys.filter(id => phrase.names[id].group === name)\n    keys.forEach(id => {\n      arr.push(phrase.buildFrom(phrase.names[id].start, phrase.names[id].length))\n    })\n  }\n  return doc.buildFrom(arr)\n}\n\n/** grab named capture group results */\nexports.byName = function(target) {\n  if (target === undefined) {\n    return groupByNames(this)\n  }\n  if (typeof target === 'number') {\n    target = String(target)\n  }\n  return getOneName(this, target) || this.buildFrom([])\n}\nexports.names = exports.byName\nexports.named = exports.byName\n","const parseSyntax = require('../match/syntax')\n\n/** return a new Doc, with this one as a parent */\nexports.match = function(reg) {\n  //parse-up the input expression\n  let regs = parseSyntax(reg)\n  if (regs.length === 0) {\n    return this.buildFrom([])\n  }\n  //try expression on each phrase\n  let matches = this.list.reduce((arr, p) => {\n    return arr.concat(p.match(regs))\n  }, [])\n  return this.buildFrom(matches)\n}\n\n/** return all results except for this */\nexports.not = function(reg) {\n  //parse-up the input expression\n  let regs = parseSyntax(reg)\n  //if it's empty, return them all!\n  if (regs.length === 0) {\n    return this\n  }\n  //try expression on each phrase\n  let matches = this.list.reduce((arr, p) => {\n    return arr.concat(p.not(regs))\n  }, [])\n  return this.buildFrom(matches)\n}\n\n/** return only the first match */\nexports.matchOne = function(reg) {\n  let regs = parseSyntax(reg)\n  for (let i = 0; i < this.list.length; i++) {\n    let match = this.list[i].match(regs, true)\n    return this.buildFrom(match)\n  }\n  return this.buildFrom([])\n}\n\n/** return each current phrase, only if it contains this match */\nexports.if = function(reg) {\n  let regs = parseSyntax(reg)\n  let found = this.list.filter(p => p.has(regs) === true)\n  return this.buildFrom(found)\n}\n\n/** Filter-out any current phrases that have this match*/\nexports.ifNo = function(reg) {\n  let regs = parseSyntax(reg)\n  let found = this.list.filter(p => p.has(regs) === false)\n  return this.buildFrom(found)\n}\n\n/**Return a boolean if this match exists */\nexports.has = function(reg) {\n  let regs = parseSyntax(reg)\n  return this.list.some(p => p.has(regs) === true)\n}\n\n/** match any terms after our matches, within the sentence */\nexports.lookAhead = function(reg) {\n  // find everything afterwards, by default\n  if (!reg) {\n    reg = '.*'\n  }\n  let regs = parseSyntax(reg)\n  let matches = []\n  this.list.forEach(p => {\n    matches = matches.concat(p.lookAhead(regs))\n  })\n  matches = matches.filter(p => p)\n  return this.buildFrom(matches)\n}\nexports.lookAfter = exports.lookAhead\n\n/** match any terms before our matches, within the sentence */\nexports.lookBehind = function(reg) {\n  // find everything afterwards, by default\n  if (!reg) {\n    reg = '.*'\n  }\n  let regs = parseSyntax(reg)\n  let matches = []\n  this.list.forEach(p => {\n    matches = matches.concat(p.lookBehind(regs))\n  })\n  matches = matches.filter(p => p)\n  return this.buildFrom(matches)\n}\nexports.lookBefore = exports.lookBehind\n\n/** return all terms before a match, in each phrase */\nexports.before = function(reg) {\n  let regs = parseSyntax(reg)\n  //only the phrases we care about\n  let phrases = this.if(regs).list\n  let befores = phrases.map(p => {\n    let ids = p.terms().map(t => t.id)\n    //run the search again\n    let m = p.match(regs)[0]\n    let index = ids.indexOf(m.start)\n    //nothing is before a first-term match\n    if (index === 0 || index === -1) {\n      return null\n    }\n    return p.buildFrom(p.start, index)\n  })\n  befores = befores.filter(p => p !== null)\n  return this.buildFrom(befores)\n}\n\n/** return all terms after a match, in each phrase */\nexports.after = function(reg) {\n  let regs = parseSyntax(reg)\n  //only the phrases we care about\n  let phrases = this.if(regs).list\n  let befores = phrases.map(p => {\n    let terms = p.terms()\n    let ids = terms.map(t => t.id)\n    //run the search again\n    let m = p.match(regs)[0]\n    let index = ids.indexOf(m.start)\n    //skip if nothing is after it\n    if (index === -1 || !terms[index + m.length]) {\n      return null\n    }\n    //create the new phrase, after our match.\n    let id = terms[index + m.length].id\n    let len = p.length - index - m.length\n    return p.buildFrom(id, len)\n  })\n  befores = befores.filter(p => p !== null)\n  return this.buildFrom(befores)\n}\n","/** apply a tag, or tags to all terms */\nconst tagTerms = function(tag, doc, safe, reason) {\n  let tagList = []\n  if (typeof tag === 'string') {\n    tagList = tag.split(' ')\n  }\n\n  //do indepenent tags for each term:\n  doc.list.forEach(p => {\n    let terms = p.cache.terms || p.terms()\n    // tagSafe - apply only to fitting terms\n    if (safe === true) {\n      terms = terms.filter(t => t.canBe(tag, doc.world))\n    }\n    terms.forEach((t, i) => {\n      //fancy version:\n      if (tagList.length > 1) {\n        if (tagList[i] && tagList[i] !== '.') {\n          t.tag(tagList[i], reason, doc.world)\n        }\n      } else {\n        //non-fancy version (same tag for all terms)\n        t.tag(tag, reason, doc.world)\n      }\n    })\n  })\n  return\n}\nmodule.exports = tagTerms\n","const setTag = require('./_setTag')\n\n/** Give all terms the given tag */\nexports.tag = function(tags, why) {\n  if (!tags) {\n    return this\n  }\n  setTag(tags, this, false, why)\n  return this\n}\n\n/** Only apply tag to terms if it is consistent with current tags */\nexports.tagSafe = function(tags, why) {\n  if (!tags) {\n    return this\n  }\n  setTag(tags, this, true, why)\n  return this\n}\n\n/** Remove this term from the given terms */\nexports.unTag = function(tags, why) {\n  this.list.forEach(p => {\n    p.terms().forEach(t => t.unTag(tags, why, this.world))\n  })\n  return this\n}\n\n/** return only the terms that can be this tag*/\nexports.canBe = function(tag) {\n  if (!tag) {\n    return this\n  }\n  let world = this.world\n  let matches = this.list.reduce((arr, p) => {\n    return arr.concat(p.canBe(tag, world))\n  }, [])\n  return this.buildFrom(matches)\n}\n","/* run each phrase through a function, and create a new document */\nexports.map = function(fn) {\n  if (!fn) {\n    return this\n  }\n  let list = this.list.map((p, i) => {\n    let doc = this.buildFrom([p])\n    doc.from = null //it's not a child/parent\n    let res = fn(doc, i)\n    if (res.list && res.list[0]) {\n      return res.list[0]\n    }\n    return res\n  })\n  if (list.length === 0) {\n    return this.buildFrom(list)\n  }\n  // if it is not a list of Phrase objects, then don't try to make a Doc object\n  if (typeof list[0] !== 'object' || list[0].isA !== 'Phrase') {\n    return list\n  }\n  return this.buildFrom(list)\n}\n\n/** run a function on each phrase */\nexports.forEach = function(fn, detachParent) {\n  if (!fn) {\n    return this\n  }\n  this.list.forEach((p, i) => {\n    let sub = this.buildFrom([p])\n    // if we're doing fancy insertions, we may want to skip updating the parent each time.\n    if (detachParent === true) {\n      sub.from = null //\n    }\n    fn(sub, i)\n  })\n  return this\n}\n\n/** return only the phrases that return true */\nexports.filter = function(fn) {\n  if (!fn) {\n    return this\n  }\n  let list = this.list.filter((p, i) => {\n    let doc = this.buildFrom([p])\n    doc.from = null //it's not a child/parent\n    return fn(doc, i)\n  })\n  return this.buildFrom(list)\n}\n\n/** return a document with only the first phrase that matches */\nexports.find = function(fn) {\n  if (!fn) {\n    return this\n  }\n  let phrase = this.list.find((p, i) => {\n    let doc = this.buildFrom([p])\n    doc.from = null //it's not a child/parent\n    return fn(doc, i)\n  })\n  if (phrase) {\n    return this.buildFrom([phrase])\n  }\n  return undefined\n}\n\n/** return true or false if there is one matching phrase */\nexports.some = function(fn) {\n  if (!fn) {\n    return this\n  }\n  return this.list.some((p, i) => {\n    let doc = this.buildFrom([p])\n    doc.from = null //it's not a child/parent\n    return fn(doc, i)\n  })\n}\n\n/** sample a subset of the results */\nexports.random = function(n) {\n  if (!this.found) {\n    return this\n  }\n  let r = Math.floor(Math.random() * this.list.length)\n  if (n === undefined) {\n    let list = [this.list[r]]\n    return this.buildFrom(list)\n  }\n  //prevent it from going over the end\n  if (r + n > this.length) {\n    r = this.length - n\n    r = r < 0 ? 0 : r\n  }\n  return this.slice(r, r + n)\n}\n\n/** combine each phrase into a new data-structure */\n// exports.reduce = function(fn, h) {\n//   let list = this.list.reduce((_h, ts) => {\n//     let doc = this.buildFrom([ts])\n//     doc.from = null //it's not a child/parent\n//     return fn(_h, doc)\n//   }, h)\n//   return this.buildFrom(list)\n// }\n","const tokenize = require('../../01-tokenizer/02-words')\n\n// compare one term and one match\nconst doesMatch = function(term, str) {\n  if (str === '') {\n    return false\n  }\n  return term.reduced === str || term.implicit === str || term.root === str || term.text.toLowerCase() === str\n}\n\n// is this lookup found in these terms?\nconst findStart = function(arr, terms) {\n  //find the start\n  for (let i = 0; i < terms.length; i++) {\n    if (doesMatch(terms[i], arr[0])) {\n      if (arr.every((a, n) => terms[i + n] && doesMatch(terms[i + n], a) === true)) {\n        return terms[i].id\n      }\n    }\n  }\n  return false\n}\n\n/** lookup an array of words or phrases */\nexports.lookup = function(arr) {\n  if (typeof arr === 'string') {\n    arr = [arr]\n  }\n  let lookups = arr.map(str => {\n    str = str.toLowerCase()\n    let words = tokenize(str)\n    words = words.map(s => s.trim())\n    return words\n  })\n  this.cache()\n  let found = []\n  // try each lookup\n  lookups.forEach(a => {\n    //try each phrase\n    this.list.forEach(p => {\n      // cache-miss, skip.\n      if (p.cache.words[a[0]] !== true) {\n        return\n      }\n      //we found a potential match\n      let terms = p.terms()\n      let id = findStart(a, terms)\n      if (id !== false) {\n        // create the actual phrase\n        let phrase = p.buildFrom(id, a.length)\n        found.push(phrase)\n        return\n      }\n    })\n  })\n  return this.buildFrom(found)\n}\nexports.lookUp = exports.lookup\n","const tokenize = require('../../../01-tokenizer')\n\nconst titleCase = str => {\n  return str.charAt(0).toUpperCase() + str.substr(1)\n}\n\n/** substitute-in new content */\nexports.replaceWith = function(replace, options = {}) {\n  if (!replace) {\n    return this.delete()\n  }\n  //support old-style params\n  if (options === true) {\n    options = { keepTags: true }\n  }\n  if (options === false) {\n    options = { keepTags: false }\n  }\n  options = options || {}\n\n  // clear the cache\n  this.uncache()\n  // return this\n  this.list.forEach(p => {\n    let input = replace\n    // accept a function for replace\n    if (typeof replace === 'function') {\n      input = replace(p)\n    }\n    let newPhrases\n    // accept a Doc object to replace\n    if (input && typeof input === 'object' && input.isA === 'Doc') {\n      newPhrases = input.list\n      this.pool().merge(input.pool())\n    } else if (typeof input === 'string') {\n      //input is a string\n      if (options.keepCase !== false && p.terms(0).isTitleCase()) {\n        input = titleCase(input)\n      }\n      newPhrases = tokenize(input, this.world, this.pool())\n      //tag the new phrases\n      let tmpDoc = this.buildFrom(newPhrases)\n      tmpDoc.tagger()\n    } else {\n      return //don't even bother\n    }\n\n    // try to keep its old tags, if appropriate\n    if (options.keepTags === true) {\n      let oldTags = p.json({ terms: { tags: true } }).terms\n      newPhrases[0].terms().forEach((t, i) => {\n        if (oldTags[i]) {\n          t.tagSafe(oldTags[i].tags, 'keptTag', this.world)\n        }\n      })\n    }\n    p.replace(newPhrases[0], this) //Oneday: support multi-sentence replacements\n  })\n  return this\n}\n\n/** search and replace match with new content */\nexports.replace = function(match, replace, options) {\n  // if there's no 2nd param, use replaceWith\n  if (replace === undefined) {\n    return this.replaceWith(match, options)\n  }\n  this.match(match).replaceWith(replace, options)\n  return this\n}\n","const tokenize = require('../../../01-tokenizer')\n\n/** add these new terms to the end*/\nexports.append = function(str) {\n  if (!str) {\n    return this\n  }\n  // clear the cache\n  this.uncache()\n  //add it to end of every phrase\n  this.list.forEach(p => {\n    //build it\n    let phrase = tokenize(str, this.world, this.pool())[0] //assume it's one sentence, for now\n    //tag it\n    let tmpDoc = this.buildFrom([phrase])\n    tmpDoc.tagger()\n    // push it onto the end\n    p.append(phrase, this)\n  })\n  return this\n}\nexports.insertAfter = exports.append\nexports.insertAt = exports.append\n\n/** add these new terms to the front*/\nexports.prepend = function(str) {\n  if (!str) {\n    return this\n  }\n  // clear the cache\n  this.uncache()\n  //add it to start of every phrase\n  this.list.forEach(p => {\n    //build it\n    let phrase = tokenize(str, this.world, this.pool())[0] //assume it's one sentence, for now\n    //tag it\n    let tmpDoc = this.buildFrom([phrase])\n    tmpDoc.tagger()\n    // add it to the start\n    p.prepend(phrase, this)\n  })\n  return this\n}\nexports.insertBefore = exports.prepend\n\n/** add these new things to the end*/\nexports.concat = function() {\n  // clear the cache\n  this.uncache()\n  let list = this.list.slice(0)\n  //repeat for any number of params\n  for (let i = 0; i < arguments.length; i++) {\n    let arg = arguments[i]\n    //support a fresh string\n    if (typeof arg === 'string') {\n      let arr = tokenize(arg, this.world)\n      //TODO: phrase.tagger()?\n      list = list.concat(arr)\n    } else if (arg.isA === 'Doc') {\n      list = list.concat(arg.list)\n    } else if (arg.isA === 'Phrase') {\n      list.push(arg)\n    }\n  }\n  return this.buildFrom(list)\n}\n\n/** fully remove these terms from the document */\nexports.delete = function(match) {\n  // clear the cache\n  this.uncache()\n  let toRemove = this\n  if (match) {\n    toRemove = this.match(match)\n  }\n  toRemove.list.forEach(phrase => phrase.delete(this))\n  return this\n}\n// aliases\nexports.remove = exports.delete\n","const shouldTrim = {\n  clean: true,\n  reduced: true,\n  root: true,\n}\n\n/** return the document as text */\nexports.text = function(options) {\n  options = options || {}\n  //are we showing every phrase?\n  let showFull = false\n  if (this.parents().length === 0) {\n    showFull = true\n  }\n  // cache roots, if necessary\n  if (options === 'root' || (typeof options === 'object' && options.root)) {\n    this.list.forEach(p => {\n      p.terms().forEach(t => {\n        if (t.root === null) {\n          t.setRoot(this.world)\n        }\n      })\n    })\n  }\n\n  let txt = this.list.reduce((str, p, i) => {\n    const trimPre = !showFull && i === 0\n    const trimPost = !showFull && i === this.list.length - 1\n    return str + p.text(options, trimPre, trimPost)\n  }, '')\n\n  // clumsy final trim of leading/trailing whitespace\n  if (shouldTrim[options] === true || options.reduced === true || options.clean === true || options.root === true) {\n    txt = txt.trim()\n  }\n  return txt\n}\n","// get all character startings in doc\nconst termOffsets = function(doc) {\n  let elapsed = 0\n  let index = 0\n  let offsets = {}\n  doc.termList().forEach(term => {\n    offsets[term.id] = {\n      index: index,\n      start: elapsed + term.pre.length,\n      length: term.text.length,\n    }\n    elapsed += term.pre.length + term.text.length + term.post.length\n    index += 1\n  })\n  return offsets\n}\n\nconst calcOffset = function(doc, result, options) {\n  // calculate offsets for each term\n  let offsets = termOffsets(doc.all())\n  // add index values\n  if (options.terms.index || options.index) {\n    result.forEach(o => {\n      o.terms.forEach(t => {\n        t.index = offsets[t.id].index\n      })\n      o.index = o.terms[0].index\n    })\n  }\n  // add offset values\n  if (options.terms.offset || options.offset) {\n    result.forEach(o => {\n      o.terms.forEach(t => {\n        t.offset = offsets[t.id] || {}\n      })\n      // let len = o.terms.reduce((n, t, i) => {\n      //   n += t.offset.length || 0\n      //   //add whitespace, too\n      //   console.log(t.post)\n      //   return n\n      // }, 0)\n      o.offset = o.terms[0].offset\n      o.offset.length = o.text.length\n    })\n  }\n}\nmodule.exports = calcOffset\n","const offsets = require('./_offset')\nconst jsonDefaults = { text: true, terms: true, trim: true }\n\n//some options have dependents\nconst setOptions = function(options) {\n  options = Object.assign({}, jsonDefaults, options)\n\n  if (options.unique) {\n    options.reduced = true\n  }\n  //offset calculation requires these options to be on\n  if (options.offset) {\n    options.text = true\n    if (!options.terms || options.terms === true) {\n      options.terms = {}\n    }\n    options.terms.offset = true\n  }\n  if (options.index || options.terms.index) {\n    options.terms = options.terms === true ? {} : options.terms\n    options.terms.id = true\n  }\n  return options\n}\n\n/** pull out desired metadata from the document */\nexports.json = function(options = {}) {\n  //support json(3) format\n  if (typeof options === 'number' && this.list[options]) {\n    return this.list[options].json(jsonDefaults)\n  }\n\n  options = setOptions(options)\n\n  // cache root strings beforehand, if necessary\n  if (options.root === true) {\n    this.list.forEach(p => {\n      p.terms().forEach(t => {\n        if (t.root === null) {\n          t.setRoot(this.world)\n        }\n      })\n    })\n  }\n\n  let result = this.list.map(p => {\n    return p.json(options, this.world)\n  })\n  // add offset and index data for each term\n  if (options.terms.offset || options.offset || options.terms.index || options.index) {\n    offsets(this, result, options)\n  }\n  // add frequency #s\n  if (options.frequency || options.freq || options.count) {\n    let obj = {}\n    this.list.forEach(p => {\n      let str = p.text('reduced')\n      obj[str] = obj[str] || 0\n      obj[str] += 1\n    })\n    this.list.forEach((p, i) => {\n      result[i].count = obj[p.text('reduced')]\n    })\n  }\n  // remove duplicates\n  if (options.unique) {\n    let already = {}\n    result = result.filter(o => {\n      if (already[o.reduced] === true) {\n        return false\n      }\n      already[o.reduced] = true\n      return true\n    })\n  }\n  return result\n}\n\n//aliases\nexports.data = exports.json\n","const tagset = require('../../../World/tags')\n\n// https://stackoverflow.com/questions/9781218/how-to-change-node-jss-console-font-color\nconst reset = '\\x1b[0m'\n\nconst padEnd = function(str, width) {\n  str = str.toString()\n  while (str.length < width) {\n    str += ' '\n  }\n  return str\n}\n\nfunction isClientSide() {\n  return typeof window !== 'undefined' && window.document\n}\n\n// some nice colors for client-side debug\nconst css = {\n  green: '#7f9c6c',\n  red: '#914045',\n  blue: '#6699cc',\n  magenta: '#6D5685',\n  cyan: '#2D85A8',\n  yellow: '#e6d7b3',\n  black: '#303b50',\n}\n\nconst logClientSide = function(doc) {\n  doc.list.forEach(p => {\n    console.log('\\n%c\"' + p.text() + '\"', 'color: #e6d7b3;')\n    let terms = p.cache.terms || p.terms()\n    terms.forEach(t => {\n      let tags = Object.keys(t.tags)\n      let text = t.text || '-'\n      if (t.implicit) {\n        text = '[' + t.implicit + ']'\n      }\n      let word = \"'\" + text + \"'\"\n      word = padEnd(word, 8)\n      let found = tags.find(tag => tagset[tag] && tagset[tag].color)\n      let color = 'steelblue'\n      if (tagset[found]) {\n        color = tagset[found].color\n        color = css[color]\n      }\n      console.log(`   ${word}  -  %c${tags.join(', ')}`, `color: ${color || 'steelblue'};`)\n    })\n  })\n}\n\n//cheaper than requiring chalk\nconst cli = {\n  green: function(str) {\n    return '\\x1b[32m' + str + reset\n  },\n  red: function(str) {\n    return '\\x1b[31m' + str + reset\n  },\n  blue: function(str) {\n    return '\\x1b[34m' + str + reset\n  },\n  magenta: function(str) {\n    return '\\x1b[35m' + str + reset\n  },\n  cyan: function(str) {\n    return '\\x1b[36m' + str + reset\n  },\n  yellow: function(str) {\n    return '\\x1b[33m' + str + reset\n  },\n  black: function(str) {\n    return '\\x1b[30m' + str + reset\n  },\n}\n\nconst tagString = function(tags) {\n  tags = tags.map(tag => {\n    if (!tagset.hasOwnProperty(tag)) {\n      return tag\n    }\n    const c = tagset[tag].color || 'blue'\n    return cli[c](tag)\n  })\n  return tags.join(', ')\n}\n\n//output some helpful stuff to the console\nconst debug = function(doc) {\n  if (isClientSide()) {\n    logClientSide(doc)\n    return doc\n  }\n  console.log(cli.blue('====='))\n  doc.list.forEach(p => {\n    console.log(cli.blue('  -----'))\n    let terms = p.cache.terms || p.terms()\n    terms.forEach(t => {\n      let tags = Object.keys(t.tags)\n      let text = t.text || '-'\n      if (t.implicit) {\n        text = '[' + t.implicit + ']'\n      }\n      if (typeof module !== undefined) {\n        text = cli.yellow(text)\n      }\n      let word = \"'\" + text + \"'\"\n      word = padEnd(word, 18)\n      let str = cli.blue('  ｜ ') + word + '  - ' + tagString(tags)\n      console.log(str)\n    })\n  })\n  console.log('')\n  return doc\n}\nmodule.exports = debug\n","const topk = function(doc) {\n  let list = doc.json({ text: false, terms: false, reduced: true })\n  // combine them\n  let obj = {}\n  list.forEach(o => {\n    if (!obj[o.reduced]) {\n      o.count = 0\n      obj[o.reduced] = o\n    }\n    obj[o.reduced].count += 1\n  })\n  let arr = Object.keys(obj).map(k => obj[k])\n  // sort them\n  arr.sort((a, b) => {\n    if (a.count > b.count) {\n      return -1\n    } else if (a.count < b.count) {\n      return 1\n    }\n    return 0\n  })\n  return arr\n}\nmodule.exports = topk\n","const debug = require('./_debug')\nconst topk = require('./_topk')\n\n/** pretty-print the current document and its tags */\nexports.debug = function() {\n  debug(this)\n  return this\n}\n\n/** some named output formats */\nexports.out = function(method) {\n  if (method === 'text') {\n    return this.text()\n  }\n  if (method === 'normal') {\n    return this.text('normal')\n  }\n  if (method === 'json') {\n    return this.json()\n  }\n  if (method === 'offset' || method === 'offsets') {\n    return this.json({ offset: true })\n  }\n  if (method === 'array') {\n    return this.json({ terms: false }).map(obj => obj.text)\n  }\n  if (method === 'freq' || method === 'frequency') {\n    return topk(this)\n  }\n  if (method === 'terms') {\n    let list = []\n    this.json({ text: false, terms: { text: true } }).forEach(obj => {\n      let terms = obj.terms.map(t => t.text)\n      terms = terms.filter(t => t)\n      list = list.concat(terms)\n    })\n    return list\n  }\n  if (method === 'tags') {\n    return this.list.map(p => {\n      return p.terms().reduce((h, t) => {\n        h[t.clean || t.implicit] = Object.keys(t.tags)\n        return h\n      }, {})\n    })\n  }\n  if (method === 'debug') {\n    debug(this)\n    return this\n  }\n  return this.text()\n}\n","const methods = {\n  /** alphabetical order */\n  alpha: (a, b) => {\n    let left = a.text('clean')\n    let right = b.text('clean')\n    if (left < right) {\n      return -1\n    }\n    if (left > right) {\n      return 1\n    }\n    return 0\n  },\n\n  /** count the # of characters of each match */\n  length: (a, b) => {\n    let left = a.text().trim().length\n    let right = b.text().trim().length\n    if (left < right) {\n      return 1\n    }\n    if (left > right) {\n      return -1\n    }\n    return 0\n  },\n\n  /** count the # of terms in each match */\n  wordCount: (a, b) => {\n    let left = a.wordCount()\n    let right = b.wordCount()\n    if (left < right) {\n      return 1\n    }\n    if (left > right) {\n      return -1\n    }\n    return 0\n  },\n}\n\n/** sort by # of duplicates in the document*/\nconst byFreq = function(doc) {\n  let counts = {}\n  const options = {\n    case: true,\n    punctuation: false,\n    whitespace: true,\n    unicode: true,\n  }\n  doc.list.forEach(p => {\n    let str = p.text(options)\n    counts[str] = counts[str] || 0\n    counts[str] += 1\n  })\n  // sort by freq\n  doc.list.sort((a, b) => {\n    let left = counts[a.text(options)]\n    let right = counts[b.text(options)]\n    if (left < right) {\n      return 1\n    }\n    if (left > right) {\n      return -1\n    }\n    return 0\n  })\n  return doc\n}\n\n// order results 'chronologically', or document-order\nconst sortSequential = function(doc) {\n  let order = {}\n  doc.json({ terms: { offset: true } }).forEach(o => {\n    order[o.terms[0].id] = o.terms[0].offset.start\n  })\n  doc.list = doc.list.sort((a, b) => {\n    if (order[a.start] > order[b.start]) {\n      return 1\n    } else if (order[a.start] < order[b.start]) {\n      return -1\n    }\n    return 0\n  })\n  return doc\n}\n\n//aliases\nmethods.alphabetical = methods.alpha\nmethods.wordcount = methods.wordCount\n\n// aliases for sequential ordering\nconst seqNames = {\n  index: true,\n  sequence: true,\n  seq: true,\n  sequential: true,\n  chron: true,\n  chronological: true,\n}\n\n/** re-arrange the order of the matches (in place) */\nexports.sort = function(input) {\n  input = input || 'alpha'\n  //do this one up-front\n  if (input === 'freq' || input === 'frequency' || input === 'topk') {\n    return byFreq(this)\n  }\n  if (seqNames.hasOwnProperty(input)) {\n    return sortSequential(this)\n  }\n\n  input = methods[input] || input\n  // apply sort method on each phrase\n  if (typeof input === 'function') {\n    this.list = this.list.sort(input)\n    return this\n  }\n  return this\n}\n\n/** reverse the order of the matches, but not the words */\nexports.reverse = function() {\n  let list = [].concat(this.list)\n  list = list.reverse()\n  return this.buildFrom(list)\n}\n\n/** remove any duplicate matches */\nexports.unique = function() {\n  let list = [].concat(this.list)\n  let obj = {}\n  list = list.filter(p => {\n    let str = p.text('reduced').trim()\n    if (obj.hasOwnProperty(str) === true) {\n      return false\n    }\n    obj[str] = true\n    return true\n  })\n  return this.buildFrom(list)\n}\n","const killUnicode = require('../../../Term/normalize/unicode')\nconst isPunct = /[\\[\\]{}⟨⟩:,،、‒–—―…‹›«»‐\\-;\\/⁄·*\\•^†‡°¡¿※№÷×ºª%‰=‱¶§~|‖¦©℗®℠™¤₳฿]/g\nconst quotes = /['‘’“”\"′″‴]+/g\n\nconst methods = {\n  // cleanup newlines and extra spaces\n  whitespace: function(doc) {\n    let termArr = doc.list.map(ts => ts.terms())\n    termArr.forEach((terms, o) => {\n      terms.forEach((t, i) => {\n        // keep dashes between words\n        if (t.hasDash() === true) {\n          t.post = ' - '\n          return\n        }\n        // remove existing spaces\n        t.pre = t.pre.replace(/\\s/g, '')\n        t.post = t.post.replace(/\\s/g, '')\n        //last word? ensure there's a next sentence.\n        if (terms.length - 1 === i && !termArr[o + 1]) {\n          return\n        }\n        // no extra spaces for contractions\n        if (t.implicit && Boolean(t.text) === true) {\n          return\n        }\n        // no extra spaces for hyphenated words\n        if (t.hasHyphen() === true) {\n          return\n        }\n\n        t.post += ' '\n      })\n    })\n  },\n\n  punctuation: function(termList) {\n    termList.forEach(t => {\n      // space between hyphenated words\n      if (t.hasHyphen() === true) {\n        t.post = ' '\n      }\n      t.pre = t.pre.replace(isPunct, '')\n      t.post = t.post.replace(isPunct, '')\n      // elipses\n      t.post = t.post.replace(/\\.\\.\\./, '')\n      // only allow one exclamation\n      if (/!/.test(t.post) === true) {\n        t.post = t.post.replace(/!/g, '')\n        t.post = '!' + t.post\n      }\n      // only allow one question mark\n      if (/\\?/.test(t.post) === true) {\n        t.post = t.post.replace(/[\\?!]*/, '')\n        t.post = '?' + t.post\n      }\n    })\n  },\n\n  unicode: function(termList) {\n    termList.forEach(t => {\n      if (t.isImplicit() === true) {\n        return\n      }\n      t.text = killUnicode(t.text)\n    })\n  },\n\n  quotations: function(termList) {\n    termList.forEach(t => {\n      t.post = t.post.replace(quotes, '')\n      t.pre = t.pre.replace(quotes, '')\n    })\n  },\n\n  adverbs: function(doc) {\n    doc\n      .match('#Adverb')\n      .not('(not|nary|seldom|never|barely|almost|basically|so)')\n      .remove()\n  },\n\n  // remove the '.' from 'Mrs.' (safely)\n  abbreviations: function(doc) {\n    doc.list.forEach(ts => {\n      let terms = ts.terms()\n      terms.forEach((t, i) => {\n        if (t.tags.Abbreviation === true && terms[i + 1]) {\n          t.post = t.post.replace(/^\\./, '')\n        }\n      })\n    })\n  },\n}\nmodule.exports = methods\n","const methods = require('./_methods')\n\nconst defaults = {\n  // light\n  whitespace: true,\n  unicode: true,\n  punctuation: true,\n  emoji: true,\n  acronyms: true,\n  abbreviations: true,\n\n  // medium\n  case: false,\n  contractions: false,\n  parentheses: false,\n  quotations: false,\n  adverbs: false,\n\n  // heavy (loose legibility)\n  possessives: false,\n  verbs: false,\n  nouns: false,\n  honorifics: false,\n\n  // pronouns: true,\n}\nconst mapping = {\n  light: {},\n  medium: { case: true, contractions: true, parentheses: true, quotations: true, adverbs: true },\n}\nmapping.heavy = Object.assign({}, mapping.medium, { possessives: true, verbs: true, nouns: true, honorifics: true })\n\n/** common ways to clean-up the document, and reduce noise */\nexports.normalize = function(options) {\n  options = options || {}\n  // support named forms\n  if (typeof options === 'string') {\n    options = mapping[options] || {}\n  }\n  // set defaults\n  options = Object.assign({}, defaults, options)\n  // clear the cache\n  this.uncache()\n\n  let termList = this.termList()\n\n  // lowercase things\n  if (options.case) {\n    this.toLowerCase()\n  }\n\n  //whitespace\n  if (options.whitespace) {\n    methods.whitespace(this)\n  }\n\n  // unicode: é -> e\n  if (options.unicode) {\n    methods.unicode(termList)\n  }\n\n  //punctuation - keep sentence punctation, quotes, parenths\n  if (options.punctuation) {\n    methods.punctuation(termList)\n  }\n\n  // remove ':)'\n  if (options.emoji) {\n    this.remove('(#Emoji|#Emoticon)')\n  }\n\n  // 'f.b.i.' -> 'FBI'\n  if (options.acronyms) {\n    this.acronyms().strip()\n    // .toUpperCase()\n  }\n  // remove period from abbreviations\n  if (options.abbreviations) {\n    methods.abbreviations(this)\n  }\n\n  // --Medium methods--\n\n  // `isn't` -> 'is not'\n  if (options.contraction || options.contractions) {\n    this.contractions().expand()\n  }\n\n  // '(word)' -> 'word'\n  if (options.parentheses) {\n    this.parentheses().unwrap()\n  }\n  // remove \"\" punctuation\n  if (options.quotations || options.quotes) {\n    methods.quotations(termList)\n  }\n\n  // remove any un-necessary adverbs\n  if (options.adverbs) {\n    methods.adverbs(this)\n  }\n\n  // --Heavy methods--\n\n  // `cory hart's -> cory hart'\n  if (options.possessive || options.possessives) {\n    this.possessives().strip()\n  }\n  // 'he walked' -> 'he walk'\n  if (options.verbs) {\n    this.verbs().toInfinitive()\n  }\n  // 'three dogs' -> 'three dog'\n  if (options.nouns || options.plurals) {\n    this.nouns().toSingular()\n  }\n  // remove 'Mr.' from 'Mr John Smith'\n  if (options.honorifics) {\n    this.remove('#Honorific')\n  }\n\n  return this\n}\n","const parseSyntax = require('../../match/syntax')\n\n/** return a Document with three parts for every match\n * seperate everything before the word, as a new phrase\n */\nexports.splitOn = function(reg) {\n  // if there's no match, split parent, instead\n  if (!reg) {\n    let parent = this.parent()\n    return parent.splitOn(this)\n  }\n  //start looking for a match..\n  let regs = parseSyntax(reg)\n  let matches = []\n  this.list.forEach(p => {\n    let foundEm = p.match(regs)\n    //no match here, add full sentence\n    if (foundEm.length === 0) {\n      matches.push(p)\n      return\n    }\n    // we found something here.\n    let carry = p\n    foundEm.forEach(found => {\n      let parts = carry.splitOn(found)\n      // add em in\n      if (parts.before) {\n        matches.push(parts.before)\n      }\n      if (parts.match) {\n        matches.push(parts.match)\n      }\n      // start matching now on the end\n      carry = parts.after\n    })\n    // add that last part\n    if (carry) {\n      matches.push(carry)\n    }\n  })\n  return this.buildFrom(matches)\n}\n\n/** return a Document with two parts for every match\n * seperate everything after the word, as a new phrase\n */\nexports.splitAfter = function(reg) {\n  // if there's no match, split parent, instead\n  if (!reg) {\n    let parent = this.parent()\n    return parent.splitAfter(this)\n  }\n  // start looking for our matches\n  let regs = parseSyntax(reg)\n  let matches = []\n  this.list.forEach(p => {\n    let foundEm = p.match(regs)\n    //no match here, add full sentence\n    if (foundEm.length === 0) {\n      matches.push(p)\n      return\n    }\n    // we found something here.\n    let carry = p\n    foundEm.forEach(found => {\n      let parts = carry.splitOn(found)\n      // add em in\n      if (parts.before && parts.match) {\n        // merge these two together\n        parts.before.length += parts.match.length\n        matches.push(parts.before)\n      } else if (parts.match) {\n        matches.push(parts.match)\n      }\n      // start matching now on the end\n      carry = parts.after\n    })\n    // add that last part\n    if (carry) {\n      matches.push(carry)\n    }\n  })\n  return this.buildFrom(matches)\n}\nexports.split = exports.splitAfter //i guess?\n\n/** return a Document with two parts for every match */\nexports.splitBefore = function(reg) {\n  // if there's no match, split parent, instead\n  if (!reg) {\n    let parent = this.parent()\n    return parent.splitBefore(this)\n  }\n  //start looking for a match..\n  let regs = parseSyntax(reg)\n  let matches = []\n  this.list.forEach(p => {\n    let foundEm = p.match(regs)\n    //no match here, add full sentence\n    if (foundEm.length === 0) {\n      matches.push(p)\n      return\n    }\n    // we found something here.\n    let carry = p\n    foundEm.forEach(found => {\n      let parts = carry.splitOn(found)\n      // add before part in\n      if (parts.before) {\n        matches.push(parts.before)\n      }\n      // merge match+after\n      if (parts.match && parts.after) {\n        parts.match.length += parts.after.length\n      }\n      // start matching now on the end\n      carry = parts.match\n    })\n    // add that last part\n    if (carry) {\n      matches.push(carry)\n    }\n  })\n  return this.buildFrom(matches)\n}\n\n/** split a document into labeled sections */\nexports.segment = function(regs, options) {\n  regs = regs || {}\n  options = options || { text: true }\n  let doc = this\n  let keys = Object.keys(regs)\n  // split em\n  keys.forEach(k => {\n    doc = doc.splitOn(k)\n  })\n  //add labels for each section\n  doc.list.forEach(p => {\n    for (let i = 0; i < keys.length; i += 1) {\n      if (p.has(keys[i])) {\n        p.segment = regs[keys[i]]\n        return\n      }\n    }\n  })\n  return doc.list.map(p => {\n    let res = p.json(options)\n    res.segment = p.segment || null\n    return res\n  })\n}\n","const eachTerm = function(doc, fn) {\n  let world = doc.world\n  doc.list.forEach(p => {\n    p.terms().forEach(t => t[fn](world))\n  })\n  return doc\n}\n\n/** turn every letter of every term to lower-cse */\nexports.toLowerCase = function() {\n  return eachTerm(this, 'toLowerCase')\n}\n\n/** turn every letter of every term to upper case */\nexports.toUpperCase = function() {\n  return eachTerm(this, 'toUpperCase')\n}\n\n/** upper-case the first letter of each term */\nexports.toTitleCase = function() {\n  return eachTerm(this, 'toTitleCase')\n}\n/** remove whitespace and title-case each term */\nexports.toCamelCase = function() {\n  this.list.forEach(p => {\n    //remove whitespace\n    let terms = p.terms()\n    terms.forEach((t, i) => {\n      if (i !== 0) {\n        t.toTitleCase()\n      }\n      if (i !== terms.length - 1) {\n        t.post = ''\n      }\n    })\n  })\n  // this.tag('#CamelCase', 'toCamelCase')\n  return this\n}\n","/** add this punctuation or whitespace before each match: */\nexports.pre = function(str, concat) {\n  if (str === undefined) {\n    return this.list[0].terms(0).pre\n  }\n  this.list.forEach(p => {\n    let term = p.terms(0)\n    if (concat === true) {\n      term.pre += str\n    } else {\n      term.pre = str\n    }\n  })\n  return this\n}\n\n/** add this punctuation or whitespace after each match: */\nexports.post = function(str, concat) {\n  // return array of post strings\n  if (str === undefined) {\n    return this.list.map(p => {\n      let terms = p.terms()\n      let term = terms[terms.length - 1]\n      return term.post\n    })\n  }\n  // set post string on all ends\n  this.list.forEach(p => {\n    let terms = p.terms()\n    let term = terms[terms.length - 1]\n    if (concat === true) {\n      term.post += str\n    } else {\n      term.post = str\n    }\n  })\n  return this\n}\n\n/** remove start and end whitespace */\nexports.trim = function() {\n  this.list = this.list.map(p => p.trim())\n  return this\n}\n\n/** connect words with hyphen, and remove whitespace */\nexports.hyphenate = function() {\n  this.list.forEach(p => {\n    let terms = p.terms()\n    //remove whitespace\n    terms.forEach((t, i) => {\n      if (i !== 0) {\n        t.pre = ''\n      }\n      if (terms[i + 1]) {\n        t.post = '-'\n      }\n    })\n  })\n  return this\n}\n\n/** remove hyphens between words, and set whitespace */\nexports.dehyphenate = function() {\n  const hasHyphen = /(-|–|—)/\n  this.list.forEach(p => {\n    let terms = p.terms()\n    //remove whitespace\n    terms.forEach(t => {\n      if (hasHyphen.test(t.post)) {\n        t.post = ' '\n      }\n    })\n  })\n  return this\n}\nexports.deHyphenate = exports.dehyphenate\n\n/** add quotations around these matches */\nexports.toQuotations = function(start, end) {\n  start = start || `\"`\n  end = end || `\"`\n  this.list.forEach(p => {\n    let terms = p.terms()\n    terms[0].pre = start + terms[0].pre\n    let last = terms[terms.length - 1]\n    last.post = end + last.post\n  })\n  return this\n}\nexports.toQuotation = exports.toQuotations\n\n/** add brackets around these matches */\nexports.toParentheses = function(start, end) {\n  start = start || `(`\n  end = end || `)`\n  this.list.forEach(p => {\n    let terms = p.terms()\n    terms[0].pre = start + terms[0].pre\n    let last = terms[terms.length - 1]\n    last.post = end + last.post\n  })\n  return this\n}\n","/** make all phrases into one phrase */\nexports.join = function(str) {\n  // clear the cache\n  this.uncache()\n  // make one large phrase - 'main'\n  let main = this.list[0]\n  let before = main.length\n  let removed = {}\n  for (let i = 1; i < this.list.length; i++) {\n    const p = this.list[i]\n    removed[p.start] = true\n    let term = main.lastTerm()\n    // add whitespace between them\n    if (str) {\n      term.post += str\n    }\n    //  main -> p\n    term.next = p.start\n    // main <- p\n    p.terms(0).prev = term.id\n    main.length += p.length\n  }\n\n  // parents are bigger than than their children.\n  // when we increase a child, we increase their parent too.\n  let increase = main.length - before\n  this.parents().forEach(doc => {\n    // increase length on each effected phrase\n    doc.list.forEach(p => {\n      let terms = p.terms()\n      for (let i = 0; i < terms.length; i++) {\n        if (terms[i].id === main.start) {\n          p.length += increase\n          break\n        }\n      }\n    })\n    // remove redundant phrases now\n    doc.list = doc.list.filter(p => removed[p.start] !== true)\n  })\n  // return one major phrase\n  return this.buildFrom([main])\n}\n","const postPunct = /[,\\)\"';:\\-–—\\.…]/\n// const irregulars = {\n//   'will not': `won't`,\n//   'i am': `i'm`,\n// }\n\nconst setContraction = function(m, suffix) {\n  if (!m.found) {\n    return\n  }\n  let terms = m.termList()\n  //avoid any problematic punctuation\n  for (let i = 0; i < terms.length - 1; i++) {\n    const t = terms[i]\n    if (postPunct.test(t.post)) {\n      return\n    }\n  }\n\n  // set them as implict\n  terms.forEach(t => {\n    t.implicit = t.clean\n  })\n  // perform the contraction\n  terms[0].text += suffix\n  // clean-up the others\n  terms.slice(1).forEach(t => {\n    t.text = ''\n  })\n  for (let i = 0; i < terms.length - 1; i++) {\n    const t = terms[i]\n    t.post = t.post.replace(/ /, '')\n  }\n}\n\n/** turn 'i am' into i'm */\nexports.contract = function() {\n  let doc = this.not('@hasContraction')\n  // we are -> we're\n  let m = doc.match('(we|they|you) are')\n  setContraction(m, `'re`)\n  // they will -> they'll\n  m = doc.match('(he|she|they|it|we|you) will')\n  setContraction(m, `'ll`)\n  // she is -> she's\n  m = doc.match('(he|she|they|it|we) is')\n  setContraction(m, `'s`)\n  // spencer is -> spencer's\n  m = doc.match('#Person is')\n  setContraction(m, `'s`)\n  // spencer would -> spencer'd\n  m = doc.match('#Person would')\n  setContraction(m, `'d`)\n  // would not -> wouldn't\n  m = doc.match('(is|was|had|would|should|could|do|does|have|has|can) not')\n  setContraction(m, `n't`)\n  // i have -> i've\n  m = doc.match('(i|we|they) have')\n  setContraction(m, `'ve`)\n  // would have -> would've\n  m = doc.match('(would|should|could) have')\n  setContraction(m, `'ve`)\n  // i am -> i'm\n  m = doc.match('i am')\n  setContraction(m, `'m`)\n  // going to -> gonna\n  m = doc.match('going to')\n  return this\n}\n","module.exports = Object.assign(\n  {},\n  require('./01-utils'),\n  require('./02-accessors'),\n  require('./03-match'),\n  require('./04-tag'),\n  require('./05-loops'),\n  require('./06-lookup'),\n\n  require('./insert/01-replace'),\n  require('./insert/02-insert'),\n\n  require('./output/01-text'),\n  require('./output/02-json'),\n  require('./output/03-out'),\n\n  require('./transform/01-sort'),\n  require('./transform/02-normalize'),\n  require('./transform/03-split'),\n  require('./transform/04-case'),\n  require('./transform/05-whitespace'),\n  require('./transform/06-join'),\n  require('./transform/07-contract')\n)\n","let methods = {}\n\n// allow helper methods like .adjectives() and .adverbs()\nconst arr = [\n  ['terms', '.'],\n  ['hyphenated', '@hasHyphen .'],\n  ['adjectives', '#Adjective'],\n  ['hashTags', '#HashTag'],\n  ['emails', '#Email'],\n  ['emoji', '#Emoji'],\n  ['emoticons', '#Emoticon'],\n  ['atMentions', '#AtMention'],\n  ['urls', '#Url'],\n  ['adverbs', '#Adverb'],\n  ['pronouns', '#Pronoun'],\n  ['conjunctions', '#Conjunction'],\n  ['prepositions', '#Preposition'],\n]\narr.forEach(a => {\n  methods[a[0]] = function(n) {\n    let m = this.match(a[1])\n    if (typeof n === 'number') {\n      m = m.get(n)\n    }\n    return m\n  }\n})\n// aliases\nmethods.emojis = methods.emoji\nmethods.atmentions = methods.atMentions\nmethods.words = methods.terms\n\n/** return anything tagged as a phone number */\nmethods.phoneNumbers = function(n) {\n  let m = this.splitAfter('@hasComma')\n  m = m.match('#PhoneNumber+')\n  if (typeof n === 'number') {\n    m = m.get(n)\n  }\n  return m\n}\n\n/** money + currency pair */\nmethods.money = function(n) {\n  let m = this.match('#Money #Currency?')\n  if (typeof n === 'number') {\n    m = m.get(n)\n  }\n  return m\n}\n\n/** return all cities, countries, addresses, and regions */\nmethods.places = function(n) {\n  // don't split 'paris, france'\n  let keep = this.match('(#City && @hasComma) (#Region|#Country)')\n  // but split the other commas\n  let m = this.not(keep).splitAfter('@hasComma')\n  // combine them back together\n  m = m.concat(keep)\n  m.sort('index')\n  m = m.match('#Place+')\n  if (typeof n === 'number') {\n    m = m.get(n)\n  }\n  return m\n}\n\n/** return all schools, businesses and institutions */\nmethods.organizations = function(n) {\n  let m = this.clauses()\n  m = m.match('#Organization+')\n  if (typeof n === 'number') {\n    m = m.get(n)\n  }\n  return m\n}\n\n//combine them with .topics() method\nmethods.entities = function(n) {\n  let r = this.clauses()\n  // Find people, places, and organizations\n  let yup = r.people()\n  yup = yup.concat(r.places())\n  yup = yup.concat(r.organizations())\n  let ignore = ['someone', 'man', 'woman', 'mother', 'brother', 'sister', 'father']\n  yup = yup.not(ignore)\n  //return them to normal ordering\n  yup.sort('sequence')\n  // yup.unique() //? not sure\n  if (typeof n === 'number') {\n    yup = yup.get(n)\n  }\n  return yup\n}\n//aliases\nmethods.things = methods.entities\nmethods.topics = methods.entities\n\n/** alias for .all() until it gets overloaded by plugin */\nmethods.sentences = function() {\n  return this.all()\n}\n\nmodule.exports = methods\n","const addMethod = function(Doc) {\n  /**  */\n  class Abbreviations extends Doc {\n    stripPeriods() {\n      this.termList().forEach(t => {\n        if (t.tags.Abbreviation === true && t.next) {\n          t.post = t.post.replace(/^\\./, '')\n        }\n        let str = t.text.replace(/\\./, '')\n        t.set(str)\n      })\n      return this\n    }\n    addPeriods() {\n      this.termList().forEach(t => {\n        t.post = t.post.replace(/^\\./, '')\n        t.post = '.' + t.post\n      })\n      return this\n    }\n  }\n  Abbreviations.prototype.unwrap = Abbreviations.prototype.stripPeriods\n\n  Doc.prototype.abbreviations = function(n) {\n    let match = this.match('#Abbreviation')\n    if (typeof n === 'number') {\n      match = match.get(n)\n    }\n    return new Abbreviations(match.list, this, this.world)\n  }\n  return Doc\n}\nmodule.exports = addMethod\n","const hasPeriod = /\\./\n\nconst addMethod = function(Doc) {\n  /**  */\n  class Acronyms extends Doc {\n    stripPeriods() {\n      this.termList().forEach(t => {\n        let str = t.text.replace(/\\./g, '')\n        t.set(str)\n      })\n      return this\n    }\n    addPeriods() {\n      this.termList().forEach(t => {\n        let str = t.text.replace(/\\./g, '')\n        str = str.split('').join('.')\n        // don't add a end-period if there's a sentence-end one\n        if (hasPeriod.test(t.post) === false) {\n          str += '.'\n        }\n        t.set(str)\n      })\n      return this\n    }\n  }\n  Acronyms.prototype.unwrap = Acronyms.prototype.stripPeriods\n  Acronyms.prototype.strip = Acronyms.prototype.stripPeriods\n\n  Doc.prototype.acronyms = function(n) {\n    let match = this.match('#Acronym')\n    if (typeof n === 'number') {\n      match = match.get(n)\n    }\n    return new Acronyms(match.list, this, this.world)\n  }\n  return Doc\n}\nmodule.exports = addMethod\n","const addMethod = function(Doc) {\n  /** split into approximate sub-sentence phrases */\n  Doc.prototype.clauses = function(n) {\n    // an awkward way to disambiguate a comma use\n    let commas = this.if('@hasComma')\n      .notIf('@hasComma @hasComma') //fun, cool...\n      .notIf('@hasComma . .? (and|or) .') //cool, and fun\n      .notIf('(#City && @hasComma) #Country') //'toronto, canada'\n      .notIf('(#Date && @hasComma) #Year') //'july 6, 1992'\n      .notIf('@hasComma (too|also)$') //at end of sentence\n      .match('@hasComma')\n    let found = this.splitAfter(commas)\n\n    let quotes = found.quotations()\n    found = found.splitOn(quotes)\n\n    let parentheses = found.parentheses()\n    found = found.splitOn(parentheses)\n\n    // it is cool and it is ..\n    let conjunctions = found.if('#Copula #Adjective #Conjunction (#Pronoun|#Determiner) #Verb').match('#Conjunction')\n    found = found.splitBefore(conjunctions)\n\n    // if it is this then that\n    let condition = found.if('if .{2,9} then .').match('then')\n    found = found.splitBefore(condition)\n\n    // misc clause partitions\n    found = found.splitBefore('as well as .')\n    found = found.splitBefore('such as .')\n    found = found.splitBefore('in addition to .')\n\n    // semicolons, dashes\n    found = found.splitAfter('@hasSemicolon')\n    found = found.splitAfter('@hasDash')\n\n    // passive voice verb - '.. which was robbed is empty'\n    // let passive = found.match('#Noun (which|that) (was|is) #Adverb? #PastTense #Adverb?')\n    // if (passive.found) {\n    //   found = found.splitAfter(passive)\n    // }\n    // //which the boy robbed\n    // passive = found.match('#Noun (which|that) the? #Noun+ #Adverb? #PastTense #Adverb?')\n    // if (passive.found) {\n    //   found = found.splitAfter(passive)\n    // }\n\n    // does there appear to have relative/subordinate clause still?\n    let tooLong = found.filter(d => d.wordCount() > 5 && d.match('#Verb+').length >= 2)\n    if (tooLong.found) {\n      let m = tooLong.splitAfter('#Noun .* #Verb .* #Noun+')\n      found = found.splitOn(m.eq(0))\n    }\n\n    if (typeof n === 'number') {\n      found = found.get(n)\n    }\n    return new Doc(found.list, this, this.world)\n  }\n  return Doc\n}\nmodule.exports = addMethod\n","const addMethod = function(Doc) {\n  /**  */\n  class Contractions extends Doc {\n    constructor(list, from, world) {\n      super(list, from, world)\n      this.contracted = null\n    }\n    /** turn didn't into 'did not' */\n    expand() {\n      this.list.forEach(p => {\n        let terms = p.terms()\n        //change the case?\n        let isTitlecase = terms[0].isTitleCase()\n\n        terms.forEach((t, i) => {\n          //use the implicit text\n          t.set(t.implicit || t.text)\n          t.implicit = undefined\n\n          //add whitespace\n          if (i < terms.length - 1 && t.post === '') {\n            t.post += ' '\n          }\n        })\n        //set titlecase\n        if (isTitlecase) {\n          terms[0].toTitleCase()\n        }\n      })\n      return this\n    }\n  }\n\n  //find contractable, expanded-contractions\n  // const findExpanded = r => {\n  //   let remain = r.not('#Contraction')\n  //   let m = remain.match('(#Noun|#QuestionWord) (#Copula|did|do|have|had|could|would|will)')\n  //   m.concat(remain.match('(they|we|you|i) have'))\n  //   m.concat(remain.match('i am'))\n  //   m.concat(remain.match('(#Copula|#Modal|do|does|have|has|can|will) not'))\n  //   return m\n  // }\n\n  Doc.prototype.contractions = function(n) {\n    //find currently-contracted\n    let found = this.match('@hasContraction+') //(may want to split these up)\n    //todo: split consecutive contractions\n    if (typeof n === 'number') {\n      found = found.get(n)\n    }\n    return new Contractions(found.list, this, this.world)\n  }\n\n  //aliases\n  Doc.prototype.expanded = Doc.prototype.isExpanded\n  Doc.prototype.contracted = Doc.prototype.isContracted\n  return Doc\n}\nmodule.exports = addMethod\n","const addMethod = function(Doc) {\n  //pull it apart..\n  const parse = function(doc) {\n    let things = doc.splitAfter('@hasComma').not('(and|or) not?')\n    let beforeLast = doc.match('[.] (and|or)')\n    return {\n      things: things,\n      conjunction: doc.match('(and|or) not?'),\n      beforeLast: beforeLast,\n      hasOxford: beforeLast.has('@hasComma'),\n    }\n  }\n\n  /** cool, fun, and nice */\n  class Lists extends Doc {\n    /** coordinating conjunction */\n    conjunctions() {\n      return this.match('(and|or)')\n    }\n    /** split-up by list object */\n    parts() {\n      return this.splitAfter('(@hasComma|#Conjunction)')\n    }\n    /** remove the conjunction */\n    items() {\n      return this.parts().notIf('#Conjunction')\n    }\n    /** add a new unit to the list */\n    add(str) {\n      this.forEach(p => {\n        let beforeLast = parse(p).beforeLast\n        beforeLast.append(str)\n        //add a comma to it\n        beforeLast.termList(0).addPunctuation(',')\n      })\n      return this\n    }\n    /** remove any matching unit from the list */\n    remove() {\n      return this\n    }\n\n    /** return only lists that use a serial comma */\n    hasOxfordComma() {\n      return this.filter(doc => parse(doc).hasOxford)\n    }\n    addOxfordComma() {\n      return this\n    }\n    removeOxfordComma() {\n      return this\n    }\n  }\n  // aliases\n  Lists.prototype.things = Lists.prototype.items\n\n  Doc.prototype.lists = function(n) {\n    let m = this.if('@hasComma+ .? (and|or) not? .')\n\n    // person-list\n    let nounList = m.match('(#Noun|#Adjective)+ #Conjunction not? #Adjective? #Noun+')\n    let adjList = m.match('(#Adjective|#Adverb)+ #Conjunction not? #Adverb? #Adjective+')\n    let verbList = m.match('(#Verb|#Adverb)+ #Conjunction not? #Adverb? #Verb+')\n    let result = nounList.concat(adjList)\n    result = result.concat(verbList)\n    result = result.if('@hasComma')\n\n    if (typeof n === 'number') {\n      result = m.get(n)\n    }\n    return new Lists(result.list, this, this.world)\n  }\n  return Doc\n}\nmodule.exports = addMethod\n","const noPlural =\n  '(#Pronoun|#Place|#Value|#Person|#Uncountable|#Month|#WeekDay|#Holiday|#Possessive)'\n\n//certain words can't be plural, like 'peace'\nconst hasPlural = function(doc) {\n  if (doc.has('#Plural') === true) {\n    return true\n  }\n  // these can't be plural\n  if (doc.has(noPlural) === true) {\n    return false\n  }\n  return true\n}\n\nmodule.exports = hasPlural\n","'use strict'\n\n//chooses an indefinite aricle 'a/an' for a word\nconst irregulars = {\n  hour: 'an',\n  heir: 'an',\n  heirloom: 'an',\n  honest: 'an',\n  honour: 'an',\n  honor: 'an',\n  uber: 'an', //german u\n}\n//pronounced letters of acronyms that get a 'an'\nconst an_acronyms = {\n  a: true,\n  e: true,\n  f: true,\n  h: true,\n  i: true,\n  l: true,\n  m: true,\n  n: true,\n  o: true,\n  r: true,\n  s: true,\n  x: true,\n}\n//'a' regexes\nconst a_regexs = [\n  /^onc?e/i, //'wu' sound of 'o'\n  /^u[bcfhjkqrstn][aeiou]/i, // 'yu' sound for hard 'u'\n  /^eul/i,\n]\n\nconst makeArticle = function(doc) {\n  //no 'the john smith', but 'a london hotel'\n  if (doc.has('#Person') || doc.has('#Place')) {\n    return ''\n  }\n  //no a/an if it's plural\n  if (doc.has('#Plural')) {\n    return 'the'\n  }\n  let str = doc.text('normal').trim()\n  //explicit irregular forms\n  if (irregulars.hasOwnProperty(str)) {\n    return irregulars[str]\n  }\n  //spelled-out acronyms\n  let firstLetter = str.substr(0, 1)\n  if (doc.has('^@isAcronym') && an_acronyms.hasOwnProperty(firstLetter)) {\n    return 'an'\n  }\n  //'a' regexes\n  for (let i = 0; i < a_regexs.length; i++) {\n    if (a_regexs[i].test(str)) {\n      return 'a'\n    }\n  }\n  //basic vowel-startings\n  if (/^[aeiou]/i.test(str)) {\n    return 'an'\n  }\n  return 'a'\n}\n\nmodule.exports = makeArticle\n","//similar to plural/singularize rules, but not the same\nconst isPlural = [\n  /(antenn|formul|nebul|vertebr|vit)ae$/i,\n  /(octop|vir|radi|nucle|fung|cact|stimul)i$/i,\n  /men$/i,\n  /.tia$/i,\n  /(m|l)ice$/i,\n]\n\n//similar to plural/singularize rules, but not the same\nconst isSingular = [\n  /(ax|test)is$/i,\n  /(octop|vir|radi|nucle|fung|cact|stimul)us$/i,\n  /(octop|vir)i$/i,\n  /(rl)f$/i,\n  /(alias|status)$/i,\n  /(bu)s$/i,\n  /(al|ad|at|er|et|ed|ad)o$/i,\n  /(ti)um$/i,\n  /(ti)a$/i,\n  /sis$/i,\n  /(?:(^f)fe|(lr)f)$/i,\n  /hive$/i,\n  /(^aeiouy|qu)y$/i,\n  /(x|ch|ss|sh|z)$/i,\n  /(matr|vert|ind|cort)(ix|ex)$/i,\n  /(m|l)ouse$/i,\n  /(m|l)ice$/i,\n  /(antenn|formul|nebul|vertebr|vit)a$/i,\n  /.sis$/i,\n  /^(?!talis|.*hu)(.*)man$/i,\n]\nmodule.exports = {\n  isSingular: isSingular,\n  isPlural: isPlural,\n}\n","const rules = require('./_rules')\nconst endS = /s$/\n// double-check this term, if it is not plural, or singular.\n// (this is a partial copy of ./tagger/fallbacks/plural)\n// fallback plural if it ends in an 's'.\nconst isPlural = function(str) {\n  // isSingular suffix rules\n  if (rules.isSingular.find(reg => reg.test(str))) {\n    return false\n  }\n  // does it end in an s?\n  if (endS.test(str) === true) {\n    return true\n  }\n  // is it a plural like 'fungi'?\n  if (rules.isPlural.find(reg => reg.test(str))) {\n    return true\n  }\n  return null\n}\nmodule.exports = isPlural\n","const exceptions = {\n  he: 'his',\n  she: 'hers',\n  they: 'theirs',\n  we: 'ours',\n  i: 'mine',\n  you: 'yours',\n\n  her: 'hers',\n  their: 'theirs',\n  our: 'ours',\n  my: 'mine',\n  your: 'yours',\n}\n\n// turn \"David\" to \"David's\"\nconst toPossessive = function(doc) {\n  let str = doc.text('text').trim()\n  // exceptions\n  if (exceptions.hasOwnProperty(str)) {\n    doc.replaceWith(exceptions[str], true)\n    doc.tag('Possessive', 'toPossessive')\n    return\n  }\n  // flanders'\n  if (/s$/.test(str)) {\n    str += \"'\"\n    doc.replaceWith(str, true)\n    doc.tag('Possessive', 'toPossessive')\n    return\n  }\n  //normal form:\n  str += \"'s\"\n  doc.replaceWith(str, true)\n  doc.tag('Possessive', 'toPossessive')\n  return\n}\nmodule.exports = toPossessive\n","// .nouns() supports some noun-phrase-ish groupings\n// pull these apart, if necessary\nconst parse = function(doc) {\n  let res = {\n    main: doc,\n  }\n  //support 'mayor of chicago' as one noun-phrase\n  if (doc.has('#Noun (of|by|for) .')) {\n    let m = doc.splitAfter('[#Noun+]')\n    res.main = m.eq(0)\n    res.post = m.eq(1)\n  }\n  return res\n}\nmodule.exports = parse\n","const hasPlural = require('./plural/hasPlural')\nconst getArticle = require('./getArticle')\nconst isPlural = require('./plural/isPlural')\nconst toPossessive = require('./toPossessive')\nconst parse = require('./parse')\n\nconst methods = {\n  /** overload the original json with noun information */\n  json: function(options) {\n    let n = null\n    if (typeof options === 'number') {\n      n = options\n      options = null\n    }\n    options = options || { text: true, normal: true, trim: true, terms: true }\n    let res = []\n    this.forEach(doc => {\n      let json = doc.json(options)[0]\n      json.article = getArticle(doc)\n      res.push(json)\n    })\n    if (n !== null) {\n      return res[n]\n    }\n    return res\n  },\n  /** get all adjectives describing this noun*/\n  adjectives: function() {\n    let list = this.lookAhead('^(that|who|which)? (was|is|will)? be? #Adverb? #Adjective+')\n    list = list.concat(this.lookBehind('#Adjective+ #Adverb?$'))\n    list = list.match('#Adjective')\n    return list.sort('index')\n  },\n\n  isPlural: function() {\n    return this.if('#Plural') //assume tagger has run?\n  },\n  hasPlural: function() {\n    return this.filter(d => hasPlural(d))\n  },\n  toPlural: function(agree) {\n    let toPlural = this.world.transforms.toPlural\n    this.forEach(doc => {\n      if (doc.has('#Plural') || hasPlural(doc) === false) {\n        return\n      }\n      // double-check it isn't an un-tagged plural\n      let main = parse(doc).main\n      let str = main.text('reduced')\n      if (!main.has('#Singular') && isPlural(str) === true) {\n        return\n      }\n      str = toPlural(str, this.world)\n      main.replace(str).tag('#Plural')\n      // 'an apple' -> 'apples'\n      if (agree) {\n        let an = main.lookBefore('(an|a) #Adjective?$').not('#Adjective')\n        if (an.found === true) {\n          an.remove()\n        }\n      }\n    })\n    return this\n  },\n  toSingular: function(agree) {\n    let toSingular = this.world.transforms.toSingular\n    this.forEach(doc => {\n      if (doc.has('#Singular') || hasPlural(doc) === false) {\n        return\n      }\n      // double-check it isn't an un-tagged plural\n      let main = parse(doc).main\n      let str = main.text('reduced')\n      if (!main.has('#Plural') && isPlural(str) !== true) {\n        return\n      }\n      str = toSingular(str, this.world)\n      main.replace(str).tag('#Singular')\n      // add an article\n      if (agree) {\n        // 'apples' -> 'an apple'\n        let start = doc\n        let adj = doc.lookBefore('#Adjective')\n        if (adj.found) {\n          start = adj\n        }\n        let article = getArticle(start)\n        start.insertBefore(article)\n      }\n    })\n    return this\n  },\n  toPossessive: function() {\n    this.forEach(d => {\n      toPossessive(d)\n    })\n    return this\n  },\n}\nmodule.exports = methods\n","const methods = require('./methods')\n\nconst addMethod = function(Doc) {\n  /**  */\n  class Nouns extends Doc {}\n  // add-in our methods\n  Object.assign(Nouns.prototype, methods)\n\n  Doc.prototype.nouns = function(n) {\n    // don't split 'paris, france'\n    let keep = this.match('(#City && @hasComma) (#Region|#Country)')\n    // but split the other commas\n    let m = this.not(keep).splitAfter('@hasComma')\n    // combine them back together\n    m = m.concat(keep)\n\n    m = m.match('#Noun+ (of|by)? the? #Noun+?')\n    //nouns that we don't want in these results, for weird reasons\n    m = m.not('#Pronoun')\n    m = m.not('(there|these)')\n    m = m.not('(#Month|#WeekDay)') //allow Durations, Holidays\n    // //allow possessives like \"spencer's\", but not generic ones like,\n    m = m.not('(my|our|your|their|her|his)')\n    m = m.not('(of|for|by|the)$')\n\n    if (typeof n === 'number') {\n      m = m.get(n)\n    }\n    return new Nouns(m.list, this, this.world)\n  }\n  return Doc\n}\nmodule.exports = addMethod\n","const open = /\\(/\nconst close = /\\)/\n\nconst addMethod = function(Doc) {\n  /** anything between (these things) */\n  class Parentheses extends Doc {\n    /** remove the parentheses characters */\n    unwrap() {\n      this.list.forEach(p => {\n        let first = p.terms(0)\n        first.pre = first.pre.replace(open, '')\n        let last = p.lastTerm()\n        last.post = last.post.replace(close, '')\n      })\n      return this\n    }\n  }\n\n  Doc.prototype.parentheses = function(n) {\n    let list = []\n    this.list.forEach(p => {\n      let terms = p.terms()\n      //look for opening brackets\n      for (let i = 0; i < terms.length; i += 1) {\n        const t = terms[i]\n        if (open.test(t.pre)) {\n          //look for the closing bracket..\n          for (let o = i; o < terms.length; o += 1) {\n            if (close.test(terms[o].post)) {\n              let len = o - i + 1\n              list.push(p.buildFrom(t.id, len))\n              i = o\n              break\n            }\n          }\n        }\n      }\n    })\n    //support nth result\n    if (typeof n === 'number') {\n      if (list[n]) {\n        list = [list[n]]\n      } else {\n        list = []\n      }\n      return new Parentheses(list, this, this.world)\n    }\n    return new Parentheses(list, this, this.world)\n  }\n\n  return Doc\n}\nmodule.exports = addMethod\n","const addMethod = function(Doc) {\n  /**  */\n  class Possessives extends Doc {\n    constructor(list, from, world) {\n      super(list, from, world)\n      this.contracted = null\n    }\n    /** turn didn't into 'did not' */\n    strip() {\n      this.list.forEach(p => {\n        let terms = p.terms()\n        terms.forEach(t => {\n          let str = t.text.replace(/'s$/, '')\n          t.set(str || t.text)\n        })\n      })\n      return this\n    }\n  }\n\n  //find contractable, expanded-contractions\n  // const findExpanded = r => {\n  //   let remain = r.not('#Contraction')\n  //   let m = remain.match('(#Noun|#QuestionWord) (#Copula|did|do|have|had|could|would|will)')\n  //   m.concat(remain.match('(they|we|you|i) have'))\n  //   m.concat(remain.match('i am'))\n  //   m.concat(remain.match('(#Copula|#Modal|do|does|have|has|can|will) not'))\n  //   return m\n  // }\n\n  Doc.prototype.possessives = function(n) {\n    //find currently-contracted\n    let found = this.match('#Noun+? #Possessive')\n    //todo: split consecutive contractions\n    if (typeof n === 'number') {\n      found = found.get(n)\n    }\n    return new Possessives(found.list, this, this.world)\n  }\n  return Doc\n}\nmodule.exports = addMethod\n","const pairs = {\n  '\\u0022': '\\u0022', // 'StraightDoubleQuotes'\n  '\\uFF02': '\\uFF02', // 'StraightDoubleQuotesWide'\n  '\\u0027': '\\u0027', // 'StraightSingleQuotes'\n  '\\u201C': '\\u201D', // 'CommaDoubleQuotes'\n  '\\u2018': '\\u2019', // 'CommaSingleQuotes'\n  '\\u201F': '\\u201D', // 'CurlyDoubleQuotesReversed'\n  '\\u201B': '\\u2019', // 'CurlySingleQuotesReversed'\n  '\\u201E': '\\u201D', // 'LowCurlyDoubleQuotes'\n  '\\u2E42': '\\u201D', // 'LowCurlyDoubleQuotesReversed'\n  '\\u201A': '\\u2019', // 'LowCurlySingleQuotes'\n  '\\u00AB': '\\u00BB', // 'AngleDoubleQuotes'\n  '\\u2039': '\\u203A', // 'AngleSingleQuotes'\n  // Prime 'non quotation'\n  '\\u2035': '\\u2032', // 'PrimeSingleQuotes'\n  '\\u2036': '\\u2033', // 'PrimeDoubleQuotes'\n  '\\u2037': '\\u2034', // 'PrimeTripleQuotes'\n  // Prime 'quotation' variation\n  '\\u301D': '\\u301E', // 'PrimeDoubleQuotes'\n  '\\u0060': '\\u00B4', // 'PrimeSingleQuotes'\n  '\\u301F': '\\u301E', // 'LowPrimeDoubleQuotesReversed'\n}\n\nconst hasOpen = RegExp('(' + Object.keys(pairs).join('|') + ')')\n\nconst addMethod = function(Doc) {\n  /** \"these things\" */\n  class Quotations extends Doc {\n    /** remove the quote characters */\n    unwrap() {\n      return this\n    }\n  }\n\n  Doc.prototype.quotations = function(n) {\n    let list = []\n    this.list.forEach(p => {\n      let terms = p.terms()\n      //look for opening quotes\n      for (let i = 0; i < terms.length; i += 1) {\n        const t = terms[i]\n        if (hasOpen.test(t.pre)) {\n          let char = (t.pre.match(hasOpen) || [])[0]\n          let want = pairs[char]\n          // if (!want) {\n          //   console.warn('missing quote char ' + char)\n          // }\n          //look for the closing bracket..\n          for (let o = i; o < terms.length; o += 1) {\n            if (terms[o].post.indexOf(want) !== -1) {\n              let len = o - i + 1\n              list.push(p.buildFrom(t.id, len))\n              i = o\n              break\n            }\n          }\n        }\n      }\n    })\n    //support nth result\n    if (typeof n === 'number') {\n      if (list[n]) {\n        list = [list[n]]\n      } else {\n        list = []\n      }\n      return new Quotations(list, this, this.world)\n    }\n    return new Quotations(list, this, this.world)\n  }\n  // alias\n  Doc.prototype.quotes = Doc.prototype.quotations\n\n  return Doc\n}\nmodule.exports = addMethod\n","// walked => walk  - turn a verb into it's root form\nconst toInfinitive = function(parsed, world) {\n  let verb = parsed.verb\n\n  //1. if it's already infinitive\n  let str = verb.text('normal')\n  if (verb.has('#Infinitive')) {\n    return str\n  }\n\n  // 2. world transform does the heavy-lifting\n  let tense = null\n  if (verb.has('#PastTense')) {\n    tense = 'PastTense'\n  } else if (verb.has('#Gerund')) {\n    tense = 'Gerund'\n  } else if (verb.has('#PresentTense')) {\n    tense = 'PresentTense'\n  } else if (verb.has('#Participle')) {\n    tense = 'Participle'\n  } else if (verb.has('#Actor')) {\n    tense = 'Actor'\n  }\n  return world.transforms.toInfinitive(str, world, tense)\n}\nmodule.exports = toInfinitive\n","// spencer walks -> singular\n// we walk -> plural\n\n// the most-recent noun-phrase, before this verb.\nconst findNoun = function(vb) {\n  let noun = vb.lookBehind('#Noun+').last()\n  return noun\n}\n\n//sometimes you can tell if a verb is plural/singular, just by the verb\n// i am / we were\n// othertimes you need its subject 'we walk' vs 'i walk'\nconst isPlural = function(parsed) {\n  let vb = parsed.verb\n  if (vb.has('(are|were|does)') || parsed.auxiliary.has('(are|were|does)')) {\n    return true\n  }\n  if (vb.has('(is|am|do|was)') || parsed.auxiliary.has('(is|am|do|was)')) {\n    return false\n  }\n  //consider its prior noun\n  let noun = findNoun(vb)\n  if (noun.has('(we|they|you)')) {\n    return true\n  }\n  if (noun.has('#Plural')) {\n    return true\n  }\n  if (noun.has('#Singular')) {\n    return false\n  }\n  return null\n}\nmodule.exports = isPlural\n","const toInfinitive = require('./toInfinitive')\nconst isPlural = require('./isPlural')\n// #Modal : would walk    -> 'would not walk'\n// #Copula : is           -> 'is not'\n// #PastTense : walked    -> did not walk\n// #PresentTense : walks  -> does not walk\n// #Gerund : walking:     -> not walking\n// #Infinitive : walk     -> do not walk\n\nconst toNegative = function(parsed, world) {\n  let vb = parsed.verb\n  // if it's already negative...\n  if (parsed.negative.found) {\n    return\n  }\n\n  // would walk -> would not walk\n  if (parsed.auxiliary.found) {\n    parsed.auxiliary.eq(0).append('not')\n    return\n  }\n  // is walking -> is not walking\n  if (vb.has('(#Copula|will|has|had|do)')) {\n    vb.append('not')\n    return\n  }\n  // walked -> did not walk\n  if (vb.has('#PastTense')) {\n    let inf = toInfinitive(parsed, world)\n    vb.replaceWith(inf, true)\n    vb.prepend('did not')\n    return\n  }\n  // walks -> does not walk\n  if (vb.has('#PresentTense')) {\n    let inf = toInfinitive(parsed, world)\n    vb.replaceWith(inf, true)\n    if (isPlural(parsed, world)) {\n      vb.prepend('do not')\n    } else {\n      vb.prepend('does not')\n    }\n    return\n  }\n  //walking -> not walking\n  if (vb.has('#Gerund')) {\n    let inf = toInfinitive(parsed, world)\n    vb.replaceWith(inf, true)\n    vb.prepend('not')\n    return\n  }\n\n  //fallback 1:  walk -> does not walk\n  if (isPlural(parsed, world)) {\n    vb.prepend('does not')\n    return\n  }\n  //fallback 2:  walk -> do not walk\n  vb.prepend('do not')\n  return\n}\nmodule.exports = toNegative\n","// turn 'would not really walk up' into parts\nconst parseVerb = function(vb) {\n  let parsed = {\n    adverb: vb.match('#Adverb+'), // 'really'\n    negative: vb.match('#Negative'), // 'not'\n    auxiliary: vb.match('#Auxiliary').not('(#Negative|#Adverb)'), // 'will' of 'will go'\n    particle: vb.match('#Particle'), // 'up' of 'pull up'\n    verb: vb.match('#Verb').not('(#Adverb|#Negative|#Auxiliary|#Particle)'),\n  }\n  // fallback, if no verb found\n  if (!parsed.verb.found) {\n    // blank-everything\n    Object.keys(parsed).forEach(k => {\n      parsed[k] = parsed[k].not('.')\n    })\n    // it's all the verb\n    parsed.verb = vb\n    return parsed\n  }\n  //\n  if (parsed.adverb && parsed.adverb.found) {\n    let match = parsed.adverb.text('reduced') + '$'\n    if (vb.has(match)) {\n      parsed.adverbAfter = true\n    }\n  }\n  return parsed\n}\nmodule.exports = parseVerb\n","const isPlural = require('../isPlural')\n\n/** too many special cases for is/was/will be*/\nconst toBe = parsed => {\n  let isI = false\n  let plural = isPlural(parsed)\n  let isNegative = parsed.negative.found\n  //account for 'i is' -> 'i am' irregular\n  // if (vb.parent && vb.parent.has('i #Adverb? #Copula')) {\n  //   isI = true;\n  // }\n\n  // 'i look', not 'i looks'\n  if (parsed.verb.lookBehind('(i|we) (#Adverb|#Verb)?$').found) {\n    isI = true\n  }\n\n  let obj = {\n    PastTense: 'was',\n    PresentTense: 'is',\n    FutureTense: 'will be',\n    Infinitive: 'is',\n    Gerund: 'being',\n    Actor: '',\n    PerfectTense: 'been',\n    Pluperfect: 'been',\n  }\n  //\"i is\" -> \"i am\"\n  if (isI === true) {\n    obj.PresentTense = 'am'\n    obj.Infinitive = 'am'\n  }\n  if (plural) {\n    obj.PastTense = 'were'\n    obj.PresentTense = 'are'\n    obj.Infinitive = 'are'\n  }\n  if (isNegative) {\n    obj.PastTense += ' not'\n    obj.PresentTense += ' not'\n    obj.FutureTense = 'will not be'\n    obj.Infinitive += ' not'\n    obj.PerfectTense = 'not ' + obj.PerfectTense\n    obj.Pluperfect = 'not ' + obj.Pluperfect\n    obj.Gerund = 'not ' + obj.Gerund\n  }\n  return obj\n}\nmodule.exports = toBe\n","const toInfinitive = require('../toInfinitive')\nconst toBe = require('./toBe')\n\nconst conjugate = function(parsed, world) {\n  let verb = parsed.verb\n\n  //special handling of 'is', 'will be', etc.\n  if (verb.has('#Copula') || (verb.out('normal') === 'be' && parsed.auxiliary.has('will'))) {\n    return toBe(parsed, world)\n  }\n\n  let hasHyphen = parsed.verb.termList(0).hasHyphen()\n\n  let infinitive = toInfinitive(parsed, world)\n  if (!infinitive) {\n    return {}\n  }\n  let forms = world.transforms.conjugate(infinitive, world)\n  forms.Infinitive = infinitive\n\n  // add particle to phrasal verbs ('fall over')\n  if (parsed.particle.found) {\n    let particle = parsed.particle.text()\n    let space = hasHyphen === true ? '-' : ' '\n    Object.keys(forms).forEach(k => (forms[k] += space + particle))\n  }\n  //put the adverb at the end?\n  if (parsed.adverb.found) {\n    let adverb = parsed.adverb.text()\n    let space = hasHyphen === true ? '-' : ' '\n    if (parsed.adverbAfter === true) {\n      Object.keys(forms).forEach(k => (forms[k] += space + adverb))\n    } else {\n      Object.keys(forms).forEach(k => (forms[k] = adverb + space + forms[k]))\n    }\n  }\n\n  //apply negative\n  const isNegative = parsed.negative.found\n  if (isNegative) {\n    forms.PastTense = 'did not ' + forms.Infinitive\n    forms.PresentTense = 'does not ' + forms.Infinitive\n    forms.Gerund = 'not ' + forms.Gerund\n  }\n  //future Tense is pretty straightforward\n  if (!forms.FutureTense) {\n    if (isNegative) {\n      forms.FutureTense = 'will not ' + forms.Infinitive\n    } else {\n      forms.FutureTense = 'will ' + forms.Infinitive\n    }\n  }\n  if (isNegative) {\n    forms.Infinitive = 'not ' + forms.Infinitive\n  }\n  return forms\n}\nmodule.exports = conjugate\n","const toNegative = require('./toNegative')\nconst parseVerb = require('./parse')\nconst isPlural = require('./isPlural')\nconst conjugate = require('./conjugate')\n\nmodule.exports = {\n  /** overload the original json with verb information */\n  json: function(options) {\n    let n = null\n    if (typeof options === 'number') {\n      n = options\n      options = null\n    }\n    options = options || { text: true, normal: true, trim: true, terms: true }\n    let res = []\n    this.forEach(p => {\n      let json = p.json(options)[0]\n      let parsed = parseVerb(p)\n      json.parts = {}\n      Object.keys(parsed).forEach(k => {\n        json.parts[k] = parsed[k].text('normal')\n      })\n      json.isNegative = p.has('#Negative')\n      json.conjugations = conjugate(parsed, this.world)\n      res.push(json)\n    })\n    if (n !== null) {\n      return res[n]\n    }\n    return res\n  },\n\n  /** grab the adverbs describing these verbs */\n  adverbs: function() {\n    let list = []\n    // look at internal adverbs\n    this.forEach(vb => {\n      let advb = parseVerb(vb).adverb\n      if (advb.found) {\n        list = list.concat(advb.list)\n      }\n    })\n    // look for leading adverbs\n    let m = this.lookBehind('#Adverb+$')\n    if (m.found) {\n      list = m.list.concat(list)\n    }\n    // look for trailing adverbs\n    m = this.lookAhead('^#Adverb+')\n    if (m.found) {\n      list = list.concat(m.list)\n    }\n    return this.buildFrom(list)\n  },\n  /**return verbs like 'we walk' and not 'spencer walks' */\n  isPlural: function() {\n    let list = []\n    this.forEach(vb => {\n      let parsed = parseVerb(vb)\n      if (isPlural(parsed, this.world) === true) {\n        list.push(vb.list[0])\n      }\n    })\n    return this.buildFrom(list)\n  },\n  /** return verbs like 'spencer walks' and not 'we walk' */\n  isSingular: function() {\n    let list = []\n    this.forEach(vb => {\n      let parsed = parseVerb(vb)\n      if (isPlural(parsed, this.world) === false) {\n        list.push(vb.list[0])\n      }\n    })\n    return this.buildFrom(list)\n  },\n\n  /**  */\n  conjugate: function() {\n    let result = []\n    this.forEach(vb => {\n      let parsed = parseVerb(vb)\n      let forms = conjugate(parsed, this.world)\n      result.push(forms)\n    })\n    return result\n  },\n  /** */\n  toPastTense: function() {\n    this.forEach(vb => {\n      let parsed = parseVerb(vb)\n      let str = conjugate(parsed, this.world).PastTense\n      if (str) {\n        vb.replaceWith(str, false)\n        // vb.tag('PastTense')\n      }\n    })\n    return this\n  },\n  /** */\n  toPresentTense: function() {\n    this.forEach(vb => {\n      let parsed = parseVerb(vb)\n      let obj = conjugate(parsed, this.world)\n      let str = obj.PresentTense\n      // 'i look', not 'i looks'\n      if (vb.lookBehind('(i|we) (#Adverb|#Verb)?$').found) {\n        str = obj.Infinitive\n      }\n      if (str) {\n        vb.replaceWith(str, false)\n        vb.tag('PresentTense')\n      }\n    })\n    return this\n  },\n  /** */\n  toFutureTense: function() {\n    this.forEach(vb => {\n      let parsed = parseVerb(vb)\n      let str = conjugate(parsed, this.world).FutureTense\n      if (str) {\n        vb.replaceWith(str, false)\n        vb.tag('FutureTense')\n      }\n    })\n    return this\n  },\n  /** */\n  toInfinitive: function() {\n    this.forEach(vb => {\n      let parsed = parseVerb(vb)\n      let str = conjugate(parsed, this.world).Infinitive\n      if (str) {\n        vb.replaceWith(str, false)\n        vb.tag('Infinitive')\n      }\n    })\n    return this\n  },\n  /** */\n  toGerund: function() {\n    this.forEach(vb => {\n      let parsed = parseVerb(vb)\n      let str = conjugate(parsed, this.world).Gerund\n      if (str) {\n        vb.replaceWith(str, false)\n        vb.tag('Gerund')\n      }\n    })\n    return this\n  },\n\n  /** return only verbs with 'not'*/\n  isNegative: function() {\n    return this.if('#Negative')\n  },\n  /**  return only verbs without 'not'*/\n  isPositive: function() {\n    return this.ifNo('#Negative')\n  },\n  /** add a 'not' to these verbs */\n  toNegative: function() {\n    this.list.forEach(p => {\n      let doc = this.buildFrom([p])\n      let parsed = parseVerb(doc)\n      toNegative(parsed, doc.world)\n    })\n    return this\n  },\n  /** remove 'not' from these verbs */\n  toPositive: function() {\n    let m = this.match('do not #Verb')\n    if (m.found) {\n      m.remove('do not')\n    }\n    return this.remove('#Negative')\n  },\n}\n","const subsets = require('./_simple')\nconst subclass = [\n  require('./Abbreviations'),\n  require('./Acronyms'),\n  require('./Clauses'),\n  require('./Contractions'),\n  require('./Lists'),\n  require('./Nouns'),\n  require('./Parentheses'),\n  require('./Possessives'),\n  require('./Quotations'),\n  require('./Verbs'),\n  require('./People'),\n]\n\nconst extend = function(Doc) {\n  // add basic methods\n  Object.keys(subsets).forEach(k => (Doc.prototype[k] = subsets[k]))\n  // add subclassed methods\n  subclass.forEach(addFn => addFn(Doc))\n  return Doc\n}\nmodule.exports = extend\n","const methods = require('./methods')\n\nconst addMethod = function(Doc) {\n  /**  */\n  class Verbs extends Doc {}\n  // add-in our methods\n  Object.assign(Verbs.prototype, methods)\n\n  // aliases\n  Verbs.prototype.negate = Verbs.prototype.toNegative\n\n  Doc.prototype.verbs = function(n) {\n    let match = this.match('(#Adverb|#Auxiliary|#Verb|#Negative|#Particle)+')\n    // try to ignore leading and trailing adverbs\n    match = match.not('^#Adverb+')\n    match = match.not('#Adverb+$')\n    // handle commas:\n    // don't split 'really, really'\n    let keep = match.match('(#Adverb && @hasComma) #Adverb')\n    // // but split the other commas\n    let m = match.not(keep).splitAfter('@hasComma')\n    // // combine them back together\n    m = m.concat(keep)\n    m.sort('index')\n    //handle slashes?\n\n    //ensure there's actually a verb\n    m = m.if('#Verb')\n\n    //grab (n)th result\n    if (typeof n === 'number') {\n      m = m.get(n)\n    }\n    let vb = new Verbs(m.list, this, this.world)\n    return vb\n  }\n  return Doc\n}\nmodule.exports = addMethod\n","const addMethod = function(Doc) {\n  /**  */\n  class People extends Doc {\n    // honorifics(){}\n    // firstNames(){}\n    // lastNames(){}\n    // pronouns(){}\n    // toPronoun(){}\n    // fromPronoun(){}\n  }\n\n  Doc.prototype.people = function(n) {\n    let match = this.splitAfter('@hasComma')\n    match = match.match('#Person+')\n\n    //grab (n)th result\n    if (typeof n === 'number') {\n      match = match.get(n)\n    }\n    return new People(match.list, this, this.world)\n  }\n  return Doc\n}\nmodule.exports = addMethod\n","const methods = {\n  misc: require('./methods'),\n  selections: require('../Subset/_simple'),\n}\nconst tagger = require('../02-tagger')\nconst tokenize = require('../01-tokenizer')\nconst extend = require('../Subset')\n\n/** a parsed text object */\nclass Doc {\n  constructor(list, from, world) {\n    this.list = list\n    //quiet these properties in console.logs\n    Object.defineProperty(this, 'from', {\n      enumerable: false,\n      value: from,\n      writable: true,\n    })\n    //borrow some missing data from parent\n    if (world === undefined && from !== undefined) {\n      world = from.world\n    }\n    //'world' getter\n    Object.defineProperty(this, 'world', {\n      enumerable: false,\n      value: world,\n      writable: true,\n    })\n    //fast-scans for our data\n\n    //'found' getter\n    Object.defineProperty(this, 'found', {\n      get: () => this.list.length > 0,\n    })\n    //'length' getter\n    Object.defineProperty(this, 'length', {\n      get: () => this.list.length,\n    })\n    // this is way easier than .constructor.name...\n    Object.defineProperty(this, 'isA', {\n      get: () => 'Doc',\n    })\n  }\n\n  /** run part-of-speech tagger on all results*/\n  tagger() {\n    return tagger(this)\n  }\n\n  /** pool is stored on phrase objects */\n  pool() {\n    if (this.list.length > 0) {\n      return this.list[0].pool\n    }\n    return this.all().list[0].pool\n  }\n}\n\n/** create a new Document object */\nDoc.prototype.buildFrom = function(list) {\n  list = list.map(p => p.clone(true))\n  // new this.constructor()\n  let doc = new Doc(list, this, this.world)\n  return doc\n}\n\n/** create a new Document from plaintext. */\nDoc.prototype.fromText = function(str) {\n  let list = tokenize(str, this.world, this.pool())\n  return this.buildFrom(list)\n}\n\nObject.assign(Doc.prototype, methods.misc)\nObject.assign(Doc.prototype, methods.selections)\n\n//add sub-classes\nextend(Doc)\n\n//aliases\nconst aliases = {\n  untag: 'unTag',\n  and: 'match',\n  notIf: 'ifNo',\n  only: 'if',\n  onlyIf: 'if',\n}\nObject.keys(aliases).forEach(k => (Doc.prototype[k] = Doc.prototype[aliases[k]]))\nmodule.exports = Doc\n","const tokenize = require('./01-tokenizer')\nconst fromJSON = require('./01-tokenizer/fromJSON')\nconst version = require('./_version')\nconst World = require('./World/World')\nconst Doc = require('./Doc/Doc')\nconst Phrase = require('./Phrase/Phrase')\nconst Term = require('./Term/Term')\nconst Pool = require('./01-tokenizer/Pool')\n\nfunction instance(worldInstance) {\n  //blast-out our word-lists, just once\n  let world = worldInstance\n\n  /** parse and tag text into a compromise object  */\n  const nlp = function(text = '', lexicon) {\n    if (lexicon) {\n      world.addWords(lexicon)\n    }\n    let list = tokenize(text, world)\n    let doc = new Doc(list, null, world)\n    doc.tagger()\n    return doc\n  }\n\n  /** parse text into a compromise object, without running POS-tagging */\n  nlp.tokenize = function(text = '', lexicon) {\n    if (lexicon) {\n      world.addWords(lexicon)\n    }\n    let list = tokenize(text, world)\n    let doc = new Doc(list, null, world)\n    return doc\n  }\n\n  /** mix in a compromise-plugin */\n  nlp.extend = function(fn) {\n    fn(Doc, world, this, Phrase, Term, Pool)\n    return this\n  }\n\n  /** create a compromise Doc object from .json() results */\n  nlp.fromJSON = function(json) {\n    let list = fromJSON(json, world)\n    return new Doc(list, null, world)\n  }\n\n  /** make a deep-copy of the library state */\n  nlp.clone = function() {\n    return instance(world.clone())\n  }\n\n  /** log our decision-making for debugging */\n  nlp.verbose = function(bool = true) {\n    world.verbose(bool)\n    return this\n  }\n\n  /** current version of the library */\n  nlp.version = version\n  // alias\n  nlp.import = nlp.load\n\n  return nlp\n}\n\nmodule.exports = instance(new World())\n","module.exports = '12.3.0'"],"names":["chars","split","str","text","i","Math","floor","random","length","compact","a","b","c","d","e","f","g","h","I","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","unicode","Object","keys","forEach","join","periodAcronym","oneLetterAcronym","noPeriodAcronym","lowerCaseAcronym","test","hasSlash","original","toLowerCase","trim","killUnicode","replace","isAcronym","startings","endings","hasApostrophe","hasAcronym","minusNumber","pre","post","found","after","clean","normalize","parsed","reduced","reduce","word","alias","titleCase","upperCase","exports","this","toUpperCase","isTitleCase","startQuote","endQuote","punct","indexOf","hasQuote","hasPost","hasPre","hyphen","Boolean","implicit","wrapMatch","doesMatch","reg","index","id","anything","start","end","undefined","hasOwnProperty","soft","root","tag","tags","method","regex","choices","operator","every","some","result","negative","boring","world","transform","transforms","Plural","toSingular","Verb","Negative","Infinitive","tense","PastTense","Gerund","PresentTense","Participle","Actor","toInfinitive","hasSpace","isUpperCase","options","showPre","showPost","before","normal","titlecase","ProperNoun","Acronym","lowercase","acronyms","whitespace","last","punctuation","hasEllipses","abbreviations","Abbreviation","boringTags","Auxiliary","Possessive","term","tagSet","sort","lineage","isA","jsonDefault","offset","bestTag","assign","rankTags","require$$0","require$$1","require$$2","require$$3","require$$4","isClientSide","window","document","padEnd","width","toString","reason","console","log","charAt","substr","addTag","tagset","fns","isVerbose","down","unTag","notA","canBe","enemies","add","Term","String","obj","parseTerm","prev","next","makeId","prototype","clone","methods","tagMethods","cache","terms","pool","get","error","push","isShallow","buildFrom","newTerms","map","_this","wantId","lastId","filter","trimEnd","isFirst","isLast","isFull","textOut","lastTerm","endOfSentence","addWhitespace","beforeTerms","newTerm","match","newPhrase","doc","lastBefore","lastNew","afterId","beforeId","stitchIn","list","toStretch","hasId","docs","concat","parents","parent","shouldChange","starterId","main","phrase","set","deleteLength","arr","find","shrinkAll","append","prepend","deletePhrase","firstLength","tmp","findIndex","slice","res","json","regs","all","getAfter","getBefore","require$$5","optional","words","getGreedy","until","count","max","min","greedyTo","nextReg","getOrCreateGroup","namedGroups","namedGroupId","startIndex","group","named","captures","previousGroupId","isNamedGroup","remain","greedy","startAt","isImplicit","skipto","matches","hasMinMax","andSign","captureName","RegExp","stripStart","stripEnd","stripBoth","parseToken","exec","Number","isNamed","capture","postProcess","tokens","captureArr","first","reverse","getLastTrue","input","_typeof","call","isArray","byArray","ids","fromDoc","byParentheses","byWords","matchOne","syntax","failFast","minLength","tryMatch","groups","names","matchAll","ts","current","justOne","notMatch","_this2","results","previous","can","_this3","Phrase","defineProperty","enumerable","writable","value","matchMethods","aliases","Pool","initSplit","hasSomething","hasEllipse","newLine","hasLetter","startWhitespace","isSentence","abbrevs","lastWord","sentences","chunks","splits","lines","naiive_split","ws","wordlike","isBoundary","naiiveSplit","isSlash","notWord","hasHyphen","splitHyphens","hyphens","whichDash","carry","combineSlashes","splitSentences","splitTerms","phrases","linkTerms","Cool","entity","Noun","Singular","Person","FirstName","MaleName","FemaleName","LastName","Honorific","Place","Country","City","Region","Address","Organization","SportsTeam","School","Company","Uncountable","Pronoun","Activity","Unit","Demonym","FutureTense","Copula","Modal","PerfectTense","Pluperfect","PhrasalVerb","Particle","Value","Ordinal","Cardinal","RomanNumeral","TextValue","NumericValue","Money","Percent","Adjective","Comparable","Comparative","Superlative","NumberRange","Adverb","Date","Month","WeekDay","Time","Determiner","Conjunction","Preposition","QuestionWord","Currency","Expression","Url","PhoneNumber","HashTag","AtMention","Emoji","Emoticon","Email","Condition","colorMap","color","len","unique","key","validate","inferIsA","inferNotA","inferColor","addIn","nouns","verbs","values","misc","inferTags","build","addWord","lex","lexicon","hasCompound","plural","toPlural","conj","conjugate","adjectives","irregulars","inf","forms","g8","vh1","q1","q2","q3","q4","mapping","prt","perf","pst","fut","pres","pluperf","conjugations","act","ache","age","aim","arise","babysit","ban","be","beat","become","begin","being","bend","bet","bind","bite","bleed","blow","boil","brake","breed","bring","broadcast","budget","burn","burst","buy","choose","cling","come","compete","cost","creep","cut","deal","develop","die","dig","dive","draw","dream","drink","drive","drop","eat","edit","egg","fall","feed","feel","fight","flee","fling","fly","forbid","forget","forgive","free","freeze","give","go","grow","hang","have","hear","hide","hit","hold","hurt","ice","imply","is","keep","kneel","know","lay","lead","leap","leave","lend","lie","light","loose","lose","make","mean","meet","miss","name","pay","prove","puke","put","quit","read","ride","ring","rise","rub","run","say","seat","see","seek","sell","send","sew","shake","shave","shed","shine","shoot","show","shut","sing","sink","sit","ski","slay","sleep","slide","smash","sneak","speak","speed","spend","spill","spin","spit","spread","spring","stand","steal","stick","sting","stink","stream","strew","strike","suit","sware","swear","sweep","swim","swing","take","teach","tear","tell","think","thrive","tie","undergo","understand","upset","wait","wake","wear","weave","wed","weep","win","wind","withdraw","wring","write","final","repl","pr","pa","gr","ar","posMap","doTransform","pos","suffixes","hasY","checkSuffix","genericFill","do_rules","dont_rules","nice","late","hard","inner","outer","far","worse","bad","good","big","large","grey","gray","green","yellow","red","well","sad","toSuperlative","toComparative","sup","comp","addE","trySuffix","rules","invert","to","guessVerb","addendum","alga","alumna","alumnus","analysis","antenna","appendix","avocado","axis","bacillus","barracks","beau","bus","cactus","chateau","child","circus","clothes","corpus","criterion","curriculum","database","deer","diagnosis","echo","embargo","epoch","foot","formula","fungus","genus","goose","halo","hippopotamus","larva","leaf","libretto","loaf","man","matrix","memorandum","modulus","mosquito","mouse","move","nebula","nucleus","octopus","opus","ovum","ox","parenthesis","person","phenomenon","prognosis","quiz","radius","referendum","rodeo","sex","shoe","sombrero","stimulus","stomach","syllabus","synopsis","tableau","thesis","thief","tooth","tornado","tuxedo","vertebra","irregs","three","guess","two","guessTense","rule","World","defaultTags","unpackWords","lexData","addIrregulars","getByTag","bool","unpack","addLex","inferTagSet","fn","taggers","plurals","compounds","postProcessors","JSON","parse","stringify","w2","from","addParent","doShallow","wordCount","setRoot","eq","num","target","groupByNames","getOneName","byName","parseSyntax","not","has","lookAhead","lookBehind","befores","safe","tagList","why","setTag","detachParent","sub","_this4","_this5","lookups","tokenize","findStart","lookup","keepTags","uncache","newPhrases","merge","keepCase","tagger","oldTags","tagSafe","replaceWith","arguments","arg","toRemove","shouldTrim","showFull","txt","trimPre","trimPost","offsets","elapsed","termList","termOffsets","jsonDefaults","setOptions","frequency","freq","already","css","blue","magenta","cyan","black","cli","tagString","module","logClientSide","debug","topk","alpha","left","right","alphabetical","wordcount","seqNames","sequence","seq","sequential","chron","chronological","counts","order","sortSequential","isPunct","quotes","termArr","hasDash","quotations","adverbs","remove","defaults","emoji","contractions","parentheses","possessives","honorifics","medium","heavy","strip","contraction","expand","unwrap","possessive","splitOn","foundEm","parts","splitAfter","splitBefore","segment","eachTerm","toTitleCase","dehyphenate","toQuotations","removed","increase","postPunct","setContraction","suffix","require$$6","require$$7","require$$8","require$$9","require$$10","require$$11","require$$12","require$$13","require$$14","require$$15","require$$16","require$$17","emojis","atmentions","atMentions","phoneNumbers","money","places","organizations","clauses","entities","yup","people","things","topics","Doc","Abbreviations","stripPeriods","hasPeriod","Acronyms","commas","notIf","conjunctions","condition","tooLong","Contractions","contracted","isTitlecase","expanded","isExpanded","isContracted","beforeLast","conjunction","hasOxford","Lists","addPunctuation","items","lists","nounList","adjList","verbList","hour","heir","heirloom","honest","honour","honor","uber","an_acronyms","a_regexs","firstLetter","isSingular","isPlural","endS","exceptions","he","she","they","we","you","her","their","our","my","your","article","getArticle","hasPlural","agree","an","lookBefore","adj","insertBefore","toPossessive","Nouns","open","close","Parentheses","Possessives","pairs","hasOpen","verb","vb","auxiliary","noun","findNoun","adverb","particle","adverbAfter","isI","isNegative","out","toBe","infinitive","space","parseVerb","advb","toPastTense","toPresentTense","_this6","toFutureTense","_this7","_this8","toGerund","_this9","isPositive","ifNo","toNegative","_this10","toPositive","subclass","Quotations","char","want","Verbs","negate","People","subsets","addFn","selections","fromText","untag","and","only","onlyIf","instance","worldInstance","nlp","addWords","extend","fromJSON","verbose","version","load"],"mappings":"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CAEExkB,IAAK,wBACLwkB,GAAI,OAEN,CACExkB,IAAK,aACLwkB,GAAI,QAEN,CACExkB,IAAK,YACLwkB,GAAI,SC5PNC,GAAY,CACd1iB,OAAQ,CAAC,OACTG,MAAO,CAAC,QACRN,WAAY,CACV,MACA,MACA,OACA,OACA,OACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,KACA,MACA,MACA,MACA,MAEFE,UAAW,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAC1CE,aAAc,CACZ,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,OACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,KACA,UAIJyiB,GAAY3nB,OAAOC,KAAK0nB,IAAW9lB,QAAO,SAACjD,EAAGG,UAC5C4oB,GAAU5oB,GAAGmB,SAAQ,SAAA7B,UAAMO,EAAEP,GAAKU,KAC3BH,IACN,IC9EG8a,GAAa,CACjBf,MCRe,CACfiP,SAAU,UACVC,KAAM,QACNC,OAAQ,UACRC,QAAS,SACTC,SAAU,WACVC,QAAS,WACTC,SAAU,aACVC,QAAS,WACTC,KAAM,OACNC,SAAU,UACVC,SAAU,WACVC,KAAM,QACNC,IAAK,QACLC,OAAQ,QACRC,QAAS,WACTC,MAAO,WACPC,OAAQ,WACRC,QAAS,UACTC,OAAQ,UACRC,UAAW,WACXC,WAAY,YACZC,SAAU,YACVC,KAAM,OACNC,UAAW,YACXC,KAAM,SACNC,QAAS,YACTC,MAAO,SACPC,KAAM,OACNC,QAAS,WACTC,OAAQ,QACRC,MAAO,SACPC,MAAO,QACPC,KAAM,QACNC,aAAc,cACd1mB,MAAO,UACP2mB,MAAO,SACPC,KAAM,SACNC,SAAU,WACVC,KAAM,SACNC,IAAK,MACLC,OAAQ,WACRC,WAAY,YACZC,QAAS,SACTC,SAAU,aACVC,MAAO,OACPC,KAAM,QACNC,OAAQ,UACRC,QAAS,SACTC,QAAS,SACTC,KAAM,QACNC,KAAM,MACNC,GAAI,OACJC,YAAa,cACbC,OAAQ,SACRC,WAAY,YACZC,UAAW,YACXC,KAAM,UACNC,OAAQ,QACRC,WAAY,YACZC,MAAO,SACPC,IAAK,QACLC,KAAM,QACNC,SAAU,YACVC,SAAU,UACVC,QAAS,WACTC,SAAU,UACVC,SAAU,WACVC,QAAS,WACTC,OAAQ,SACRC,MAAO,UACPC,MAAO,QACPC,QAAS,WACTC,OAAQ,UACRC,SAAU,aDjEVxT,MAAOtR,IAIH7C,GAAa,CACjB+U,UAAWjS,GACXkS,WAAYjS,GACZ8R,SAAU7R,GACV9C,WAAY4I,GACZlI,aEDmB,SAASxH,EAAK0G,EAAOQ,OACnClH,QACI,OAG+B,IAApC0G,EAAMkJ,MAAMhK,eAAe5F,WACzBwuB,EAAS9nB,EAAMmV,WAAWd,MAC1B3Y,EAAOD,OAAOC,KAAKosB,GACdtuB,EAAI,EAAGA,EAAIkC,EAAK9B,OAAQJ,YAC3B6b,EAAQ5Z,OAAOC,KAAKosB,EAAOpsB,EAAKlC,KAC3BoB,EAAI,EAAGA,EAAIya,EAAMzb,OAAQgB,OAC5BtB,IAAQwuB,EAAOpsB,EAAKlC,IAAI6b,EAAMza,WACzBc,EAAKlC,OAOpBgH,EAAQA,GAnCS,SAASlH,OACtByuB,EAAQzuB,EAAIuK,OAAOvK,EAAIM,OAAS,OACA,IAAhCouB,GAAM9oB,eAAe6oB,UAChBC,GAAMD,OAEXE,EAAM3uB,EAAIuK,OAAOvK,EAAIM,OAAS,UACA,IAA9BouB,GAAM9oB,eAAe+oB,GAChBD,GAAMC,GAGH,MADF3uB,EAAIuK,OAAOvK,EAAIM,OAAS,GAEzB,eAEF,KAsBUsuB,CAAW5uB,KACf2pB,GAAMziB,OACZ,IAAIhH,EAAI,EAAGA,EAAIypB,GAAMziB,GAAO5G,OAAQJ,IAAK,KACtC2uB,EAAOlF,GAAMziB,GAAOhH,OACC,IAAvB2uB,EAAKxpB,IAAI1C,KAAK3C,UACTA,EAAIiD,QAAQ4rB,EAAKxpB,IAAKwpB,EAAKhF,WAIjC7pB,IFxBL2K,IAAY,EAGVmkB,qCAGF3sB,OAAO6R,eAAe1P,KAAM,QAAS,CACnC2P,YAAY,EACZE,MAAO8G,GACP/G,UAAU,IAEZ/R,OAAO6R,eAAe1P,KAAM,cAAe,CACzC2P,YAAY,EACZE,MAAO,GACPD,UAAU,IAEZ/R,OAAO6R,eAAe1P,KAAM,aAAc,CACxC2P,YAAY,EACZE,MAAO0H,GACP3H,UAAU,IAEZ/R,OAAO6R,eAAe1P,KAAM,OAAQ,CAClC2P,YAAY,EACZE,MAAOhS,OAAOmH,OAAO,GAAIylB,IACzB7a,UAAU,IAEZ/R,OAAO6R,eAAe1P,KAAM,aAAc,CACxC2P,YAAY,EACZE,MAAOvN,GACPsN,UAAU,IAGZ/R,OAAO6R,eAAe1P,KAAM,UAAW,CACrC2P,YAAY,EACZE,MAAO,GACPD,UAAU,SAGP8a,YAAYC,SAEZC,gBAGL/sB,OAAO6R,eAAe1P,KAAM,QAAS,CACnC2P,YAAY,EACZE,MAAO,CACL1L,cAAenE,KAAK6qB,SAAS,6DAM3BC,UACNzkB,GAAYykB,EACL9qB,gDAGAqG,oCAIA5E,WACHsV,EAAM/W,KAAKsL,MACXR,EAAM,GACNQ,EAAQzN,OAAOC,KAAKiZ,GACfnb,EAAI,EAAGA,EAAI0P,EAAMtP,OAAQJ,IACH,iBAAlBmb,EAAIzL,EAAM1P,IACfmb,EAAIzL,EAAM1P,MAAQ6F,IACpBqJ,EAAIQ,EAAM1P,KAAM,GAETmb,EAAIzL,EAAM1P,IAAIoG,MAAK,SAAA3E,UAAKA,IAAMoE,OACvCqJ,EAAIQ,EAAM1P,KAAM,UAGbkP,sCAIGiM,WACNrV,EAAO7D,OAAOC,KAAKiZ,GACdnb,EAAI,EAAGA,EAAI8F,EAAK1F,OAAQJ,YAC3B0P,EAAQzN,OAAOC,KAAKitB,GAAOhU,EAAIrV,EAAK9F,MAC/B4B,EAAI,EAAGA,EAAI8N,EAAMtP,OAAQwB,IAChCwtB,GAAe1f,EAAM9N,GAAIkE,EAAK9F,GAAIoE,KAAKsL,OAEvC0f,GAAe1f,EAAM9N,GAAIkE,EAAK9F,GAAIoE,uCAK/B8G,WACHhJ,EAAOD,OAAOC,KAAKgJ,GACdlL,EAAI,EAAGA,EAAIkC,EAAK9B,OAAQJ,IAAK,KAChC+D,EAAO7B,EAAKlC,GAAG4C,cACnBwsB,GAAerrB,EAAMmH,EAAIhJ,EAAKlC,IAAKoE,KAAKsL,OAExC0f,GAAerrB,EAAMmH,EAAIhJ,EAAKlC,IAAKoE,sDAKrC4qB,GAAc5qB,MACPA,qCAID0B,UACNA,EAAO7D,OAAOmH,OAAO,GAAItD,QACpBA,KAAO7D,OAAOmH,OAAOhF,KAAK0B,KAAMA,QAEhCA,KAAOupB,GAAYjrB,KAAK0B,MACtB1B,yCAGGkrB,eACLC,QAAQvjB,KAAKsjB,GACXlrB,2CAKA,CACLsL,MAAOzN,OAAOC,KAAKkC,KAAKsL,OAAOtP,OAC/BovB,QAASvtB,OAAOC,KAAKkC,KAAKuX,WAAWf,OAAOxa,OAC5Cuc,aAAc1a,OAAOC,KAAKkC,KAAKuX,WAAWd,OAAOza,OACjDqvB,UAAWxtB,OAAOC,KAAKkC,KAAKiX,aAAajb,OACzCsvB,eAAgBtrB,KAAKmrB,QAAQnvB,iBAM7BoL,GAAQ,SAASN,UACdykB,KAAKC,MAAMD,KAAKE,UAAU3kB,KAInC0jB,GAAMrjB,UAAUC,MAAQ,eAClBskB,EAAK,IAAIlB,UAEbkB,EAAGpgB,MAAQzN,OAAOmH,OAAO,GAAIhF,KAAKsL,OAClCogB,EAAGzU,YAAcpZ,OAAOmH,OAAO,GAAIhF,KAAKiX,aAExCyU,EAAGnU,WAAanQ,GAAMpH,KAAKuX,YAC3BmU,EAAGhqB,KAAO0F,GAAMpH,KAAK0B,MAErBgqB,EAAGppB,WAAatC,KAAKsC,WACrBopB,EAAGP,QAAUnrB,KAAKmrB,QACXO,GAET,OAAiBlB,uBG7KjBzqB,MAAc,kBACLC,KAAK4J,UAAU,IAAM5J,MAI9BD,SAAiB,kBACXC,KAAK2rB,KACA3rB,KAAK2rB,KAEP3rB,MAITD,UAAkB,SAAShD,OACrBqN,EAAM,UACQ,SAAZwhB,EAAqB3iB,GACrBA,EAAI0iB,OACNvhB,EAAIxC,KAAKqB,EAAI0iB,MACbC,EAAU3iB,EAAI0iB,OAGlBC,CAAU5rB,MACVoK,EAAMA,EAAIyD,UACO,iBAAN9Q,EACFqN,EAAIrN,GAENqN,GAITrK,QAAgB,SAAS8rB,OACnBtiB,EAAOvJ,KAAKuJ,KAAKvB,KAAI,SAAAgH,UAAMA,EAAG5H,MAAMykB,aAC9B7rB,KAAK8H,UAAUyB,IAK3BxJ,YAAoB,kBACXC,KAAKuJ,KAAK7J,QAAO,SAAC+L,EAAOxO,UAC9BwO,GAASxO,EAAE6uB,cAEV,IAEL/rB,YAAoBA,EAAQ+rB,UAW5B/rB,QAAgB,SAASsD,qBACvBA,EAAUA,GAAW,QAChBkG,KAAKxL,SAAQ,SAAAd,OACZqO,EAAQ,GACZrO,EAAEsK,MAAQtK,EAAEsK,OAAS,GACrBtK,EAAEsK,MAAMC,MAAQvK,EAAEsK,MAAMC,OAASvK,EAAEuK,QAEnCvK,EAAEsK,MAAMC,MAAMzJ,SAAQ,SAAAV,GACpBiO,EAAMjO,EAAEiC,QAAS,EACjBgM,EAAMjO,EAAEoC,UAAW,EACnB6L,EAAMjO,EAAE1B,KAAK6C,gBAAiB,EAC1BnB,EAAEuD,WACJ0K,EAAMjO,EAAEuD,WAAY,GAElBvD,EAAEmE,OACJ8J,EAAMjO,EAAEmE,OAAQ,QAEFH,IAAZhE,EAAEuC,QACJ0L,EAAQzN,OAAOmH,OAAOsG,EAAOjO,EAAEuC,QAE7ByD,EAAQ7B,OACVnE,EAAE0uB,QAAQ9jB,EAAK7F,OACfkJ,EAAMjO,EAAEmE,OAAQ,aAGb8J,EAAM,IACbrO,EAAEsK,MAAM+D,MAAQA,KAEXtL,MAITD,UAAkB,uBACXwJ,KAAKxL,SAAQ,SAAAd,GAChBA,EAAEsK,MAAQ,WAGPqC,UAAU7L,SAAQ,SAAAkL,GACrBA,EAAIM,KAAKxL,SAAQ,SAAAd,GACfA,EAAEsK,MAAQ,SAGPvH,iHChGTD,QAAgB,SAAShD,eACbsE,IAANtE,EACKiD,KAAK0H,IAAI,GAEX1H,KAAK6K,MAAM,EAAG9N,IAIvBgD,OAAe,SAAShD,WACZsE,IAANtE,SACKiD,KAAK0H,IAAI1H,KAAKuJ,KAAKvN,OAAS,OAEjCoF,EAAMpB,KAAKuJ,KAAKvN,cACbgE,KAAK6K,MAAMzJ,EAAMrE,EAAGqE,IAI7BrB,QAAgB,SAASoB,EAAOC,OAC1BmI,EAAOvJ,KAAKuJ,KAAKsB,MAAM1J,EAAOC,UAC3BpB,KAAK8H,UAAUyB,IAIxBxJ,KAAa,SAAShD,OAChBE,EAAI+C,KAAKuJ,KAAKxM,eACRsE,IAANpE,EACK+C,KAAK8H,UAAU,IAEjB9H,KAAK8H,UAAU,CAAC7K,KAEzB8C,MAAcA,EAAQisB,GAGtBjsB,YAAoB,kBACXC,KAAK+I,MAAM,OAGpBhJ,WAAmB,kBACVC,KAAK+I,MAAM,OAIpBhJ,WAAmB,SAASksB,WACtB7hB,EAAM,GAEDxO,EAAI,EAAGA,EAAIoE,KAAKuJ,KAAKvN,OAAQJ,YAChC4L,EAAQxH,KAAKuJ,KAAK3N,GAAG4L,QAChBxK,EAAI,EAAGA,EAAIwK,EAAMxL,OAAQgB,OAChCoN,EAAIxC,KAAKJ,EAAMxK,SAEHqE,IAAR4qB,QAAkC5qB,IAAb+I,EAAI6hB,UACpB7hB,EAAI6hB,UAIV7hB,GAwCTrK,SAAiB,SAASmsB,eACT7qB,IAAX6qB,EArCe,SAASjjB,WACxB6B,EAAM,GACJ+D,EAAS,GACNjT,EAAI,EAAGA,EAAIqN,EAAIM,KAAKvN,OAAQJ,YAC7BqO,EAAShB,EAAIM,KAAK3N,GAClBkT,EAAQjR,OAAO6Y,OAAOzM,EAAO6E,OAC1BnS,EAAI,EAAGA,EAAImS,EAAM9S,OAAQW,IAAK,OACJmS,EAAMnS,GAA/BuP,IAAAA,MAAO/K,IAAAA,MAAOnF,IAAAA,OACjB6S,EAAO3C,KACV2C,EAAO3C,GAAS,IAElB2C,EAAO3C,GAAOtE,KAAKqC,EAAOnC,UAAU3G,EAAOnF,YAGzC8B,EAAOD,OAAOC,KAAK+Q,GAChBjT,EAAI,EAAGA,EAAIkC,EAAK9B,OAAQJ,IAAK,KAC9Bsa,EAAMpY,EAAKlC,GACjBkP,EAAIoL,GAAOjN,EAAInB,UAAU+G,EAAOqH,WAE3BpL,EAmBEqhB,CAAansB,OAEA,iBAAXksB,IACTA,EAASrlB,OAAOqlB,IAnBD,SAASjjB,EAAK+U,WACzB5T,EAAM,cACHxO,OACDqO,EAAShB,EAAIM,KAAK3N,GACpBkC,EAAOD,OAAOC,KAAKmM,EAAO6E,QAC9BhR,EAAOA,EAAKsK,QAAO,SAAAnH,UAAMgJ,EAAO6E,MAAM7N,GAAIiL,QAAU8R,MAC/CjgB,SAAQ,SAAAkD,GACXmJ,EAAIxC,KAAKqC,EAAOnC,UAAUmC,EAAO6E,MAAM7N,GAAIE,MAAO8I,EAAO6E,MAAM7N,GAAIjF,aAL9DJ,EAAI,EAAGA,EAAIqN,EAAIM,KAAKvN,OAAQJ,MAA5BA,UAQFqN,EAAInB,UAAUsC,GAWdgiB,CAAWpsB,KAAMksB,IAAWlsB,KAAK8H,UAAU,MAEpD/H,QAAgBA,EAAQssB,OACxBtsB,QAAgBA,EAAQssB,wICvGxBtsB,QAAgB,SAASgB,OAEnBiK,EAAOshB,GAAYvrB,MACH,IAAhBiK,EAAKhP,cACAgE,KAAK8H,UAAU,QAGpB8E,EAAU5M,KAAKuJ,KAAK7J,QAAO,SAAC0K,EAAKnN,UAC5BmN,EAAIT,OAAO1M,EAAE8L,MAAMiC,MACzB,WACIhL,KAAK8H,UAAU8E,IAIxB7M,MAAc,SAASgB,OAEjBiK,EAAOshB,GAAYvrB,MAEH,IAAhBiK,EAAKhP,cACAgE,SAGL4M,EAAU5M,KAAKuJ,KAAK7J,QAAO,SAAC0K,EAAKnN,UAC5BmN,EAAIT,OAAO1M,EAAEsvB,IAAIvhB,MACvB,WACIhL,KAAK8H,UAAU8E,IAIxB7M,WAAmB,SAASgB,WACtBiK,EAAOshB,GAAYvrB,GACdnF,EAAI,EAAGA,EAAIoE,KAAKuJ,KAAKvN,OAAQJ,IAAK,KACrCmN,EAAQ/I,KAAKuJ,KAAK3N,GAAGmN,MAAMiC,GAAM,UAC9BhL,KAAK8H,UAAUiB,UAEjB/I,KAAK8H,UAAU,KAIxB/H,KAAa,SAASgB,OAChBiK,EAAOshB,GAAYvrB,GACnB3B,EAAQY,KAAKuJ,KAAKnB,QAAO,SAAAnL,UAAqB,IAAhBA,EAAEuvB,IAAIxhB,aACjChL,KAAK8H,UAAU1I,IAIxBW,OAAe,SAASgB,OAClBiK,EAAOshB,GAAYvrB,GACnB3B,EAAQY,KAAKuJ,KAAKnB,QAAO,SAAAnL,UAAqB,IAAhBA,EAAEuvB,IAAIxhB,aACjChL,KAAK8H,UAAU1I,IAIxBW,MAAc,SAASgB,OACjBiK,EAAOshB,GAAYvrB,UAChBf,KAAKuJ,KAAKvH,MAAK,SAAA/E,UAAqB,IAAhBA,EAAEuvB,IAAIxhB,OAInCjL,YAAoB,SAASgB,GAEtBA,IACHA,EAAM,UAEJiK,EAAOshB,GAAYvrB,GACnB6L,EAAU,eACTrD,KAAKxL,SAAQ,SAAAd,GAChB2P,EAAUA,EAAQjD,OAAO1M,EAAEwvB,UAAUzhB,OAEvC4B,EAAUA,EAAQxE,QAAO,SAAAnL,UAAKA,KACvB+C,KAAK8H,UAAU8E,IAExB7M,YAAoBA,EAAQ0sB,UAG5B1sB,aAAqB,SAASgB,GAEvBA,IACHA,EAAM,UAEJiK,EAAOshB,GAAYvrB,GACnB6L,EAAU,eACTrD,KAAKxL,SAAQ,SAAAd,GAChB2P,EAAUA,EAAQjD,OAAO1M,EAAEyvB,WAAW1hB,OAExC4B,EAAUA,EAAQxE,QAAO,SAAAnL,UAAKA,KACvB+C,KAAK8H,UAAU8E,IAExB7M,aAAqBA,EAAQ2sB,WAG7B3sB,SAAiB,SAASgB,OACpBiK,EAAOshB,GAAYvrB,GAGnB4rB,EADU3sB,QAAQgL,GAAMzB,KACNvB,KAAI,SAAA/K,OACpBmR,EAAMnR,EAAEuK,QAAQQ,KAAI,SAAA3K,UAAKA,EAAE4D,MAE3BnE,EAAIG,EAAE8L,MAAMiC,GAAM,GAClBhK,EAAQoN,EAAI9N,QAAQxD,EAAEqE,cAEZ,IAAVH,IAA0B,IAAXA,EACV,KAEF/D,EAAE6K,UAAU7K,EAAEkE,MAAOH,aAE9B2rB,EAAUA,EAAQvkB,QAAO,SAAAnL,UAAW,OAANA,KACvB+C,KAAK8H,UAAU6kB,IAIxB5sB,QAAgB,SAASgB,OACnBiK,EAAOshB,GAAYvrB,GAGnB4rB,EADU3sB,QAAQgL,GAAMzB,KACNvB,KAAI,SAAA/K,OACpBuK,EAAQvK,EAAEuK,QACV4G,EAAM5G,EAAMQ,KAAI,SAAA3K,UAAKA,EAAE4D,MAEvBnE,EAAIG,EAAE8L,MAAMiC,GAAM,GAClBhK,EAAQoN,EAAI9N,QAAQxD,EAAEqE,WAEX,IAAXH,IAAiBwG,EAAMxG,EAAQlE,EAAEd,eAC5B,SAGLiF,EAAKuG,EAAMxG,EAAQlE,EAAEd,QAAQiF,GAC7B+U,EAAM/Y,EAAEjB,OAASgF,EAAQlE,EAAEd,cACxBiB,EAAE6K,UAAU7G,EAAI+U,aAEzB2W,EAAUA,EAAQvkB,QAAO,SAAAnL,UAAW,OAANA,KACvB+C,KAAK8H,UAAU6kB,gICrIP,SAASlrB,EAAKwH,EAAK2jB,EAAM/mB,OACpCgnB,EAAU,GACK,iBAARprB,IACTorB,EAAUprB,EAAIhG,MAAM,MAItBwN,EAAIM,KAAKxL,SAAQ,SAAAd,OACXuK,EAAQvK,EAAEsK,MAAMC,OAASvK,EAAEuK,SAElB,IAATolB,IACFplB,EAAQA,EAAMY,QAAO,SAAA/K,UAAKA,EAAEoJ,MAAMhF,EAAKwH,EAAI7G,WAE7CoF,EAAMzJ,SAAQ,SAACV,EAAGzB,GAEZixB,EAAQ7wB,OAAS,EACf6wB,EAAQjxB,IAAqB,MAAfixB,EAAQjxB,IACxByB,EAAEoE,IAAIorB,EAAQjxB,GAAIiK,EAAQoD,EAAI7G,OAIhC/E,EAAEoE,IAAIA,EAAKoE,EAAQoD,EAAI7G,uBCnBjB,SAASV,EAAMorB,UACtBprB,GAGLqrB,GAAOrrB,EAAM1B,MAAM,EAAO8sB,GACnB9sB,MAHEA,cAOO,SAAS0B,EAAMorB,UAC1BprB,GAGLqrB,GAAOrrB,EAAM1B,MAAM,EAAM8sB,GAClB9sB,MAHEA,YAOK,SAAS0B,EAAMorB,0BACxBvjB,KAAKxL,SAAQ,SAAAd,GAChBA,EAAEuK,QAAQzJ,SAAQ,SAAAV,UAAKA,EAAEkJ,MAAM7E,EAAMorB,EAAK7kB,EAAK7F,aAE1CpC,YAIO,SAASyB,OAClBA,SACIzB,SAELoC,EAAQpC,KAAKoC,MACbwK,EAAU5M,KAAKuJ,KAAK7J,QAAO,SAAC0K,EAAKnN,UAC5BmN,EAAIT,OAAO1M,EAAEwJ,MAAMhF,EAAKW,MAC9B,WACIpC,KAAK8H,UAAU8E,aCpCV,SAASse,kBAChBA,SACIlrB,SAELuJ,EAAOvJ,KAAKuJ,KAAKvB,KAAI,SAAC/K,EAAGrB,OACvBqN,EAAMhB,EAAKH,UAAU,CAAC7K,IAC1BgM,EAAI0iB,KAAO,SACP7gB,EAAMogB,EAAGjiB,EAAKrN,UACdkP,EAAIvB,MAAQuB,EAAIvB,KAAK,GAChBuB,EAAIvB,KAAK,GAEXuB,YAEW,IAAhBvB,EAAKvN,OACAgE,KAAK8H,UAAUyB,GAGD,WAAnByE,EAAOzE,EAAK,KAAmC,WAAhBA,EAAK,GAAG3E,IAClC2E,EAEFvJ,KAAK8H,UAAUyB,YAIN,SAAS2hB,EAAI8B,qBACxB9B,QAGA3hB,KAAKxL,SAAQ,SAACd,EAAGrB,OAChBqxB,EAAM7d,EAAKtH,UAAU,CAAC7K,KAEL,IAAjB+vB,IACFC,EAAItB,KAAO,MAEbT,EAAG+B,EAAKrxB,MAEHoE,MAVEA,aAcM,SAASkrB,kBACnBA,SACIlrB,SAELuJ,EAAOvJ,KAAKuJ,KAAKnB,QAAO,SAACnL,EAAGrB,OAC1BqN,EAAMuG,EAAK1H,UAAU,CAAC7K,WAC1BgM,EAAI0iB,KAAO,KACJT,EAAGjiB,EAAKrN,aAEVoE,KAAK8H,UAAUyB,SAIT,SAAS2hB,kBACjBA,SACIlrB,SAELiK,EAASjK,KAAKuJ,KAAKc,MAAK,SAACpN,EAAGrB,OAC1BqN,EAAMikB,EAAKplB,UAAU,CAAC7K,WAC1BgM,EAAI0iB,KAAO,KACJT,EAAGjiB,EAAKrN,aAEbqO,EACKjK,KAAK8H,UAAU,CAACmC,iBAMZ,SAASihB,qBACjBA,EAGElrB,KAAKuJ,KAAKvH,MAAK,SAAC/E,EAAGrB,OACpBqN,EAAMkkB,EAAKrlB,UAAU,CAAC7K,WAC1BgM,EAAI0iB,KAAO,KACJT,EAAGjiB,EAAKrN,MALRoE,aAUM,SAASjD,OACnBiD,KAAKZ,aACDY,SAEL7C,EAAItB,KAAKC,MAAMD,KAAKE,SAAWiE,KAAKuJ,KAAKvN,gBACnCqF,IAANtE,EAAiB,KACfwM,EAAO,CAACvJ,KAAKuJ,KAAKpM,WACf6C,KAAK8H,UAAUyB,UAGpBpM,EAAIJ,EAAIiD,KAAKhE,SAEfmB,GADAA,EAAI6C,KAAKhE,OAASe,GACV,EAAI,EAAII,GAEX6C,KAAK6K,MAAM1N,EAAGA,EAAIJ,6BC7FrB+D,EAAY,SAAS0D,EAAM9I,SACnB,KAARA,IAGG8I,EAAK/E,UAAY/D,GAAO8I,EAAK5D,WAAalF,GAAO8I,EAAKhD,OAAS9F,GAAO8I,EAAK7I,KAAK6C,gBAAkB9C,IAiB3GqE,SAAiB,SAASqK,cACL,iBAARA,IACTA,EAAM,CAACA,QAELgjB,EAAUhjB,EAAIpC,KAAI,SAAAtM,GACpBA,EAAMA,EAAI8C,kBACN8M,EAAQ+hB,GAAS3xB,UACrB4P,EAAQA,EAAMtD,KAAI,SAAA5K,UAAKA,EAAEqB,kBAGtB8I,YACDnI,EAAQ,UAEZguB,EAAQrvB,SAAQ,SAAA7B,GAEd+L,EAAKsB,KAAKxL,SAAQ,SAAAd,OAEY,IAAxBA,EAAEsK,MAAM+D,MAAMpP,EAAE,SAIhBsL,EAAQvK,EAAEuK,QACVvG,EAnCQ,SAASmJ,EAAK5C,sBAErB5L,MACHkF,EAAU0G,EAAM5L,GAAIwO,EAAI,KACtBA,EAAIrI,OAAM,SAAC7F,EAAGa,UAAMyK,EAAM5L,EAAImB,KAAqC,IAA/B+D,EAAU0G,EAAM5L,EAAImB,GAAIb,eACvDsL,EAAM5L,GAAGqF,KAHbrF,EAAI,EAAGA,EAAI4L,EAAMxL,OAAQJ,IAAK,SAA9BA,wCAOF,EA0BM0xB,CAAUpxB,EAAGsL,OACX,IAAPvG,YAEEgJ,EAAShN,EAAE6K,UAAU7G,EAAI/E,EAAEF,QAC/BoD,EAAMwI,KAAKqC,WAKVjK,KAAK8H,UAAU1I,IAExBW,SAAiBA,EAAQwtB,UCvDnB1tB,wBAAY,SAAAnE,UACTA,EAAIsK,OAAO,GAAG/F,cAAgBvE,EAAIuK,OAAO,qBAI5B,SAAStH,cAAS0E,yDAAU,UAC3C1E,IAIW,IAAZ0E,IACFA,EAAU,CAAEmqB,UAAU,KAER,IAAZnqB,IACFA,EAAU,CAAEmqB,UAAU,IAExBnqB,EAAUA,GAAW,QAGhBoqB,eAEAlkB,KAAKxL,SAAQ,SAAAd,OAMZywB,EALA3f,EAAQpP,KAEW,mBAAZA,IACToP,EAAQpP,EAAQ1B,IAId8Q,GAA0B,WAAjBC,EAAOD,IAAoC,QAAdA,EAAMnJ,IAC9C8oB,EAAa3f,EAAMxE,KACnBtB,EAAKR,OAAOkmB,MAAM5f,EAAMtG,YACnB,CAAA,GAAqB,iBAAVsG,UAES,IAArB1K,EAAQuqB,UAAsB3wB,EAAEuK,MAAM,GAAGtH,gBAC3C6N,EAAQlO,GAAUkO,IAEpB2f,EAAaL,GAAStf,EAAO9F,EAAK7F,MAAO6F,EAAKR,QAEjCQ,EAAKH,UAAU4lB,GACrBG,aAMgB,IAArBxqB,EAAQmqB,SAAmB,KACzBM,EAAU7wB,EAAE8N,KAAK,CAAEvD,MAAO,CAAE9F,MAAM,KAAU8F,MAChDkmB,EAAW,GAAGlmB,QAAQzJ,SAAQ,SAACV,EAAGzB,GAC5BkyB,EAAQlyB,IACVyB,EAAE0wB,QAAQD,EAAQlyB,GAAG8F,KAAM,UAAWuG,EAAK7F,UAIjDnF,EAAE0B,QAAQ+uB,EAAW,GAAIzlB,MAEpBjI,MAjDEA,uBAqDO,SAAS+I,EAAOpK,EAAS0E,eAEzBhC,IAAZ1C,EACKqB,KAAKguB,YAAYjlB,EAAO1F,SAE5B0F,MAAMA,GAAOilB,YAAYrvB,EAAS0E,GAChCrD,4BCjETD,SAAiB,SAASrE,qBACnBA,QAIA+xB,eAEAlkB,KAAKxL,SAAQ,SAAAd,OAEZgN,EAASojB,GAAS3xB,EAAKuM,EAAK7F,MAAO6F,EAAKR,QAAQ,GAEvCQ,EAAKH,UAAU,CAACmC,IACtB4jB,SAEP5wB,EAAEsN,OAAON,EAAQhC,MAEZjI,MAdEA,MAgBXD,cAAsBA,EAAQwK,OAC9BxK,WAAmBA,EAAQwK,OAG3BxK,UAAkB,SAASrE,qBACpBA,QAIA+xB,eAEAlkB,KAAKxL,SAAQ,SAAAd,OAEZgN,EAASojB,GAAS3xB,EAAK0T,EAAKhN,MAAOgN,EAAK3H,QAAQ,GAEvC2H,EAAKtH,UAAU,CAACmC,IACtB4jB,SAEP5wB,EAAEuN,QAAQP,EAAQmF,MAEbpP,MAdEA,MAgBXD,eAAuBA,EAAQyK,QAG/BzK,SAAiB,gBAEV0tB,kBACDlkB,EAAOvJ,KAAKuJ,KAAKsB,MAAM,GAElBjP,EAAI,EAAGA,EAAIqyB,UAAUjyB,OAAQJ,IAAK,KACrCsyB,EAAMD,UAAUryB,MAED,iBAARsyB,EAAkB,KACvB9jB,EAAMijB,GAASa,EAAKluB,KAAKoC,OAE7BmH,EAAOA,EAAKI,OAAOS,OACE,QAAZ8jB,EAAItpB,IACb2E,EAAOA,EAAKI,OAAOukB,EAAI3kB,MACF,WAAZ2kB,EAAItpB,KACb2E,EAAK3B,KAAKsmB,UAGPluB,KAAK8H,UAAUyB,IAIxBxJ,SAAiB,SAASgJ,mBAEnB0kB,cACDU,EAAWnuB,YACX+I,IACFolB,EAAWnuB,KAAK+I,MAAMA,IAExBolB,EAAS5kB,KAAKxL,SAAQ,SAAAkM,UAAUA,SAAcuF,MACvCxP,MAGTD,SAAiBA,YC/EXquB,wFAAa,CACjB9uB,OAAO,EACPG,SAAS,EACT+B,MAAM,aAIO,SAAS6B,cACtBA,EAAUA,GAAW,OAEjBgrB,GAAW,EACe,IAA1BruB,KAAK4J,UAAU5N,SACjBqyB,GAAW,IAGG,SAAZhrB,GAA0C,WAAnB2K,EAAO3K,IAAwBA,EAAQ7B,YAC3D+H,KAAKxL,SAAQ,SAAAd,GAChBA,EAAEuK,QAAQzJ,SAAQ,SAAAV,GACD,OAAXA,EAAEmE,MACJnE,EAAE0uB,QAAQ9jB,EAAK7F,iBAMnBksB,EAAMtuB,KAAKuJ,KAAK7J,QAAO,SAAChE,EAAKuB,EAAGrB,OAC5B2yB,GAAWF,GAAkB,IAANzyB,EACvB4yB,GAAYH,GAAYzyB,IAAMqM,EAAKsB,KAAKvN,OAAS,SAChDN,EAAMuB,EAAEtB,KAAK0H,EAASkrB,EAASC,KACrC,WAGyB,IAAxBJ,GAAW/qB,KAAyC,IAApBA,EAAQ5D,UAAsC,IAAlB4D,EAAQ/D,QAAmC,IAAjB+D,EAAQ7B,OAChG8sB,EAAMA,EAAI7vB,QAEL6vB,OClBU,SAASrlB,EAAKhH,EAAQoB,OAEnCorB,EAlBc,SAASxlB,OACvBylB,EAAU,EACV1tB,EAAQ,EACRytB,EAAU,UACdxlB,EAAI0lB,WAAW5wB,SAAQ,SAAAyG,GACrBiqB,EAAQjqB,EAAKvD,IAAM,CACjBD,MAAOA,EACPG,MAAOutB,EAAUlqB,EAAKtF,IAAIlD,OAC1BA,OAAQwI,EAAK7I,KAAKK,QAEpB0yB,GAAWlqB,EAAKtF,IAAIlD,OAASwI,EAAK7I,KAAKK,OAASwI,EAAKrF,KAAKnD,OAC1DgF,GAAS,KAEJytB,EAKOG,CAAY3lB,EAAIgC,QAE1B5H,EAAQmE,MAAMxG,OAASqC,EAAQrC,QACjCiB,EAAOlE,SAAQ,SAAAf,GACbA,EAAEwK,MAAMzJ,SAAQ,SAAAV,GACdA,EAAE2D,MAAQytB,EAAQpxB,EAAE4D,IAAID,SAE1BhE,EAAEgE,MAAQhE,EAAEwK,MAAM,GAAGxG,UAIrBqC,EAAQmE,MAAM1C,QAAUzB,EAAQyB,SAClC7C,EAAOlE,SAAQ,SAAAf,GACbA,EAAEwK,MAAMzJ,SAAQ,SAAAV,GACdA,EAAEyH,OAAS2pB,EAAQpxB,EAAE4D,KAAO,MAQ9BjE,EAAE8H,OAAS9H,EAAEwK,MAAM,GAAG1C,OACtB9H,EAAE8H,OAAO9I,OAASgB,EAAErB,KAAKK,mCCzCzB6yB,EAAe,CAAElzB,MAAM,EAAM6L,OAAO,EAAM/I,MAAM,GAGhDqwB,EAAa,SAASzrB,UAC1BA,EAAUxF,OAAOmH,OAAO,GAAI6pB,EAAcxrB,IAE9B4S,SACV5S,EAAQ5D,SAAU,GAGhB4D,EAAQyB,SACVzB,EAAQ1H,MAAO,EACV0H,EAAQmE,QAA2B,IAAlBnE,EAAQmE,QAC5BnE,EAAQmE,MAAQ,IAElBnE,EAAQmE,MAAM1C,QAAS,IAErBzB,EAAQrC,OAASqC,EAAQmE,MAAMxG,SACjCqC,EAAQmE,OAA0B,IAAlBnE,EAAQmE,MAAiB,GAAKnE,EAAQmE,MACtDnE,EAAQmE,MAAMvG,IAAK,GAEdoC,GAITtD,OAAe,sBAASsD,yDAAU,MAET,iBAAZA,GAAwBrD,KAAKuJ,KAAKlG,UACpCrD,KAAKuJ,KAAKlG,GAAS0H,KAAK8jB,IAMZ,KAHrBxrB,EAAUyrB,EAAWzrB,IAGT7B,WACL+H,KAAKxL,SAAQ,SAAAd,GAChBA,EAAEuK,QAAQzJ,SAAQ,SAAAV,GACD,OAAXA,EAAEmE,MACJnE,EAAE0uB,QAAQ9jB,EAAK7F,iBAMnBH,EAASjC,KAAKuJ,KAAKvB,KAAI,SAAA/K,UAClBA,EAAE8N,KAAK1H,EAAS4E,EAAK7F,cAG1BiB,EAAQmE,MAAM1C,QAAUzB,EAAQyB,QAAUzB,EAAQmE,MAAMxG,OAASqC,EAAQrC,QAC3EytB,GAAQzuB,KAAMiC,EAAQoB,GAGpBA,EAAQ0rB,WAAa1rB,EAAQ2rB,MAAQ3rB,EAAQoI,MAAO,KAClD3E,EAAM,QACLyC,KAAKxL,SAAQ,SAAAd,OACZvB,EAAMuB,EAAEtB,KAAK,WACjBmL,EAAIpL,GAAOoL,EAAIpL,IAAQ,EACvBoL,EAAIpL,IAAQ,UAET6N,KAAKxL,SAAQ,SAACd,EAAGrB,GACpBqG,EAAOrG,GAAG6P,MAAQ3E,EAAI7J,EAAEtB,KAAK,kBAI7B0H,EAAQ4S,OAAQ,KACdgZ,EAAU,GACdhtB,EAASA,EAAOmG,QAAO,SAAApL,UACM,IAAvBiyB,EAAQjyB,EAAEyC,WAGdwvB,EAAQjyB,EAAEyC,UAAW,GACd,aAGJwC,GAITlC,OAAeA,EAAQgL,+CC1EjBrF,EAAS,SAAShK,EAAKiK,OAC3BjK,EAAMA,EAAIkK,WACHlK,EAAIM,OAAS2J,GAClBjK,GAAO,WAEFA,OAQHwzB,EAAM,CACVxK,MAAO,UACPE,IAAK,UACLuK,KAAM,UACNC,QAAS,UACTC,KAAM,UACN1K,OAAQ,UACR2K,MAAO,WA2BHC,EAAM,CACV7K,MAAO,SAAShpB,SACP,QAAaA,EAnDV,QAqDZkpB,IAAK,SAASlpB,SACL,QAAaA,EAtDV,QAwDZyzB,KAAM,SAASzzB,SACN,QAAaA,EAzDV,QA2DZ0zB,QAAS,SAAS1zB,SACT,QAAaA,EA5DV,QA8DZ2zB,KAAM,SAAS3zB,SACN,QAAaA,EA/DV,QAiEZipB,OAAQ,SAASjpB,SACR,QAAaA,EAlEV,QAoEZ4zB,MAAO,SAAS5zB,SACP,QAAaA,EArEV,SAyER8zB,EAAY,SAAS9tB,UACzBA,EAAOA,EAAKsG,KAAI,SAAAvG,OACT0E,GAAO7E,eAAeG,UAClBA,MAEHrF,EAAI+J,GAAO1E,GAAKsU,OAAS,cACxBwZ,EAAInzB,GAAGqF,OAEJzD,KAAK,OA+BnByxB,UA3Bc,SAASxmB,SA1EI,oBAAXzD,QAA0BA,OAAOC,UAc3B,SAASwD,GAC7BA,EAAIM,KAAKxL,SAAQ,SAAAd,GACf6I,QAAQC,IAAI,QAAU9I,EAAEtB,OAAS,IAAK,oBAC1BsB,EAAEsK,MAAMC,OAASvK,EAAEuK,SACzBzJ,SAAQ,SAAAV,OACRqE,EAAO7D,OAAOC,KAAKT,EAAEqE,MACrB/F,EAAO0B,EAAE1B,MAAQ,IACjB0B,EAAEuD,WACJjF,EAAO,IAAM0B,EAAEuD,SAAW,SAExBjB,EAAO,IAAMhE,EAAO,IACxBgE,EAAO+F,EAAO/F,EAAM,OAChBP,EAAQsC,EAAK2I,MAAK,SAAA5I,UAAO0E,GAAO1E,IAAQ0E,GAAO1E,GAAKsU,SACpDA,EAAQ,YACR5P,GAAO/G,KACT2W,EAAQ5P,GAAO/G,GAAO2W,MACtBA,EAAQmZ,EAAInZ,IAEdjQ,QAAQC,iBAAUpG,oBAAc+B,EAAK1D,KAAK,wBAAmB+X,GAAS,wBA4CxE2Z,CAAczmB,GACPA,IAETnD,QAAQC,IAAIwpB,EAAIJ,KAAK,UACrBlmB,EAAIM,KAAKxL,SAAQ,SAAAd,GACf6I,QAAQC,IAAIwpB,EAAIJ,KAAK,aACTlyB,EAAEsK,MAAMC,OAASvK,EAAEuK,SACzBzJ,SAAQ,SAAAV,OACRqE,EAAO7D,OAAOC,KAAKT,EAAEqE,MACrB/F,EAAO0B,EAAE1B,MAAQ,IACjB0B,EAAEuD,WACJjF,EAAO,IAAM0B,EAAEuD,SAAW,SAKxBjB,EAAO,KAFThE,EAAO4zB,EAAI5K,OAAOhpB,IAEI,IACxBgE,EAAO+F,EAAO/F,EAAM,QAChBjE,EAAM6zB,EAAIJ,KAAK,QAAUxvB,EAAO,OAAS6vB,EAAU9tB,GACvDoE,QAAQC,IAAIrK,SAGhBoK,QAAQC,IAAI,IACLkD,WCjHI,SAASA,OAChBM,EAAON,EAAI8B,KAAK,CAAEpP,MAAM,EAAO6L,OAAO,EAAO/H,SAAS,IAEtDqH,EAAM,GACVyC,EAAKxL,SAAQ,SAAAf,GACN8J,EAAI9J,EAAEyC,WACTzC,EAAEyO,MAAQ,EACV3E,EAAI9J,EAAEyC,SAAWzC,GAEnB8J,EAAI9J,EAAEyC,SAASgM,OAAS,SAEtBrB,EAAMvM,OAAOC,KAAKgJ,GAAKkB,KAAI,SAAApL,UAAKkK,EAAIlK,aAExCwN,EAAI1F,MAAK,SAACxI,EAAGC,UACPD,EAAEuP,MAAQtP,EAAEsP,OACN,EACCvP,EAAEuP,MAAQtP,EAAEsP,MACd,EAEF,KAEFrB,aCjBO,kBACdulB,GAAM3vB,MACCA,UAIK,SAAS2B,MACN,SAAXA,SACK3B,KAAKrE,UAEC,WAAXgG,SACK3B,KAAKrE,KAAK,aAEJ,SAAXgG,SACK3B,KAAK+K,UAEC,WAAXpJ,GAAkC,YAAXA,SAClB3B,KAAK+K,KAAK,CAAEjG,QAAQ,OAEd,UAAXnD,SACK3B,KAAK+K,KAAK,CAAEvD,OAAO,IAASQ,KAAI,SAAAlB,UAAOA,EAAInL,WAErC,SAAXgG,GAAgC,cAAXA,SAChBiuB,GAAK5vB,SAEC,UAAX2B,EAAoB,KAClB4H,EAAO,eACNwB,KAAK,CAAEpP,MAAM,EAAO6L,MAAO,CAAE7L,MAAM,KAAUoC,SAAQ,SAAA+I,OACpDU,EAAQV,EAAIU,MAAMQ,KAAI,SAAA3K,UAAKA,EAAE1B,QACjC6L,EAAQA,EAAMY,QAAO,SAAA/K,UAAKA,KAC1BkM,EAAOA,EAAKI,OAAOnC,MAEd+B,QAEM,SAAX5H,EACK3B,KAAKuJ,KAAKvB,KAAI,SAAA/K,UACZA,EAAEuK,QAAQ9H,QAAO,SAACjD,EAAGY,UAC1BZ,EAAEY,EAAEiC,OAASjC,EAAEuD,UAAY/C,OAAOC,KAAKT,EAAEqE,MAClCjF,IACN,OAGQ,UAAXkF,GACFguB,GAAM3vB,MACCA,MAEFA,KAAKrE,SClDR0L,GAAU,CAEdwoB,MAAO,SAAC3zB,EAAGC,OACL2zB,EAAO5zB,EAAEP,KAAK,SACdo0B,EAAQ5zB,EAAER,KAAK,gBACfm0B,EAAOC,GACD,EAEND,EAAOC,EACF,EAEF,GAIT/zB,OAAQ,SAACE,EAAGC,OACN2zB,EAAO5zB,EAAEP,OAAO8C,OAAOzC,OACvB+zB,EAAQ5zB,EAAER,OAAO8C,OAAOzC,cACxB8zB,EAAOC,EACF,EAELD,EAAOC,GACD,EAEH,GAITjE,UAAW,SAAC5vB,EAAGC,OACT2zB,EAAO5zB,EAAE4vB,YACTiE,EAAQ5zB,EAAE2vB,mBACVgE,EAAOC,EACF,EAELD,EAAOC,GACD,EAEH,OAmDHC,aAAe3oB,GAAQwoB,SACvBI,UAAY5oB,GAAQykB,UAG5B,IAAMoE,GAAW,CACflvB,OAAO,EACPmvB,UAAU,EACVC,KAAK,EACLC,YAAY,EACZC,OAAO,EACPC,eAAe,YAIF,SAASxiB,SAGR,UAFdA,EAAQA,GAAS,UAEiB,cAAVA,GAAmC,SAAVA,GA9D7CyiB,EAAS,GACPntB,EAAU,OACR,EACNY,aAAa,EACbF,YAAY,EACZnG,SAAS,IANWqL,EAgENjJ,MAxDZuJ,KAAKxL,SAAQ,SAAAd,OACXvB,EAAMuB,EAAEtB,KAAK0H,GACjBmtB,EAAO90B,GAAO80B,EAAO90B,IAAQ,EAC7B80B,EAAO90B,IAAQ,KAGjBuN,EAAIM,KAAK7E,MAAK,SAACxI,EAAGC,OACZ2zB,EAAOU,EAAOt0B,EAAEP,KAAK0H,IACrB0sB,EAAQS,EAAOr0B,EAAER,KAAK0H,WACtBysB,EAAOC,EACF,EAELD,EAAOC,GACD,EAEH,KAEF9mB,GAyCHinB,GAAS5uB,eAAeyM,GArCP,SAAS9E,OAC1BwnB,EAAQ,UACZxnB,EAAI8B,KAAK,CAAEvD,MAAO,CAAE1C,QAAQ,KAAU/G,SAAQ,SAAAf,GAC5CyzB,EAAMzzB,EAAEwK,MAAM,GAAGvG,IAAMjE,EAAEwK,MAAM,GAAG1C,OAAO3D,SAE3C8H,EAAIM,KAAON,EAAIM,KAAK7E,MAAK,SAACxI,EAAGC,UACvBs0B,EAAMv0B,EAAEiF,OAASsvB,EAAMt0B,EAAEgF,OACpB,EACEsvB,EAAMv0B,EAAEiF,OAASsvB,EAAMt0B,EAAEgF,QAC1B,EAEH,KAEF8H,EAyBEynB,CAAe1wB,MAKH,mBAFrB+N,EAAQ1G,GAAQ0G,IAAUA,SAGnBxE,KAAOvJ,KAAKuJ,KAAK7E,KAAKqJ,GACpB/N,MAEFA,KA5EM,IAASiJ,EAClBunB,EACEntB,WA8EU,eACZkG,EAAO,GAAGI,OAAO3J,KAAKuJ,aAC1BA,EAAOA,EAAKsE,UACL7N,KAAK8H,UAAUyB,WAIP,eACXA,EAAO,GAAGI,OAAO3J,KAAKuJ,MACtBzC,EAAM,UACVyC,EAAOA,EAAKnB,QAAO,SAAAnL,OACbvB,EAAMuB,EAAEtB,KAAK,WAAW8C,cACI,IAA5BqI,EAAIxF,eAAe5F,KAGvBoL,EAAIpL,IAAO,GACJ,MAEFsE,KAAK8H,UAAUyB,KC3IlBonB,GAAU,oEACVC,GAAS,mBAEC,CAEd7sB,WAAY,SAASkF,OACf4nB,EAAU5nB,EAAIM,KAAKvB,KAAI,SAAAgH,UAAMA,EAAGxH,WACpCqpB,EAAQ9yB,SAAQ,SAACyJ,EAAOxK,GACtBwK,EAAMzJ,SAAQ,SAACV,EAAGzB,IAEI,IAAhByB,EAAEyzB,WAKNzzB,EAAE6B,IAAM7B,EAAE6B,IAAIP,QAAQ,MAAO,IAC7BtB,EAAE8B,KAAO9B,EAAE8B,KAAKR,QAAQ,MAAO,KAE3B6I,EAAMxL,OAAS,IAAMJ,GAAMi1B,EAAQ7zB,EAAI,MAIvCK,EAAEuD,WAAgC,IAApBD,QAAQtD,EAAE1B,QAIN,IAAlB0B,EAAEgU,cAINhU,EAAE8B,MAAQ,OAnBR9B,EAAE8B,KAAO,aAwBjB8E,YAAa,SAAS0qB,GACpBA,EAAS5wB,SAAQ,SAAAV,IAEO,IAAlBA,EAAEgU,cACJhU,EAAE8B,KAAO,KAEX9B,EAAE6B,IAAM7B,EAAE6B,IAAIP,QAAQgyB,GAAS,IAC/BtzB,EAAE8B,KAAO9B,EAAE8B,KAAKR,QAAQgyB,GAAS,IAEjCtzB,EAAE8B,KAAO9B,EAAE8B,KAAKR,QAAQ,SAAU,KAET,IAArB,IAAIN,KAAKhB,EAAE8B,QACb9B,EAAE8B,KAAO9B,EAAE8B,KAAKR,QAAQ,KAAM,IAC9BtB,EAAE8B,KAAO,IAAM9B,EAAE8B,OAGO,IAAtB,KAAKd,KAAKhB,EAAE8B,QACd9B,EAAE8B,KAAO9B,EAAE8B,KAAKR,QAAQ,SAAU,IAClCtB,EAAE8B,KAAO,IAAM9B,EAAE8B,UAKvBvB,QAAS,SAAS+wB,GAChBA,EAAS5wB,SAAQ,SAAAV,IACQ,IAAnBA,EAAEqP,eAGNrP,EAAE1B,KAAO+C,EAAYrB,EAAE1B,WAI3Bo1B,WAAY,SAASpC,GACnBA,EAAS5wB,SAAQ,SAAAV,GACfA,EAAE8B,KAAO9B,EAAE8B,KAAKR,QAAQiyB,GAAQ,IAChCvzB,EAAE6B,IAAM7B,EAAE6B,IAAIP,QAAQiyB,GAAQ,QAIlCI,QAAS,SAAS/nB,GAChBA,EACGF,MAAM,WACNwjB,IAAI,sDACJ0E,UAIL9sB,cAAe,SAAS8E,GACtBA,EAAIM,KAAKxL,SAAQ,SAAAiR,OACXxH,EAAQwH,EAAGxH,QACfA,EAAMzJ,SAAQ,SAACV,EAAGzB,IACY,IAAxByB,EAAEqE,KAAK0C,cAAyBoD,EAAM5L,EAAI,KAC5CyB,EAAE8B,KAAO9B,EAAE8B,KAAKR,QAAQ,MAAO,aCtFnCuyB,GAAW,CAEfntB,YAAY,EACZnG,SAAS,EACTqG,aAAa,EACbktB,OAAO,EACPrtB,UAAU,EACVK,eAAe,QAGT,EACNitB,cAAc,EACdC,aAAa,EACbN,YAAY,EACZC,SAAS,EAGTM,aAAa,EACb7a,OAAO,EACPD,OAAO,EACP+a,YAAY,GAIRvZ,GAAU,CACdyF,MAAO,GACP+T,OAAQ,OAAQ,EAAMJ,cAAc,EAAMC,aAAa,EAAMN,YAAY,EAAMC,SAAS,OAElFS,MAAQ5zB,OAAOmH,OAAO,GAAIgT,GAAQwZ,OAAQ,CAAEF,aAAa,EAAM7a,OAAO,EAAMD,OAAO,EAAM+a,YAAY,IAG7G,kBAAoB,SAASluB,GAGJ,iBAFvBA,EAAUA,GAAW,MAGnBA,EAAU2U,GAAQ3U,IAAY,IAGhCA,EAAUxF,OAAOmH,OAAO,GAAIksB,GAAU7tB,QAEjCoqB,cAEDkB,EAAW3uB,KAAK2uB,kBAGhBtrB,aACG7E,cAIH6E,EAAQU,YACVsD,GAAQtD,WAAW/D,MAIjBqD,EAAQzF,SACVyJ,GAAQzJ,QAAQ+wB,GAIdtrB,EAAQY,aACVoD,GAAQpD,YAAY0qB,GAIlBtrB,EAAQ8tB,YACLF,OAAO,sBAIV5tB,EAAQS,eACLA,WAAW4tB,QAIdruB,EAAQc,eACVkD,GAAQlD,cAAcnE,OAMpBqD,EAAQsuB,aAAetuB,EAAQ+tB,oBAC5BA,eAAeQ,SAIlBvuB,EAAQguB,kBACLA,cAAcQ,UAGjBxuB,EAAQ0tB,YAAc1tB,EAAQutB,SAChCvpB,GAAQ0pB,WAAWpC,GAIjBtrB,EAAQ2tB,SACV3pB,GAAQ2pB,QAAQhxB,OAMdqD,EAAQyuB,YAAczuB,EAAQiuB,mBAC3BA,cAAcI,QAGjBruB,EAAQoT,YACLA,QAAQvT,gBAGXG,EAAQmT,OAASnT,EAAQ+nB,eACtB5U,QAAQhU,aAGXa,EAAQkuB,iBACLN,OAAO,cAGPjxB,2BCpHTD,UAAkB,SAASgB,OAEpBA,SACUf,KAAK6J,SACJkoB,QAAQ/xB,UAGpBgL,EAAOshB,GAAYvrB,GACnB6L,EAAU,eACTrD,KAAKxL,SAAQ,SAAAd,OACZ+0B,EAAU/0B,EAAE8L,MAAMiC,MAEC,IAAnBgnB,EAAQh2B,YAKRyV,EAAQxU,EACZ+0B,EAAQj0B,SAAQ,SAAAqB,OACV6yB,EAAQxgB,EAAMsgB,QAAQ3yB,GAEtB6yB,EAAMzuB,QACRoJ,EAAQhF,KAAKqqB,EAAMzuB,QAEjByuB,EAAMlpB,OACR6D,EAAQhF,KAAKqqB,EAAMlpB,OAGrB0I,EAAQwgB,EAAM5yB,SAGZoS,GACF7E,EAAQhF,KAAK6J,QAnBb7E,EAAQhF,KAAK3K,MAsBV+C,KAAK8H,UAAU8E,IAMxB7M,aAAqB,SAASgB,OAEvBA,SACUf,KAAK6J,SACJqoB,WAAWlyB,UAGvBgL,EAAOshB,GAAYvrB,GACnB6L,EAAU,eACTrD,KAAKxL,SAAQ,SAAAd,OACZ+0B,EAAU/0B,EAAE8L,MAAMiC,MAEC,IAAnBgnB,EAAQh2B,YAKRyV,EAAQxU,EACZ+0B,EAAQj0B,SAAQ,SAAAqB,OACV6yB,EAAQxgB,EAAMsgB,QAAQ3yB,GAEtB6yB,EAAMzuB,QAAUyuB,EAAMlpB,OAExBkpB,EAAMzuB,OAAOxH,QAAUi2B,EAAMlpB,MAAM/M,OACnC4Q,EAAQhF,KAAKqqB,EAAMzuB,SACVyuB,EAAMlpB,OACf6D,EAAQhF,KAAKqqB,EAAMlpB,OAGrB0I,EAAQwgB,EAAM5yB,SAGZoS,GACF7E,EAAQhF,KAAK6J,QApBb7E,EAAQhF,KAAK3K,MAuBV+C,KAAK8H,UAAU8E,IAExB7M,QAAgBA,EAAQmyB,WAGxBnyB,cAAsB,SAASgB,OAExBA,SACUf,KAAK6J,SACJsoB,YAAYnyB,UAGxBgL,EAAOshB,GAAYvrB,GACnB6L,EAAU,eACTrD,KAAKxL,SAAQ,SAAAd,OACZ+0B,EAAU/0B,EAAE8L,MAAMiC,MAEC,IAAnBgnB,EAAQh2B,YAKRyV,EAAQxU,EACZ+0B,EAAQj0B,SAAQ,SAAAqB,OACV6yB,EAAQxgB,EAAMsgB,QAAQ3yB,GAEtB6yB,EAAMzuB,QACRoJ,EAAQhF,KAAKqqB,EAAMzuB,QAGjByuB,EAAMlpB,OAASkpB,EAAM5yB,QACvB4yB,EAAMlpB,MAAM/M,QAAUi2B,EAAM5yB,MAAMrD,QAGpCyV,EAAQwgB,EAAMlpB,SAGZ0I,GACF7E,EAAQhF,KAAK6J,QApBb7E,EAAQhF,KAAK3K,MAuBV+C,KAAK8H,UAAU8E,IAIxB7M,UAAkB,SAASiL,EAAM3H,GAC/B2H,EAAOA,GAAQ,GACf3H,EAAUA,GAAW,CAAE1H,MAAM,OACzBsN,EAAMjJ,KACNlC,EAAOD,OAAOC,KAAKkN,UAEvBlN,EAAKC,SAAQ,SAAAnB,GACXqM,EAAMA,EAAI8oB,QAAQn1B,MAGpBqM,EAAIM,KAAKxL,SAAQ,SAAAd,OACV,IAAIrB,EAAI,EAAGA,EAAIkC,EAAK9B,OAAQJ,GAAK,KAChCqB,EAAEuvB,IAAI1uB,EAAKlC,gBACbqB,EAAEm1B,QAAUpnB,EAAKlN,EAAKlC,QAKrBqN,EAAIM,KAAKvB,KAAI,SAAA/K,OACd6N,EAAM7N,EAAE8N,KAAK1H,UACjByH,EAAIsnB,QAAUn1B,EAAEm1B,SAAW,KACpBtnB,SCpJLunB,gEAAW,SAASppB,EAAKiiB,OACzB9oB,EAAQ6G,EAAI7G,aAChB6G,EAAIM,KAAKxL,SAAQ,SAAAd,GACfA,EAAEuK,QAAQzJ,SAAQ,SAAAV,UAAKA,EAAE6tB,GAAI9oB,SAExB6G,oBAIa,kBACbopB,GAASryB,KAAM,4BAIF,kBACbqyB,GAASryB,KAAM,4BAIF,kBACbqyB,GAASryB,KAAM,4BAGF,uBACfuJ,KAAKxL,SAAQ,SAAAd,OAEZuK,EAAQvK,EAAEuK,QACdA,EAAMzJ,SAAQ,SAACV,EAAGzB,GACN,IAANA,GACFyB,EAAEi1B,cAEA12B,IAAM4L,EAAMxL,OAAS,IACvBqB,EAAE8B,KAAO,UAKRa,2BCpCTD,MAAc,SAASrE,EAAKiO,eACdtI,IAAR3F,EACKsE,KAAKuJ,KAAK,GAAG/B,MAAM,GAAGtI,UAE1BqK,KAAKxL,SAAQ,SAAAd,OACZuH,EAAOvH,EAAEuK,MAAM,IACJ,IAAXmC,EACFnF,EAAKtF,KAAOxD,EAEZ8I,EAAKtF,IAAMxD,KAGRsE,OAITD,OAAe,SAASrE,EAAKiO,eAEftI,IAAR3F,EACKsE,KAAKuJ,KAAKvB,KAAI,SAAA/K,OACfuK,EAAQvK,EAAEuK,eACHA,EAAMA,EAAMxL,OAAS,GACpBmD,cAIXoK,KAAKxL,SAAQ,SAAAd,OACZuK,EAAQvK,EAAEuK,QACVhD,EAAOgD,EAAMA,EAAMxL,OAAS,IACjB,IAAX2N,EACFnF,EAAKrF,MAAQzD,EAEb8I,EAAKrF,KAAOzD,KAGTsE,OAITD,OAAe,uBACRwJ,KAAOvJ,KAAKuJ,KAAKvB,KAAI,SAAA/K,UAAKA,EAAEwB,UAC1BuB,MAITD,YAAoB,uBACbwJ,KAAKxL,SAAQ,SAAAd,OACZuK,EAAQvK,EAAEuK,QAEdA,EAAMzJ,SAAQ,SAACV,EAAGzB,GACN,IAANA,IACFyB,EAAE6B,IAAM,IAENsI,EAAM5L,EAAI,KACZyB,EAAE8B,KAAO,WAIRa,MAITD,cAAsB,eACdsR,EAAY,sBACb9H,KAAKxL,SAAQ,SAAAd,GACJA,EAAEuK,QAERzJ,SAAQ,SAAAV,GACRgU,EAAUhT,KAAKhB,EAAE8B,QACnB9B,EAAE8B,KAAO,WAIRa,MAETD,cAAsBA,EAAQwyB,YAG9BxyB,eAAuB,SAASoB,EAAOC,UACrCD,EAAQA,OACRC,EAAMA,YACDmI,KAAKxL,SAAQ,SAAAd,OACZuK,EAAQvK,EAAEuK,QACdA,EAAM,GAAGtI,IAAMiC,EAAQqG,EAAM,GAAGtI,QAC5B8E,EAAOwD,EAAMA,EAAMxL,OAAS,GAChCgI,EAAK7E,KAAOiC,EAAM4C,EAAK7E,QAElBa,MAETD,cAAsBA,EAAQyyB,aAG9BzyB,gBAAwB,SAASoB,EAAOC,UACtCD,EAAQA,OACRC,EAAMA,YACDmI,KAAKxL,SAAQ,SAAAd,OACZuK,EAAQvK,EAAEuK,QACdA,EAAM,GAAGtI,IAAMiC,EAAQqG,EAAM,GAAGtI,QAC5B8E,EAAOwD,EAAMA,EAAMxL,OAAS,GAChCgI,EAAK7E,KAAOiC,EAAM4C,EAAK7E,QAElBa,qICrGM,SAAStE,QAEjB+xB,kBAEDzjB,EAAOhK,KAAKuJ,KAAK,GACjB/F,EAASwG,EAAKhO,OACdy2B,EAAU,GACL72B,EAAI,EAAGA,EAAIoE,KAAKuJ,KAAKvN,OAAQJ,IAAK,KACnCqB,EAAI+C,KAAKuJ,KAAK3N,GACpB62B,EAAQx1B,EAAEkE,QAAS,MACfqD,EAAOwF,EAAKtB,WAEZhN,IACF8I,EAAKrF,MAAQzD,GAGf8I,EAAKyC,KAAOhK,EAAEkE,MAEdlE,EAAEuK,MAAM,GAAGR,KAAOxC,EAAKvD,GACvB+I,EAAKhO,QAAUiB,EAAEjB,WAKf02B,EAAW1oB,EAAKhO,OAASwH,cACxBoG,UAAU7L,SAAQ,SAAAkL,GAErBA,EAAIM,KAAKxL,SAAQ,SAAAd,WACXuK,EAAQvK,EAAEuK,QACL5L,EAAI,EAAGA,EAAI4L,EAAMxL,OAAQJ,OAC5B4L,EAAM5L,GAAGqF,KAAO+I,EAAK7I,MAAO,CAC9BlE,EAAEjB,QAAU02B,YAMlBzpB,EAAIM,KAAON,EAAIM,KAAKnB,QAAO,SAAAnL,UAA0B,IAArBw1B,EAAQx1B,EAAEkE,aAGrCnB,KAAK8H,UAAU,CAACkC,OCzCnB2oB,GAAY,mBAMZC,GAAiB,SAAS91B,EAAG+1B,MAC5B/1B,EAAEsC,eAGHoI,EAAQ1K,EAAE6xB,WAEL/yB,EAAI,EAAGA,EAAI4L,EAAMxL,OAAS,EAAGJ,IAAK,KACnCyB,EAAImK,EAAM5L,MACZ+2B,GAAUt0B,KAAKhB,EAAE8B,aAMvBqI,EAAMzJ,SAAQ,SAAAV,GACZA,EAAEuD,SAAWvD,EAAEiC,SAGjBkI,EAAM,GAAG7L,MAAQk3B,EAEjBrrB,EAAMqD,MAAM,GAAG9M,SAAQ,SAAAV,GACrBA,EAAE1B,KAAO,UAEN,IAAIC,EAAI,EAAGA,EAAI4L,EAAMxL,OAAS,EAAGJ,IAAK,KACnCyB,EAAImK,EAAM5L,GAChByB,EAAE8B,KAAO9B,EAAE8B,KAAKR,QAAQ,IAAK,oBAKd,eACbsK,EAAMjJ,KAAKusB,IAAI,mBAEfzvB,EAAImM,EAAIF,MAAM,4BAClB6pB,GAAe91B,SAEfA,EAAImM,EAAIF,MAAM,gCACd6pB,GAAe91B,SAEfA,EAAImM,EAAIF,MAAM,0BACd6pB,GAAe91B,QAEfA,EAAImM,EAAIF,MAAM,cACd6pB,GAAe91B,QAEfA,EAAImM,EAAIF,MAAM,iBACd6pB,GAAe91B,QAEfA,EAAImM,EAAIF,MAAM,4DACd6pB,GAAe91B,SAEfA,EAAImM,EAAIF,MAAM,oBACd6pB,GAAe91B,SAEfA,EAAImM,EAAIF,MAAM,6BACd6pB,GAAe91B,SAEfA,EAAImM,EAAIF,MAAM,QACd6pB,GAAe91B,QAEfA,EAAImM,EAAIF,MAAM,YACP/I,UCnEQnC,OAAOmH,OACtB,GACAE,GACAC,GACAC,GACAC,GACAC,GACA8F,GAEA0nB,GACAC,GAEAC,GACAC,GACAC,GAEAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,ICtBEpsB,GAAU,GAGF,CACV,CAAC,QAAS,KACV,CAAC,aAAc,gBACf,CAAC,aAAc,cACf,CAAC,WAAY,YACb,CAAC,SAAU,UACX,CAAC,QAAS,UACV,CAAC,YAAa,aACd,CAAC,aAAc,cACf,CAAC,OAAQ,QACT,CAAC,UAAW,WACZ,CAAC,WAAY,YACb,CAAC,eAAgB,gBACjB,CAAC,eAAgB,iBAEftJ,SAAQ,SAAA7B,GACVmL,GAAQnL,EAAE,IAAM,SAASa,OACnBD,EAAIkD,KAAK+I,MAAM7M,EAAE,UACJ,iBAANa,IACTD,EAAIA,EAAE4K,IAAI3K,IAELD,SAIH42B,OAASrsB,GAAQ8pB,SACjBwC,WAAatsB,GAAQusB,cACrBtoB,MAAQjE,GAAQG,SAGhBqsB,aAAe,SAAS92B,OAC1BD,EAAIkD,KAAKkyB,WAAW,oBACxBp1B,EAAIA,EAAEiM,MAAM,iBACK,iBAANhM,IACTD,EAAIA,EAAE4K,IAAI3K,IAELD,MAIDg3B,MAAQ,SAAS/2B,OACnBD,EAAIkD,KAAK+I,MAAM,2BACF,iBAANhM,IACTD,EAAIA,EAAE4K,IAAI3K,IAELD,MAIDi3B,OAAS,SAASh3B,OAEpBigB,EAAOhd,KAAK+I,MAAM,2CAElBjM,EAAIkD,KAAKusB,IAAIvP,GAAMkV,WAAW,oBAElCp1B,EAAIA,EAAE6M,OAAOqT,IACXtY,KAAK,SACP5H,EAAIA,EAAEiM,MAAM,WACK,iBAANhM,IACTD,EAAIA,EAAE4K,IAAI3K,IAELD,MAIDk3B,cAAgB,SAASj3B,OAC3BD,EAAIkD,KAAKi0B,iBACbn3B,EAAIA,EAAEiM,MAAM,kBACK,iBAANhM,IACTD,EAAIA,EAAE4K,IAAI3K,IAELD,MAIDo3B,SAAW,SAASn3B,OACtBI,EAAI6C,KAAKi0B,UAETE,EAAMh3B,EAAEi3B,gBAIZD,GAFAA,GADAA,EAAMA,EAAIxqB,OAAOxM,EAAE42B,WACTpqB,OAAOxM,EAAE62B,kBAETzH,IADG,CAAC,UAAW,MAAO,QAAS,SAAU,UAAW,SAAU,YAGpE7nB,KAAK,YAEQ,iBAAN3H,IACTo3B,EAAMA,EAAIzsB,IAAI3K,IAETo3B,MAGDE,OAAShtB,GAAQ6sB,YACjBI,OAASjtB,GAAQ6sB,YAGjBxjB,UAAY,kBACX1Q,KAAKiL,OAGd,OAAiB5D,MCvGC,SAASktB,OAEnBC,mJAEG7F,WAAW5wB,SAAQ,SAAAV,IACM,IAAxBA,EAAEqE,KAAK0C,cAAyB/G,EAAE4J,OACpC5J,EAAE8B,KAAO9B,EAAE8B,KAAKR,QAAQ,MAAO,SAE7BjD,EAAM2B,EAAE1B,KAAKgD,QAAQ,KAAM,IAC/BtB,EAAE6M,IAAIxO,MAEDsE,sDAGF2uB,WAAW5wB,SAAQ,SAAAV,GACtBA,EAAE8B,KAAO9B,EAAE8B,KAAKR,QAAQ,MAAO,IAC/BtB,EAAE8B,KAAO,IAAM9B,EAAE8B,QAEZa,YAhBiBu0B,UAmB5BC,EAAcrtB,UAAU0qB,OAAS2C,EAAcrtB,UAAUstB,aAEzDF,EAAIptB,UAAUhD,cAAgB,SAASpH,OACjCgM,EAAQ/I,KAAK+I,MAAM,uBACN,iBAANhM,IACTgM,EAAQA,EAAMrB,IAAI3K,IAEb,IAAIy3B,EAAczrB,EAAMQ,KAAMvJ,KAAMA,KAAKoC,QAE3CmyB,GC9BHG,GAAY,QAEA,SAASH,OAEnBI,mJAEGhG,WAAW5wB,SAAQ,SAAAV,OAClB3B,EAAM2B,EAAE1B,KAAKgD,QAAQ,MAAO,IAChCtB,EAAE6M,IAAIxO,MAEDsE,sDAGF2uB,WAAW5wB,SAAQ,SAAAV,OAClB3B,EAAM2B,EAAE1B,KAAKgD,QAAQ,MAAO,IAChCjD,EAAMA,EAAID,MAAM,IAAIuC,KAAK,MAEM,IAA3B02B,GAAUr2B,KAAKhB,EAAE8B,QACnBzD,GAAO,KAET2B,EAAE6M,IAAIxO,MAEDsE,YAlBYu0B,UAqBvBI,EAASxtB,UAAU0qB,OAAS8C,EAASxtB,UAAUstB,aAC/CE,EAASxtB,UAAUuqB,MAAQiD,EAASxtB,UAAUstB,aAE9CF,EAAIptB,UAAUrD,SAAW,SAAS/G,OAC5BgM,EAAQ/I,KAAK+I,MAAM,kBACN,iBAANhM,IACTgM,EAAQA,EAAMrB,IAAI3K,IAEb,IAAI43B,EAAS5rB,EAAMQ,KAAMvJ,KAAMA,KAAKoC,QAEtCmyB,MCnCS,SAASA,UAEzBA,EAAIptB,UAAU8sB,QAAU,SAASl3B,OAE3B63B,EAAS50B,QAAQ,aAClB60B,MAAM,uBACNA,MAAM,6BACNA,MAAM,iCACNA,MAAM,8BACNA,MAAM,yBACN9rB,MAAM,aACL3J,EAAQY,KAAKkyB,WAAW0C,GAExBhE,EAASxxB,EAAM2xB,aAGfM,GAFJjyB,EAAQA,EAAM2yB,QAAQnB,IAEES,cAIpByD,GAHJ11B,EAAQA,EAAM2yB,QAAQV,OAGM,gEAAgEtoB,MAAM,gBAI9FgsB,GAHJ31B,EAAQA,EAAM+yB,YAAY2C,OAGD,oBAAoB/rB,MAAM,QAwB/CisB,GAdJ51B,GADAA,GAHAA,GADAA,GADAA,GAHAA,EAAQA,EAAM+yB,YAAY4C,IAGZ5C,YAAY,iBACZA,YAAY,cACZA,YAAY,qBAGZD,WAAW,kBACXA,WAAW,aAcL9pB,QAAO,SAAA/L,UAAKA,EAAEyvB,YAAc,GAAKzvB,EAAE0M,MAAM,UAAU/M,QAAU,QAC7Eg5B,EAAQ51B,MAAO,KACbtC,EAAIk4B,EAAQ9C,WAAW,4BAC3B9yB,EAAQA,EAAM2yB,QAAQj1B,EAAEkvB,GAAG,UAGZ,iBAANjvB,IACTqC,EAAQA,EAAMsI,IAAI3K,IAEb,IAAIw3B,EAAIn1B,EAAMmK,KAAMvJ,KAAMA,KAAKoC,QAEjCmyB,MC3DS,SAASA,OAEnBU,yBACQ1rB,EAAMoiB,EAAMvpB,mDAChBmH,EAAMoiB,EAAMvpB,KACb8yB,WAAa,qEAIb3rB,KAAKxL,SAAQ,SAAAd,OACZuK,EAAQvK,EAAEuK,QAEV2tB,EAAc3tB,EAAM,GAAGtH,cAE3BsH,EAAMzJ,SAAQ,SAACV,EAAGzB,GAEhByB,EAAE6M,IAAI7M,EAAEuD,UAAYvD,EAAE1B,MACtB0B,EAAEuD,cAAWS,EAGTzF,EAAI4L,EAAMxL,OAAS,GAAgB,KAAXqB,EAAE8B,OAC5B9B,EAAE8B,MAAQ,QAIVg2B,GACF3tB,EAAM,GAAG8qB,iBAGNtyB,YA3BgBu0B,UAyC3BA,EAAIptB,UAAUiqB,aAAe,SAASr0B,OAEhCqC,EAAQY,KAAK+I,MAAM,0BAEN,iBAANhM,IACTqC,EAAQA,EAAMsI,IAAI3K,IAEb,IAAIk4B,EAAa71B,EAAMmK,KAAMvJ,KAAMA,KAAKoC,QAIjDmyB,EAAIptB,UAAUiuB,SAAWb,EAAIptB,UAAUkuB,WACvCd,EAAIptB,UAAU+tB,WAAaX,EAAIptB,UAAUmuB,aAClCf,MCxDS,SAASA,OAEnB/I,EAAQ,SAASviB,OACjBorB,EAASprB,EAAIipB,WAAW,aAAa3F,IAAI,iBACzCgJ,EAAatsB,EAAIF,MAAM,sBACpB,CACLsrB,OAAQA,EACRmB,YAAavsB,EAAIF,MAAM,iBACvBwsB,WAAYA,EACZE,UAAWF,EAAW/I,IAAI,eAKxBkJ,8IAGK11B,KAAK+I,MAAM,mDAIX/I,KAAKkyB,WAAW,mEAIhBlyB,KAAKiyB,QAAQ4C,MAAM,4CAGxBn5B,eACGqC,SAAQ,SAAAd,OACPs4B,EAAa/J,EAAMvuB,GAAGs4B,WAC1BA,EAAWhrB,OAAO7O,GAElB65B,EAAW5G,SAAS,GAAGgH,eAAe,QAEjC31B,6CAIAA,qDAKAA,KAAKoI,QAAO,SAAAa,UAAOuiB,EAAMviB,GAAKwsB,6DAG9Bz1B,wDAGAA,YApCSu0B,UAwCpBmB,EAAMvuB,UAAUktB,OAASqB,EAAMvuB,UAAUyuB,MAEzCrB,EAAIptB,UAAU0uB,MAAQ,SAAS94B,OACzBD,EAAIkD,QAAQ,iCAGZ81B,EAAWh5B,EAAEiM,MAAM,4DACnBgtB,EAAUj5B,EAAEiM,MAAM,gEAClBitB,EAAWl5B,EAAEiM,MAAM,sDACnB9G,EAAS6zB,EAASnsB,OAAOosB,UAE7B9zB,GADAA,EAASA,EAAO0H,OAAOqsB,OACJ,aAEF,iBAANj5B,IACTkF,EAASnF,EAAE4K,IAAI3K,IAEV,IAAI24B,EAAMzzB,EAAOsH,KAAMvJ,KAAMA,KAAKoC,QAEpCmyB,MCpES,SAAStrB,UACE,IAAvBA,EAAIujB,IAAI,aAIc,IAAtBvjB,EAAIujB,IARR,uFCEIjV,GAAa,CACjB0e,KAAM,KACNC,KAAM,KACNC,SAAU,KACVC,OAAQ,KACRC,OAAQ,KACRC,MAAO,KACPC,KAAM,MAGFC,GAAc,CAClBt6B,GAAG,EACHI,GAAG,EACHC,GAAG,EACHE,GAAG,EACHb,GAAG,EACHiB,GAAG,EACHC,GAAG,EACHC,GAAG,EACHC,GAAG,EACHG,GAAG,EACHC,GAAG,EACHK,GAAG,GAGCg5B,GAAW,CACf,UACA,0BACA,YAGkB,SAASxtB,MAEvBA,EAAIujB,IAAI,YAAcvjB,EAAIujB,IAAI,gBACzB,MAGLvjB,EAAIujB,IAAI,iBACH,UAEL9wB,EAAMuN,EAAItN,KAAK,UAAU8C,UAEzB8Y,GAAWjW,eAAe5F,UACrB6b,GAAW7b,OAGhBg7B,EAAch7B,EAAIuK,OAAO,EAAG,MAC5BgD,EAAIujB,IAAI,gBAAkBgK,GAAYl1B,eAAeo1B,SAChD,SAGJ,IAAI96B,EAAI,EAAGA,EAAI66B,GAASz6B,OAAQJ,OAC/B66B,GAAS76B,GAAGyC,KAAK3C,SACZ,UAIP,YAAY2C,KAAK3C,GACZ,KAEF,QC/BQ,CACfi7B,WAvBiB,CACjB,gBACA,8CACA,iBACA,UACA,mBACA,UACA,4BACA,WACA,UACA,QACA,qBACA,SACA,kBACA,mBACA,gCACA,cACA,aACA,uCACA,SACA,4BAIAC,SAjCe,CACf,wCACA,6CACA,QACA,SACA,eCLIC,GAAO,QAII,SAASn7B,UAEpB2pB,GAAMsR,WAAWtsB,MAAK,SAAAtJ,UAAOA,EAAI1C,KAAK3C,SAInB,IAAnBm7B,GAAKx4B,KAAK3C,OAIV2pB,GAAMuR,SAASvsB,MAAK,SAAAtJ,UAAOA,EAAI1C,KAAK3C,OAGjC,QClBHo7B,GAAa,CACjBC,GAAI,MACJC,IAAK,OACLC,KAAM,SACNC,GAAI,OACJt7B,EAAG,OACHu7B,IAAK,QAELC,IAAK,OACLC,MAAO,SACPC,IAAK,OACLC,GAAI,OACJC,KAAM,YAIa,SAASvuB,OACxBvN,EAAMuN,EAAItN,KAAK,QAAQ8C,cAEvBq4B,GAAWx1B,eAAe5F,IAC5BuN,EAAI+kB,YAAY8I,GAAWp7B,IAAM,QACjCuN,EAAIxH,IAAI,aAAc,iBAIpB,KAAKpD,KAAK3C,IACZA,GAAO,IACPuN,EAAI+kB,YAAYtyB,GAAK,QACrBuN,EAAIxH,IAAI,aAAc,kBAIxB/F,GAAO,KACPuN,EAAI+kB,YAAYtyB,GAAK,QACrBuN,EAAIxH,IAAI,aAAc,qBChCV,SAASwH,OACjB6B,EAAM,CACRd,KAAMf,MAGJA,EAAIujB,IAAI,uBAAwB,KAC9B1vB,EAAImM,EAAIipB,WAAW,YACvBpnB,EAAId,KAAOlN,EAAEkvB,GAAG,GAChBlhB,EAAI3L,KAAOrC,EAAEkvB,GAAG,UAEXlhB,MCNO,CAEdC,KAAM,SAAS1H,OACTtG,EAAI,KACe,iBAAZsG,IACTtG,EAAIsG,EACJA,EAAU,MAEZA,EAAUA,GAAW,CAAE1H,MAAM,EAAM8H,QAAQ,EAAMhF,MAAM,EAAM+I,OAAO,OAChEsD,EAAM,eACL/M,SAAQ,SAAAkL,OACP8B,EAAO9B,EAAI8B,KAAK1H,GAAS,GAC7B0H,EAAK0sB,QAAUC,GAAWzuB,GAC1B6B,EAAIlD,KAAKmD,MAED,OAANhO,EACK+N,EAAI/N,GAEN+N,GAGTwM,WAAY,eACN/N,EAAOvJ,KAAKysB,UAAU,qEAE1BljB,GADAA,EAAOA,EAAKI,OAAO3J,KAAK0sB,WAAW,2BACvB3jB,MAAM,eACNrE,KAAK,UAGnBkyB,SAAU,kBACD52B,QAAQ,YAEjB23B,UAAW,kBACF33B,KAAKoI,QAAO,SAAA/L,UAAKs7B,GAAUt7B,OAEpC8a,SAAU,SAASygB,cACbzgB,EAAWnX,KAAKoC,MAAME,WAAW6U,qBAChCpZ,SAAQ,SAAAkL,OACPA,EAAIujB,IAAI,aAAiC,IAAnBmL,GAAU1uB,QAIhCe,EAAOwhB,GAAMviB,GAAKe,KAClBtO,EAAMsO,EAAKrO,KAAK,eACfqO,EAAKwiB,IAAI,eAAkC,IAAlBoK,GAASl7B,MAGvCA,EAAMyb,EAASzb,EAAKuM,EAAK7F,OACzB4H,EAAKrL,QAAQjD,GAAK+F,IAAI,WAElBm2B,GAAO,KACLC,EAAK7tB,EAAK8tB,WAAW,uBAAuBvL,IAAI,eACnC,IAAbsL,EAAGz4B,OACLy4B,EAAG5G,cAIFjxB,MAETwC,WAAY,SAASo1B,cACfp1B,EAAaxC,KAAKoC,MAAME,WAAWE,uBAClCzE,SAAQ,SAAAkL,OACPA,EAAIujB,IAAI,eAAmC,IAAnBmL,GAAU1uB,QAIlCe,EAAOwhB,GAAMviB,GAAKe,KAClBtO,EAAMsO,EAAKrO,KAAK,eACfqO,EAAKwiB,IAAI,aAAgC,IAAlBoK,GAASl7B,MAGrCA,EAAM8G,EAAW9G,EAAK0T,EAAKhN,OAC3B4H,EAAKrL,QAAQjD,GAAK+F,IAAI,aAElBm2B,GAAO,KAELz2B,EAAQ8H,EACR8uB,EAAM9uB,EAAI6uB,WAAW,cACrBC,EAAI34B,QACN+B,EAAQ42B,OAENN,EAAUC,GAAWv2B,GACzBA,EAAM62B,aAAaP,QAGhBz3B,MAETi4B,aAAc,uBACPl6B,SAAQ,SAAA1B,GACX47B,GAAa57B,MAER2D,UC9FO,SAASu0B,OAEnB2D,gGAAc3D,UAEpB12B,OAAOmH,OAAOkzB,EAAM/wB,UAAWE,IAE/BktB,EAAIptB,UAAUqP,MAAQ,SAASzZ,OAEzBigB,EAAOhd,KAAK+I,MAAM,2CAElBjM,EAAIkD,KAAKusB,IAAIvP,GAAMkV,WAAW,oBAWlCp1B,GADAA,GAFAA,GADAA,GADAA,GAFAA,GAFAA,EAAIA,EAAE6M,OAAOqT,IAEPjU,MAAM,iCAENwjB,IAAI,aACJA,IAAI,kBACJA,IAAI,sBAEJA,IAAI,gCACJA,IAAI,oBAEO,iBAANxvB,IACTD,EAAIA,EAAE4K,IAAI3K,IAEL,IAAIm7B,EAAMp7B,EAAEyM,KAAMvJ,KAAMA,KAAKoC,QAE/BmyB,GC9BH4D,GAAO,KACPC,GAAQ,QAEI,SAAS7D,OAEnB8D,6IAGG9uB,KAAKxL,SAAQ,SAAAd,OACZ2Q,EAAQ3Q,EAAEuK,MAAM,GACpBoG,EAAM1O,IAAM0O,EAAM1O,IAAIP,QAAQw5B,GAAM,QAChCn0B,EAAO/G,EAAEyL,WACb1E,EAAK7E,KAAO6E,EAAK7E,KAAKR,QAAQy5B,GAAO,OAEhCp4B,YATeu0B,UAa1BA,EAAIptB,UAAUkqB,YAAc,SAASt0B,OAC/BwM,EAAO,eACNA,KAAKxL,SAAQ,SAAAd,WACZuK,EAAQvK,EAAEuK,QAEL5L,EAAI,EAAGA,EAAI4L,EAAMxL,OAAQJ,GAAK,EAAG,KAClCyB,EAAImK,EAAM5L,MACZu8B,GAAK95B,KAAKhB,EAAE6B,SAET,IAAIlC,EAAIpB,EAAGoB,EAAIwK,EAAMxL,OAAQgB,GAAK,KACjCo7B,GAAM/5B,KAAKmJ,EAAMxK,GAAGmC,MAAO,KACzB6W,EAAMhZ,EAAIpB,EAAI,EAClB2N,EAAK3B,KAAK3K,EAAE6K,UAAUzK,EAAE4D,GAAI+U,IAC5Bpa,EAAIoB,aAQG,iBAAND,GAEPwM,EADEA,EAAKxM,GACA,CAACwM,EAAKxM,IAEN,GAEF,IAAIs7B,EAAY9uB,EAAMvJ,KAAMA,KAAKoC,QAEnC,IAAIi2B,EAAY9uB,EAAMvJ,KAAMA,KAAKoC,QAGnCmyB,MClDS,SAASA,OAEnB+D,yBACQ/uB,EAAMoiB,EAAMvpB,mDAChBmH,EAAMoiB,EAAMvpB,KACb8yB,WAAa,oEAIb3rB,KAAKxL,SAAQ,SAAAd,GACJA,EAAEuK,QACRzJ,SAAQ,SAAAV,OACR3B,EAAM2B,EAAE1B,KAAKgD,QAAQ,MAAO,IAChCtB,EAAE6M,IAAIxO,GAAO2B,EAAE1B,YAGZqE,YAdeu0B,UA4B1BA,EAAIptB,UAAUmqB,YAAc,SAASv0B,OAE/BqC,EAAQY,KAAK+I,MAAM,6BAEN,iBAANhM,IACTqC,EAAQA,EAAMsI,IAAI3K,IAEb,IAAIu7B,EAAYl5B,EAAMmK,KAAMvJ,KAAMA,KAAKoC,QAEzCmyB,GCvCHgE,GAAQ,KACF,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QAEA,QACA,QACA,QAEA,QACA,QACA,KAGNC,GAAUxrB,OAAO,IAAMnP,OAAOC,KAAKy6B,IAAOv6B,KAAK,KAAO,QCtBvC,SAASwB,EAAQ4C,OAChCq2B,EAAOj5B,EAAOi5B,KAGd/8B,EAAM+8B,EAAK98B,KAAK,aAChB88B,EAAKjM,IAAI,sBACJ9wB,MAILkH,EAAQ,YACR61B,EAAKjM,IAAI,cACX5pB,EAAQ,YACC61B,EAAKjM,IAAI,WAClB5pB,EAAQ,SACC61B,EAAKjM,IAAI,iBAClB5pB,EAAQ,eACC61B,EAAKjM,IAAI,eAClB5pB,EAAQ,aACC61B,EAAKjM,IAAI,YAClB5pB,EAAQ,SAEHR,EAAME,WAAWY,aAAaxH,EAAK0G,EAAOQ,OCXlC,SAASpD,OACpBk5B,EAAKl5B,EAAOi5B,QACZC,EAAGlM,IAAI,oBAAsBhtB,EAAOm5B,UAAUnM,IAAI,0BAC7C,KAELkM,EAAGlM,IAAI,mBAAqBhtB,EAAOm5B,UAAUnM,IAAI,yBAC5C,MAGLoM,EAjBW,SAASF,UACbA,EAAGhM,WAAW,UAAU1oB,OAgBxB60B,CAASH,WAChBE,EAAKpM,IAAI,qBAGToM,EAAKpM,IAAI,aAGToM,EAAKpM,IAAI,cAGN,UCtBU,SAAShtB,EAAQ4C,OAC9Bs2B,EAAKl5B,EAAOi5B,SAEZj5B,EAAO0C,SAAS9C,SAKhBI,EAAOm5B,UAAUv5B,MACnBI,EAAOm5B,UAAU3M,GAAG,GAAGzhB,OAAO,eAI5BmuB,EAAGlM,IAAI,6BACTkM,EAAGnuB,OAAO,eAIRmuB,EAAGlM,IAAI,cAAe,KACpBhV,EAAMtU,GAAa1D,EAAQ4C,UAC/Bs2B,EAAG1K,YAAYxW,GAAK,QACpBkhB,EAAGluB,QAAQ,cAITkuB,EAAGlM,IAAI,iBAAkB,KACvBhV,EAAMtU,GAAa1D,EAAQ4C,UAC/Bs2B,EAAG1K,YAAYxW,GAAK,QAChBof,GAASp3B,GACXk5B,EAAGluB,QAAQ,UAEXkuB,EAAGluB,QAAQ,gBAKXkuB,EAAGlM,IAAI,WAAY,KACjBhV,EAAMtU,GAAa1D,EAAQ4C,UAC/Bs2B,EAAG1K,YAAYxW,GAAK,QACpBkhB,EAAGluB,QAAQ,OAKTosB,GAASp3B,GACXk5B,EAAGluB,QAAQ,YAIbkuB,EAAGluB,QAAQ,eCzDK,SAASkuB,OACrBl5B,EAAS,CACXs5B,OAAQJ,EAAG3vB,MAAM,YACjB7G,SAAUw2B,EAAG3vB,MAAM,aACnB4vB,UAAWD,EAAG3vB,MAAM,cAAcwjB,IAAI,uBACtCwM,SAAUL,EAAG3vB,MAAM,aACnB0vB,KAAMC,EAAG3vB,MAAM,SAASwjB,IAAI,iDAGzB/sB,EAAOi5B,KAAKr5B,aAEfvB,OAAOC,KAAK0B,GAAQzB,SAAQ,SAAAnB,GAC1B4C,EAAO5C,GAAK4C,EAAO5C,GAAG2vB,IAAI,QAG5B/sB,EAAOi5B,KAAOC,EACPl5B,KAGLA,EAAOs5B,QAAUt5B,EAAOs5B,OAAO15B,MAAO,KACpC2J,EAAQvJ,EAAOs5B,OAAOn9B,KAAK,WAAa,IACxC+8B,EAAGlM,IAAIzjB,KACTvJ,EAAOw5B,aAAc,UAGlBx5B,MCvBI,SAAAA,OACPy5B,GAAM,EACN/hB,EAAS0f,GAASp3B,GAClB05B,EAAa15B,EAAO0C,SAAS9C,MAO7BI,EAAOi5B,KAAK/L,WAAW,4BAA4BttB,QACrD65B,GAAM,OAGJnyB,EAAM,CACRjE,UAAW,MACXE,aAAc,KACdwQ,YAAa,UACb5Q,WAAY,KACZG,OAAQ,QACRG,MAAO,GACPyQ,aAAc,OACdC,WAAY,eAGF,IAARslB,IACFnyB,EAAI/D,aAAe,KACnB+D,EAAInE,WAAa,MAEfuU,IACFpQ,EAAIjE,UAAY,OAChBiE,EAAI/D,aAAe,MACnB+D,EAAInE,WAAa,OAEfu2B,IACFpyB,EAAIjE,WAAa,OACjBiE,EAAI/D,cAAgB,OACpB+D,EAAIyM,YAAc,cAClBzM,EAAInE,YAAc,OAClBmE,EAAI4M,aAAe,OAAS5M,EAAI4M,aAChC5M,EAAI6M,WAAa,OAAS7M,EAAI6M,WAC9B7M,EAAIhE,OAAS,OAASgE,EAAIhE,QAErBgE,MC3CS,SAAStH,EAAQ4C,OAC7Bq2B,EAAOj5B,EAAOi5B,QAGdA,EAAKjM,IAAI,YAAsC,OAAvBiM,EAAKU,IAAI,WAAsB35B,EAAOm5B,UAAUnM,IAAI,eACvE4M,GAAK55B,OAGV6R,EAAY7R,EAAOi5B,KAAK9J,SAAS,GAAGtd,YAEpCgoB,EAAan2B,GAAa1D,EAAQ4C,OACjCi3B,QACI,OAEL5hB,EAAQrV,EAAME,WAAW+U,UAAUgiB,EAAYj3B,MACnDqV,EAAM9U,WAAa02B,EAGf75B,EAAOu5B,SAAS35B,MAAO,KACrB25B,EAAWv5B,EAAOu5B,SAASp9B,OAC3B29B,GAAsB,IAAdjoB,EAAqB,IAAM,IACvCxT,OAAOC,KAAK2Z,GAAO1Z,SAAQ,SAAAnB,UAAM6a,EAAM7a,IAAM08B,EAAQP,QAGnDv5B,EAAOs5B,OAAO15B,MAAO,KACnB05B,EAASt5B,EAAOs5B,OAAOn9B,OACvB29B,GAAsB,IAAdjoB,EAAqB,IAAM,KACZ,IAAvB7R,EAAOw5B,YACTn7B,OAAOC,KAAK2Z,GAAO1Z,SAAQ,SAAAnB,UAAM6a,EAAM7a,IAAM08B,EAAQR,KAErDj7B,OAAOC,KAAK2Z,GAAO1Z,SAAQ,SAAAnB,UAAM6a,EAAM7a,GAAKk8B,EAASQ,EAAQ7hB,EAAM7a,UAKjEs8B,EAAa15B,EAAO0C,SAAS9C,aAC/B85B,IACFzhB,EAAM5U,UAAY,WAAa4U,EAAM9U,WACrC8U,EAAM1U,aAAe,YAAc0U,EAAM9U,WACzC8U,EAAM3U,OAAS,OAAS2U,EAAM3U,QAG3B2U,EAAMlE,cAEPkE,EAAMlE,YADJ2lB,EACkB,YAAczhB,EAAM9U,WAEpB,QAAU8U,EAAM9U,YAGpCu2B,IACFzhB,EAAM9U,WAAa,OAAS8U,EAAM9U,YAE7B8U,MClDQ,CAEf1M,KAAM,SAAS1H,cACTtG,EAAI,KACe,iBAAZsG,IACTtG,EAAIsG,EACJA,EAAU,MAEZA,EAAUA,GAAW,CAAE1H,MAAM,EAAM8H,QAAQ,EAAMhF,MAAM,EAAM+I,OAAO,OAChEsD,EAAM,eACL/M,SAAQ,SAAAd,OACP8N,EAAO9N,EAAE8N,KAAK1H,GAAS,GACvB7D,EAAS+5B,GAAUt8B,GACvB8N,EAAKknB,MAAQ,GACbp0B,OAAOC,KAAK0B,GAAQzB,SAAQ,SAAAnB,GAC1BmO,EAAKknB,MAAMr1B,GAAK4C,EAAO5C,GAAGjB,KAAK,aAEjCoP,EAAKmuB,WAAaj8B,EAAEuvB,IAAI,aACxBzhB,EAAKwN,aAAelB,GAAU7X,EAAQyI,EAAK7F,OAC3C0I,EAAIlD,KAAKmD,MAED,OAANhO,EACK+N,EAAI/N,GAEN+N,GAITkmB,QAAS,eACHznB,EAAO,QAENxL,SAAQ,SAAA26B,OACPc,EAAOD,GAAUb,GAAII,OACrBU,EAAKp6B,QACPmK,EAAOA,EAAKI,OAAO6vB,EAAKjwB,cAIxBzM,EAAIkD,KAAK0sB,WAAW,oBACpB5vB,EAAEsC,QACJmK,EAAOzM,EAAEyM,KAAKI,OAAOJ,KAGvBzM,EAAIkD,KAAKysB,UAAU,cACbrtB,QACJmK,EAAOA,EAAKI,OAAO7M,EAAEyM,OAEhBvJ,KAAK8H,UAAUyB,IAGxBqtB,SAAU,sBACJrtB,EAAO,eACNxL,SAAQ,SAAA26B,OACPl5B,EAAS+5B,GAAUb,IACc,IAAjC9B,GAASp3B,EAAQ4P,EAAKhN,QACxBmH,EAAK3B,KAAK8wB,EAAGnvB,KAAK,OAGfvJ,KAAK8H,UAAUyB,IAGxBotB,WAAY,sBACNptB,EAAO,eACNxL,SAAQ,SAAA26B,OACPl5B,EAAS+5B,GAAUb,IACc,IAAjC9B,GAASp3B,EAAQgQ,EAAKpN,QACxBmH,EAAK3B,KAAK8wB,EAAGnvB,KAAK,OAGfvJ,KAAK8H,UAAUyB,IAIxB8N,UAAW,sBACLpV,EAAS,eACRlE,SAAQ,SAAA26B,OACPl5B,EAAS+5B,GAAUb,GACnBjhB,EAAQJ,GAAU7X,EAAQ0tB,EAAK9qB,OACnCH,EAAO2F,KAAK6P,MAEPxV,GAGTw3B,YAAa,kCACN17B,SAAQ,SAAA26B,OACPl5B,EAAS+5B,GAAUb,GACnBh9B,EAAM2b,GAAU7X,EAAQ2tB,EAAK/qB,OAAOS,UACpCnH,GACFg9B,EAAG1K,YAAYtyB,GAAK,MAIjBsE,MAGT05B,eAAgB,kCACT37B,SAAQ,SAAA26B,OACPl5B,EAAS+5B,GAAUb,GACnB5xB,EAAMuQ,GAAU7X,EAAQm6B,EAAKv3B,OAC7B1G,EAAMoL,EAAI/D,aAEV21B,EAAGhM,WAAW,4BAA4BttB,QAC5C1D,EAAMoL,EAAInE,YAERjH,IACFg9B,EAAG1K,YAAYtyB,GAAK,GACpBg9B,EAAGj3B,IAAI,oBAGJzB,MAGT45B,cAAe,kCACR77B,SAAQ,SAAA26B,OACPl5B,EAAS+5B,GAAUb,GACnBh9B,EAAM2b,GAAU7X,EAAQq6B,EAAKz3B,OAAOmR,YACpC7X,IACFg9B,EAAG1K,YAAYtyB,GAAK,GACpBg9B,EAAGj3B,IAAI,mBAGJzB,MAGTkD,aAAc,kCACPnF,SAAQ,SAAA26B,OACPl5B,EAAS+5B,GAAUb,GACnBh9B,EAAM2b,GAAU7X,EAAQs6B,EAAK13B,OAAOO,WACpCjH,IACFg9B,EAAG1K,YAAYtyB,GAAK,GACpBg9B,EAAGj3B,IAAI,kBAGJzB,MAGT+5B,SAAU,kCACHh8B,SAAQ,SAAA26B,OACPl5B,EAAS+5B,GAAUb,GACnBh9B,EAAM2b,GAAU7X,EAAQw6B,EAAK53B,OAAOU,OACpCpH,IACFg9B,EAAG1K,YAAYtyB,GAAK,GACpBg9B,EAAGj3B,IAAI,cAGJzB,MAITk5B,WAAY,kBACHl5B,QAAQ,cAGjBi6B,WAAY,kBACHj6B,KAAKk6B,KAAK,cAGnBC,WAAY,kCACL5wB,KAAKxL,SAAQ,SAAAd,OACZgM,EAAMmxB,EAAKtyB,UAAU,CAAC7K,IACtBuC,EAAS+5B,GAAUtwB,GACvBkxB,GAAW36B,EAAQyJ,EAAI7G,UAElBpC,MAGTq6B,WAAY,eACNv9B,EAAIkD,KAAK+I,MAAM,uBACfjM,EAAEsC,OACJtC,EAAEm0B,OAAO,UAEJjxB,KAAKixB,OAAO,eC/KjBqJ,GAAW,CACfp1B,GACAC,GACAC,GACAC,GACAC,GACA8F,GACA0nB,GACAC,GRgBgB,SAASwB,OAEnBgG,wIAGKv6B,YAHcu0B,UAOzBA,EAAIptB,UAAU4pB,WAAa,SAASh0B,OAC9BwM,EAAO,eACNA,KAAKxL,SAAQ,SAAAd,WACZuK,EAAQvK,EAAEuK,QAEL5L,EAAI,EAAGA,EAAI4L,EAAMxL,OAAQJ,GAAK,EAAG,KAClCyB,EAAImK,EAAM5L,MACZ48B,GAAQn6B,KAAKhB,EAAE6B,aACbs7B,GAAQn9B,EAAE6B,IAAI6J,MAAMyvB,KAAY,IAAI,GACpCiC,EAAOlC,GAAMiC,GAKRx9B,EAAIpB,EAAGoB,EAAIwK,EAAMxL,OAAQgB,GAAK,MACA,IAAjCwK,EAAMxK,GAAGmC,KAAKmB,QAAQm6B,GAAc,KAClCzkB,EAAMhZ,EAAIpB,EAAI,EAClB2N,EAAK3B,KAAK3K,EAAE6K,UAAUzK,EAAE4D,GAAI+U,IAC5Bpa,EAAIoB,aAQG,iBAAND,GAEPwM,EADEA,EAAKxM,GACA,CAACwM,EAAKxM,IAEN,GAEF,IAAIw9B,EAAWhxB,EAAMvJ,KAAMA,KAAKoC,QAElC,IAAIm4B,EAAWhxB,EAAMvJ,KAAMA,KAAKoC,QAGzCmyB,EAAIptB,UAAUypB,OAAS2D,EAAIptB,UAAU4pB,WAE9BwD,GSvES,SAASA,OAEnBmG,gGAAcnG,UAEpB12B,OAAOmH,OAAO01B,EAAMvzB,UAAWE,IAG/BqzB,EAAMvzB,UAAUwzB,OAASD,EAAMvzB,UAAUgzB,WAEzC5F,EAAIptB,UAAUsP,MAAQ,SAAS1Z,OACzBgM,EAAQ/I,KAAK+I,MAAM,mDAMnBiU,GAHJjU,GADAA,EAAQA,EAAMwjB,IAAI,cACJA,IAAI,cAGDxjB,MAAM,kCAEnBjM,EAAIiM,EAAMwjB,IAAIvP,GAAMkV,WAAW,oBAEnCp1B,EAAIA,EAAE6M,OAAOqT,IACXtY,KAAK,SAIP5H,EAAIA,KAAK,SAGQ,iBAANC,IACTD,EAAIA,EAAE4K,IAAI3K,IAEH,IAAI29B,EAAM59B,EAAEyM,KAAMvJ,KAAMA,KAAKoC,QAGjCmyB,GCpCS,SAASA,OAEnBqG,gGAAerG,UASrBA,EAAIptB,UAAUitB,OAAS,SAASr3B,OAC1BgM,EAAQ/I,KAAKkyB,WAAW,oBAC5BnpB,EAAQA,EAAMA,MAAM,YAGH,iBAANhM,IACTgM,EAAQA,EAAMrB,IAAI3K,IAEb,IAAI69B,EAAO7xB,EAAMQ,KAAMvJ,KAAMA,KAAKoC,QAEpCmyB,OFNM,SAASA,UAEtB12B,OAAOC,KAAK+8B,IAAS98B,SAAQ,SAAAnB,UAAM23B,EAAIptB,UAAUvK,GAAKi+B,GAAQj+B,MAE9D09B,GAASv8B,SAAQ,SAAA+8B,UAASA,EAAMvG,MACzBA,GGpBHltB,GAAU,CACdsP,KAAMzR,GACN61B,WAAY51B,IAORovB,yBACQhrB,EAAMoiB,EAAMvpB,6BACjBmH,KAAOA,EAEZ1L,OAAO6R,eAAe1P,KAAM,OAAQ,CAClC2P,YAAY,EACZE,MAAO8b,EACP/b,UAAU,SAGEvO,IAAVe,QAAgCf,IAATsqB,IACzBvpB,EAAQupB,EAAKvpB,OAGfvE,OAAO6R,eAAe1P,KAAM,QAAS,CACnC2P,YAAY,EACZE,MAAOzN,EACPwN,UAAU,IAKZ/R,OAAO6R,eAAe1P,KAAM,QAAS,CACnC0H,IAAK,kBAAMO,EAAKsB,KAAKvN,OAAS,KAGhC6B,OAAO6R,eAAe1P,KAAM,SAAU,CACpC0H,IAAK,kBAAMO,EAAKsB,KAAKvN,UAGvB6B,OAAO6R,eAAe1P,KAAM,MAAO,CACjC0H,IAAK,iBAAM,2DAMNmmB,GAAO7tB,4CAKVA,KAAKuJ,KAAKvN,OAAS,EACdgE,KAAKuJ,KAAK,GAAG9B,KAEfzH,KAAKiL,MAAM1B,KAAK,GAAG9B,cAK9B8sB,GAAIptB,UAAUW,UAAY,SAASyB,UACjCA,EAAOA,EAAKvB,KAAI,SAAA/K,UAAKA,EAAEmK,OAAM,MAEnB,IAAImtB,GAAIhrB,EAAMvJ,KAAMA,KAAKoC,QAKrCmyB,GAAIptB,UAAU6zB,SAAW,SAASt/B,OAC5B6N,EAAO8jB,GAAS3xB,EAAKsE,KAAKoC,MAAOpC,KAAKyH,eACnCzH,KAAK8H,UAAUyB,IAGxB1L,OAAOmH,OAAOuvB,GAAIptB,UAAWE,GAAQsP,MACrC9Y,OAAOmH,OAAOuvB,GAAIptB,UAAWE,GAAQ0zB,eAG9BxG,IAGP,IAAMxkB,GAAU,CACdkrB,MAAO,QACPC,IAAK,QACLrG,MAAO,OACPsG,KAAM,KACNC,OAAQ,MAEVv9B,OAAOC,KAAKiS,IAAShS,SAAQ,SAAAnB,UAAM23B,GAAIptB,UAAUvK,GAAK23B,GAAIptB,UAAU4I,GAAQnT,OAC5E,OAAiB23B,UC9EjB,SAAS8G,EAASC,OAEZl5B,EAAQk5B,EAGNC,EAAM,eAAS5/B,yDAAO,GAAIqb,yCAC1BA,GACF5U,EAAMo5B,SAASxkB,OAEbzN,EAAO8jB,GAAS1xB,EAAMyG,GACtB6G,EAAM,IAAIsrB,GAAIhrB,EAAM,KAAMnH,UAC9B6G,EAAI4kB,SACG5kB,UAITsyB,EAAIlO,SAAW,eAAS1xB,yDAAO,GAAIqb,yCAC7BA,GACF5U,EAAMo5B,SAASxkB,OAEbzN,EAAO8jB,GAAS1xB,EAAMyG,GACtB6G,EAAM,IAAIsrB,GAAIhrB,EAAM,KAAMnH,UACvB6G,GAITsyB,EAAIE,OAAS,SAASvQ,UACpBA,EAAGqJ,GAAKnyB,EAAOpC,KAAMyP,GAAQ7I,GAAMoJ,IAC5BhQ,MAITu7B,EAAIG,SAAW,SAAS3wB,OAClBxB,EAAOmyB,GAAS3wB,EAAM3I,UACnB,IAAImyB,GAAIhrB,EAAM,KAAMnH,IAI7Bm5B,EAAIn0B,MAAQ,kBACHi0B,EAASj5B,EAAMgF,UAIxBm0B,EAAII,QAAU,eAAS7Q,oEACrB1oB,EAAMu5B,QAAQ7Q,GACP9qB,MAITu7B,EAAIK,QC1DW,SD4DfL,SAAaA,EAAIM,KAEVN,EAGQF,CAAS,IAAI7Q"}